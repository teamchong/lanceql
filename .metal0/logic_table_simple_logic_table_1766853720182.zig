// Generated by metal0 --emit-logic-table
// Static library containing compiled @logic_table functions

const std = @import("std");
const runtime = @import("runtime");
const c_interop = @import("c_interop");

// Global allocator for logic_table functions
var __gpa = std.heap.GeneralPurposeAllocator(.{ .safety = true, .thread_safe = true }){};
pub var __global_allocator: std.mem.Allocator = __gpa.allocator();

pub const MathOps = struct {
    pub const __logic_table__ = true;

pub fn add(_: runtime.PyValue, x: f64, y: f64) f64 {
        _ = &x;
        _ = &y;
        _ = "Add two numbers.";
        return (x + y);
    }
pub fn multiply(_: runtime.PyValue, x: f64, y: f64) f64 {
        _ = &x;
        _ = &y;
        _ = "Multiply two numbers.";
        return (x * y);
    }
pub fn divide_safe(_: std.mem.Allocator, _: runtime.PyValue, x: f64, y: f64) !f64 {
        _ = &x;
        _ = &y;
        _ = "Safe division with epsilon for zero handling.";
        return try runtime.divideFloat(x, (y + 1e-8));
    }
pub fn power(_: runtime.PyValue, x: f64, y: f64) f64 {
        _ = &x;
        _ = &y;
        _ = "x raised to power y.";
        return (try runtime.builtins.pyPow(@as(f64, x), @as(f64, y)));
    }
    pub const methods = [_][]const u8{
        "add",
        "multiply",
        "divide_safe",
        "power",
    };
};

export fn MathOps_add(x: f64, y: f64) callconv(.c) f64 {
    return MathOps.add(undefined, x, y);
}

export fn MathOps_multiply(x: f64, y: f64) callconv(.c) f64 {
    return MathOps.multiply(undefined, x, y);
}

export fn MathOps_divide_safe(x: f64, y: f64) callconv(.c) f64 {
    return MathOps.divide_safe(undefined, x, y);
}

export fn MathOps_power(x: f64, y: f64) callconv(.c) f64 {
    return MathOps.power(undefined, x, y);
}


pub const ScoreOps = struct {
    pub const __logic_table__ = true;

pub fn weighted_score(_: runtime.PyValue, a: f64, b: f64, w: f64) f64 {
        _ = &a;
        _ = &b;
        _ = &w;
        _ = "Weighted combination of two scores.";
        return ((a * w) + (b * (1e0 - w)));
    }
pub fn sigmoid(_: std.mem.Allocator, _: runtime.PyValue, x: f64) !f64 {
        _ = &x;
        _ = "Sigmoid activation function.";
        return try runtime.divideFloat(1e0, (1e0 + (try runtime.builtins.pyPow(@as(f64, 2.718281828e0), @as(f64, -(x))))));
    }
pub fn clamp(_: runtime.PyValue, x: f64, min_val: f64, max_val: f64) f64 {
        _ = &x;
        _ = &min_val;
        _ = &max_val;
        _ = "Clamp value to range [min_val, max_val].";
        if ((x < min_val)) {
            return min_val;
        }
        if ((x > max_val)) {
            return max_val;
        }
        return x;
    }
    pub const methods = [_][]const u8{
        "weighted_score",
        "sigmoid",
        "clamp",
    };
};

export fn ScoreOps_weighted_score(a: f64, b: f64, w: f64) callconv(.c) f64 {
    return ScoreOps.weighted_score(undefined, a, b, w);
}

export fn ScoreOps_sigmoid(x: f64) callconv(.c) f64 {
    return ScoreOps.sigmoid(undefined, x);
}

export fn ScoreOps_clamp(x: f64, min_val: f64, max_val: f64) callconv(.c) f64 {
    return ScoreOps.clamp(undefined, x, min_val, max_val);
}


