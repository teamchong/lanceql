// Generated by metal0 --emit-logic-table
// Static library containing compiled @logic_table functions

const std = @import("std");
const runtime = @import("runtime");
const c_interop = @import("c_interop");

// Global allocator for logic_table functions
var __gpa = std.heap.GeneralPurposeAllocator(.{ .safety = true, .thread_safe = true }){};
pub var __global_allocator: std.mem.Allocator = __gpa.allocator();

pub const VectorOps = struct {
    pub const __logic_table__ = true;

    pub fn init(_: std.mem.Allocator) !@This() { return .{}; }


    pub fn dot_product(self: *const @This(), a: anytype, b: anytype) !f64 {
        _ = &self;
        _ = &a;
        _ = &b;
        var result: f64 = undefined;
        _ = &result;
        _ = "Compute dot product of two vectors.";
        result = 0.0;
        var i: isize = 0;
        while (i < @as(i64, @intCast(runtime.builtinLen(a)))) {
            result = (runtime.PyValue.from(result)).add(runtime.PyValue.from((mul_0: { const _lhs = runtime.container_dispatch.getAt(@TypeOf(a), a, @as(usize, @intCast(i))); const _rhs = runtime.container_dispatch.getAt(@TypeOf(b), b, @as(usize, @intCast(i))); break :mul_0 if (@TypeOf(_lhs) == []const u8) (if (_rhs < 0) "" else runtime.strRepeat(__global_allocator, _lhs, @as(usize, @intCast(_rhs)))) else _lhs * _rhs; })));
            i += 1;
        }
        return result;
    }

    pub fn sum_squares(self: *const @This(), a: anytype) !f64 {
        _ = &self;
        _ = &a;
        var result: f64 = undefined;
        _ = &result;
        _ = "Compute sum of squares (for L2 norm).";
        result = 0.0;
        var i: isize = 0;
        while (i < @as(i64, @intCast(runtime.builtinLen(a)))) {
            result = (runtime.PyValue.from(result)).add(runtime.PyValue.from((mul_1: { const _lhs = runtime.container_dispatch.getAt(@TypeOf(a), a, @as(usize, @intCast(i))); const _rhs = runtime.container_dispatch.getAt(@TypeOf(a), a, @as(usize, @intCast(i))); break :mul_1 if (@TypeOf(_lhs) == []const u8) (if (_rhs < 0) "" else runtime.strRepeat(__global_allocator, _lhs, @as(usize, @intCast(_rhs)))) else _lhs * _rhs; })));
            i += 1;
        }
        return result;
    }

    pub fn sum_values(self: *const @This(), a: anytype) !f64 {
        _ = &self;
        _ = &a;
        var result: f64 = undefined;
        _ = &result;
        _ = "Sum all values in array.";
        result = 0.0;
        var i: isize = 0;
        while (i < @as(i64, @intCast(runtime.builtinLen(a)))) {
            result = (runtime.PyValue.from(result)).add(runtime.PyValue.from(runtime.container_dispatch.getAt(@TypeOf(a), a, @as(usize, @intCast(i)))));
            i += 1;
        }
        return result;
    }

    pub fn min_value(self: *const @This(), a: anytype) !f64 {
        _ = &self;
        _ = &a;
        var result: @TypeOf(runtime.container_dispatch.getAt(@TypeOf(a), a, @as(usize, @intCast(0)))) = undefined;
        _ = &result;
        _ = "Find minimum value in array.";
        result = runtime.container_dispatch.getAt(@TypeOf(a), a, @as(usize, @intCast(0)));
        var i: isize = 0;
        while (i < @as(i64, @intCast(runtime.builtinLen(a)))) {
            if ((runtime.PyValue.from(runtime.container_dispatch.getAt(@TypeOf(a), a, @as(usize, @intCast(i)))).lt(runtime.PyValue.from(result)))) {
                result = runtime.container_dispatch.getAt(@TypeOf(a), a, @as(usize, @intCast(i)));
            }
            i += 1;
        }
        return result;
    }

    pub fn max_value(self: *const @This(), a: anytype) !f64 {
        _ = &self;
        _ = &a;
        var result: @TypeOf(runtime.container_dispatch.getAt(@TypeOf(a), a, @as(usize, @intCast(0)))) = undefined;
        _ = &result;
        _ = "Find maximum value in array.";
        result = runtime.container_dispatch.getAt(@TypeOf(a), a, @as(usize, @intCast(0)));
        var i: isize = 0;
        while (i < @as(i64, @intCast(runtime.builtinLen(a)))) {
            if ((runtime.PyValue.from(runtime.container_dispatch.getAt(@TypeOf(a), a, @as(usize, @intCast(i)))).gt(runtime.PyValue.from(result)))) {
                result = runtime.container_dispatch.getAt(@TypeOf(a), a, @as(usize, @intCast(i)));
            }
            i += 1;
        }
        return result;
    }
    pub const methods = [_][]const u8{
        "dot_product",
        "sum_squares",
        "sum_values",
        "min_value",
        "max_value",
    };
};

export fn VectorOps_dot_product(a: [*]f64, b: [*]f64, len: usize) callconv(.c) f64 {
    return VectorOps.dot_product(undefined, a[0..len], b[0..len]) catch 0.0;
}

export fn VectorOps_sum_squares(a: [*]f64, len: usize) callconv(.c) f64 {
    return VectorOps.sum_squares(undefined, a[0..len]) catch 0.0;
}

export fn VectorOps_sum_values(a: [*]f64, len: usize) callconv(.c) f64 {
    return VectorOps.sum_values(undefined, a[0..len]) catch 0.0;
}

export fn VectorOps_min_value(a: [*]f64, len: usize) callconv(.c) f64 {
    return VectorOps.min_value(undefined, a[0..len]) catch 0.0;
}

export fn VectorOps_max_value(a: [*]f64, len: usize) callconv(.c) f64 {
    return VectorOps.max_value(undefined, a[0..len]) catch 0.0;
}


