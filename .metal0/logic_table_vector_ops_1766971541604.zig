// Generated by metal0 --emit-logic-table
// Static library containing compiled @logic_table functions

const std = @import("std");
const runtime = @import("runtime");
const c_interop = @import("c_interop");

// Global allocator for logic_table functions
var __gpa = std.heap.GeneralPurposeAllocator(.{ .safety = true, .thread_safe = true }){};
pub var __global_allocator: std.mem.Allocator = __gpa.allocator();

pub const VectorOps = struct {
    pub const __logic_table__ = true;

    pub fn init(_: std.mem.Allocator) !@This() { return .{}; }


    pub fn dot_product(self: *const @This(), a: anytype, b: anytype) f64 {
        _ = &self;
        _ = &a;
        _ = &b;
        _ = "Compute dot product of two vectors using SIMD.";
        return (__m0_dotprod: { const __a = a; const __b = b; const __dim = @min(__a.len, __b.len);
// Infer element type from slice/array - use pointer.child for slices, array.child for arrays
const __TypeInfo = @typeInfo(@TypeOf(__a));
const __ElemType = switch (__TypeInfo) {
    .pointer => __TypeInfo.pointer.child,
    .array => __TypeInfo.array.child,
    else => f64,
};
// SIMD vectorized dot product using 4-element vectors
const __Vec4 = @Vector(4, __ElemType);
var __sum_vec: __Vec4 = @splat(0);
var __i: usize = 0;
// Main SIMD loop - process 4 elements at a time
const __simd_end = __dim & ~@as(usize, 3);
while (__i < __simd_end) : (__i += 4) {
    const __a_vec: __Vec4 = __a[__i..][0..4].*;
    const __b_vec: __Vec4 = __b[__i..][0..4].*;
    __sum_vec += __a_vec * __b_vec;
}
// Reduce SIMD vector to scalar
var __sum = @reduce(.Add, __sum_vec);
// Handle remainder elements
while (__i < __dim) : (__i += 1) {
    __sum += __a[__i] * __b[__i];
}
break :__m0_dotprod __sum;});
    }

    pub fn l2_distance(self: *const @This(), a: anytype, b: anytype) f64 {
        _ = &self;
        _ = &a;
        _ = &b;
        _ = "Compute L2 (Euclidean) distance between two vectors using SIMD.";
        return (__m1_l2dist: { const __a = a; const __b = b; const __dim = @min(__a.len, __b.len);
// Infer element type from slice/array
const __TypeInfo = @typeInfo(@TypeOf(__a));
const __ElemType = switch (__TypeInfo) {
    .pointer => __TypeInfo.pointer.child,
    .array => __TypeInfo.array.child,
    else => f64,
};
// SIMD vectorized L2 distance using 4-element vectors
const __Vec4 = @Vector(4, __ElemType);
var __sum_vec: __Vec4 = @splat(0);
var __i: usize = 0;
// Main SIMD loop - process 4 elements at a time
const __simd_end = __dim & ~@as(usize, 3);
while (__i < __simd_end) : (__i += 4) {
    const __a_vec: __Vec4 = __a[__i..][0..4].*;
    const __b_vec: __Vec4 = __b[__i..][0..4].*;
    const __diff_vec = __a_vec - __b_vec;
    __sum_vec += __diff_vec * __diff_vec;
}
// Reduce SIMD vector to scalar
var __sum = @reduce(.Add, __sum_vec);
// Handle remainder elements
while (__i < __dim) : (__i += 1) {
    const __diff = __a[__i] - __b[__i];
    __sum += __diff * __diff;
}
break :__m1_l2dist @sqrt(__sum);});
    }

    pub fn cosine_similarity(self: *const @This(), a: anytype, b: anytype) f64 {
        _ = &self;
        _ = &a;
        _ = &b;
        _ = "Compute cosine similarity between two vectors using SIMD.";
        return (__m2_cossim: { const __a = a; const __b = b; const __dim = @min(__a.len, __b.len);
// Infer element type from slice/array
const __TypeInfo = @typeInfo(@TypeOf(__a));
const __ElemType = switch (__TypeInfo) {
    .pointer => __TypeInfo.pointer.child,
    .array => __TypeInfo.array.child,
    else => f64,
};
// SIMD vectorized cosine similarity using 4-element vectors
const __Vec4 = @Vector(4, __ElemType);
var __dot_vec: __Vec4 = @splat(0);
var __norm_a_vec: __Vec4 = @splat(0);
var __norm_b_vec: __Vec4 = @splat(0);
var __i: usize = 0;
// Main SIMD loop - process 4 elements at a time
const __simd_end = __dim & ~@as(usize, 3);
while (__i < __simd_end) : (__i += 4) {
    const __a_vec: __Vec4 = __a[__i..][0..4].*;
    const __b_vec: __Vec4 = __b[__i..][0..4].*;
    __dot_vec += __a_vec * __b_vec;
    __norm_a_vec += __a_vec * __a_vec;
    __norm_b_vec += __b_vec * __b_vec;
}
// Reduce SIMD vectors to scalars
var __dot = @reduce(.Add, __dot_vec);
var __norm_a = @reduce(.Add, __norm_a_vec);
var __norm_b = @reduce(.Add, __norm_b_vec);
// Handle remainder elements
while (__i < __dim) : (__i += 1) {
    __dot += __a[__i] * __b[__i];
    __norm_a += __a[__i] * __a[__i];
    __norm_b += __b[__i] * __b[__i];
}
const __denom = @sqrt(__norm_a) * @sqrt(__norm_b);
break :__m2_cossim @as(f64, if (__denom > 0.0) __dot / __denom else 0.0);});
    }
    pub const methods = [_][]const u8{
        "dot_product",
        "l2_distance",
        "cosine_similarity",
    };
};

export fn VectorOps_dot_product(a: [*]f64, b: [*]f64, len: usize) callconv(.c) f64 {
    return VectorOps.dot_product(undefined, a[0..len], b[0..len]);
}

export fn VectorOps_l2_distance(a: [*]f64, b: [*]f64, len: usize) callconv(.c) f64 {
    return VectorOps.l2_distance(undefined, a[0..len], b[0..len]);
}

export fn VectorOps_cosine_similarity(a: [*]f64, b: [*]f64, len: usize) callconv(.c) f64 {
    return VectorOps.cosine_similarity(undefined, a[0..len], b[0..len]);
}


