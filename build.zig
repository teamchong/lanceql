const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    // === Platform Detection (comptime) ===
    // Auto-detect Metal support on macOS
    const use_metal = target.result.os.tag == .macos;
    const use_accelerate = target.result.os.tag == .macos;

    // === Core Modules ===
    const proto_mod = b.addModule("lanceql.proto", .{
        .root_source_file = b.path("src/proto/proto.zig"),
    });

    const io_mod = b.addModule("lanceql.io", .{
        .root_source_file = b.path("src/io/io.zig"),
    });

    const encoding_mod = b.addModule("lanceql.encoding", .{
        .root_source_file = b.path("src/encoding/encoding.zig"),
    });

    const value_mod = b.addModule("lanceql.value", .{
        .root_source_file = b.path("src/value.zig"),
    });

    // Metal/Accelerate module for macOS GPU acceleration (defined early for query module)
    const metal_mod = b.addModule("lanceql.metal", .{
        .root_source_file = b.path("src/metal/metal.zig"),
    });

    const query_mod = b.addModule("lanceql.query", .{
        .root_source_file = b.path("src/query/query.zig"),
        .imports = &.{
            .{ .name = "lanceql.value", .module = value_mod },
            .{ .name = "lanceql.metal", .module = metal_mod },
        },
    });

    const format_mod = b.addModule("lanceql.format", .{
        .root_source_file = b.path("src/format/format.zig"),
        .imports = &.{
            .{ .name = "lanceql.proto", .module = proto_mod },
            .{ .name = "lanceql.io", .module = io_mod },
        },
    });

    const parquet_encoding_mod = b.addModule("lanceql.encoding.parquet", .{
        .root_source_file = b.path("src/encoding/parquet/parquet_encoding.zig"),
        .imports = &.{
            .{ .name = "lanceql.proto", .module = proto_mod },
            .{ .name = "lanceql.format", .module = format_mod },
        },
    });

    // SQL modules
    const sql_ast_mod = b.addModule("lanceql.sql.ast", .{
        .root_source_file = b.path("src/sql/ast.zig"),
    });

    const sql_lexer_mod = b.addModule("lanceql.sql.lexer", .{
        .root_source_file = b.path("src/sql/lexer.zig"),
    });

    const sql_parser_mod = b.addModule("lanceql.sql.parser", .{
        .root_source_file = b.path("src/sql/parser.zig"),
        .imports = &.{
            .{ .name = "ast", .module = sql_ast_mod },
            .{ .name = "lexer", .module = sql_lexer_mod },
        },
    });

    // Column dependency extraction for @logic_table
    const sql_column_deps_mod = b.addModule("lanceql.sql.column_deps", .{
        .root_source_file = b.path("src/sql/column_deps.zig"),
        .imports = &.{
            .{ .name = "ast", .module = sql_ast_mod },
        },
    });

    // Batch code generator for @logic_table GPU/SIMD dispatch
    _ = b.addModule("lanceql.sql.batch_codegen", .{
        .root_source_file = b.path("src/sql/batch_codegen.zig"),
        .imports = &.{
            .{ .name = "ast", .module = sql_ast_mod },
            .{ .name = "column_deps", .module = sql_column_deps_mod },
        },
    });

    const table_mod = b.addModule("lanceql.table", .{
        .root_source_file = b.path("src/table.zig"),
        .imports = &.{
            .{ .name = "lanceql.format", .module = format_mod },
            .{ .name = "lanceql.proto", .module = proto_mod },
            .{ .name = "lanceql.encoding", .module = encoding_mod },
        },
    });

    const parquet_table_mod = b.addModule("lanceql.parquet_table", .{
        .root_source_file = b.path("src/parquet_table.zig"),
        .imports = &.{
            .{ .name = "lanceql.format", .module = format_mod },
            .{ .name = "lanceql.encoding.parquet", .module = parquet_encoding_mod },
        },
    });

    // Logic table static library - compiled @logic_table functions from metal0
    // Generated by: metal0 build --emit-logic-table <python_file> -o lib/logic_table.a
    // The .a file contains all @logic_table structs with metal0 runtime bundled
    //
    // Build option to specify the path (defaults to lib/logic_table.a)
    const logic_table_lib_opt = b.option([]const u8, "logic-table-lib", "Path to logic_table.a static library");

    // Logic table module - provides LogicTableContext, LogicTableRegistry, etc.
    const logic_table_mod = b.addModule("lanceql.logic_table", .{
        .root_source_file = b.path("src/logic_table/logic_table.zig"),
        .imports = &.{
            .{ .name = "lanceql.table", .module = table_mod },
        },
    });

    // metal0 module - Python to native compiler (as submodule)
    const metal0_mod = b.addModule("metal0", .{
        .root_source_file = b.path("deps/metal0/src/main.zig"),
    });

    // Query expression module - for predicate fusion in codegen
    const query_expr_mod = b.addModule("lanceql.query.expr", .{
        .root_source_file = b.path("src/query/expr.zig"),
        .imports = &.{
            .{ .name = "lanceql.value", .module = value_mod },
        },
    });

    // Codegen module - JIT compilation integration with metal0
    const codegen_mod = b.addModule("lanceql.codegen", .{
        .root_source_file = b.path("src/codegen/metal0_jit.zig"),
        .imports = &.{
            .{ .name = "metal0", .module = metal0_mod },
            .{ .name = "lanceql.format", .module = format_mod },
            .{ .name = "lanceql.proto", .module = proto_mod },
            .{ .name = "lanceql.query.expr", .module = query_expr_mod },
        },
    });

    // Helper to link logic_table.a to a compile step
    const linkLogicTableLib = struct {
        fn link(step: *std.Build.Step.Compile, lib_path: ?[]const u8, builder: *std.Build) void {
            if (lib_path) |path| {
                // User-specified path
                step.addObjectFile(.{ .cwd_relative = path });
            } else {
                // Default path - only link if file exists
                const default_path = builder.path("lib/logic_table.a");
                step.addObjectFile(default_path);
            }
        }
    }.link;

    _ = linkLogicTableLib; // Available for executables that need logic_table
    _ = logic_table_lib_opt; // Used by linkLogicTableLib

    const sql_executor_mod = b.addModule("lanceql.sql.executor", .{
        .root_source_file = b.path("src/sql/executor.zig"),
        .imports = &.{
            .{ .name = "ast", .module = sql_ast_mod },
            .{ .name = "parser", .module = sql_parser_mod },
            .{ .name = "lanceql.table", .module = table_mod },
            .{ .name = "lanceql.logic_table", .module = logic_table_mod },
        },
    });

    const sql_dispatch_mod = b.addModule("lanceql.sql.logic_table_dispatch", .{
        .root_source_file = b.path("src/sql/logic_table_dispatch.zig"),
        .imports = &.{
            .{ .name = "ast", .module = sql_ast_mod },
            .{ .name = "lanceql.logic_table", .module = logic_table_mod },
        },
    });
    _ = sql_dispatch_mod; // Used in SQL tests and CLI

    const dataframe_mod = b.addModule("lanceql.dataframe", .{
        .root_source_file = b.path("src/dataframe.zig"),
        .imports = &.{
            .{ .name = "lanceql.value", .module = value_mod },
            .{ .name = "lanceql.query", .module = query_mod },
            .{ .name = "lanceql.table", .module = table_mod },
        },
    });

    // Root module exports all
    const lanceql_mod = b.addModule("lanceql", .{
        .root_source_file = b.path("src/lanceql.zig"),
        .imports = &.{
            .{ .name = "lanceql.format", .module = format_mod },
            .{ .name = "lanceql.io", .module = io_mod },
            .{ .name = "lanceql.proto", .module = proto_mod },
            .{ .name = "lanceql.encoding", .module = encoding_mod },
            .{ .name = "lanceql.table", .module = table_mod },
            .{ .name = "lanceql.query", .module = query_mod },
            .{ .name = "lanceql.value", .module = value_mod },
            .{ .name = "lanceql.dataframe", .module = dataframe_mod },
            .{ .name = "lanceql.metal", .module = metal_mod },
            .{ .name = "lanceql.logic_table", .module = logic_table_mod },
            .{ .name = "lanceql.codegen", .module = codegen_mod },
        },
    });

    // Pass build options to metal module
    const build_options = b.addOptions();
    build_options.addOption(bool, "use_metal", use_metal);
    build_options.addOption(bool, "use_accelerate", use_accelerate);
    metal_mod.addOptions("build_options", build_options);

    // === Tests ===
    const test_footer = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("tests/test_footer.zig"),
            .target = target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "lanceql", .module = lanceql_mod },
                .{ .name = "lanceql.format", .module = format_mod },
            },
        }),
    });

    const test_proto = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("tests/test_proto.zig"),
            .target = target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "lanceql", .module = lanceql_mod },
                .{ .name = "lanceql.proto", .module = proto_mod },
            },
        }),
    });

    const test_integration = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("tests/test_integration.zig"),
            .target = target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "lanceql", .module = lanceql_mod },
                .{ .name = "lanceql.format", .module = format_mod },
                .{ .name = "lanceql.io", .module = io_mod },
                .{ .name = "lanceql.proto", .module = proto_mod },
                .{ .name = "lanceql.encoding", .module = encoding_mod },
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });

    // Run tests
    const run_test_footer = b.addRunArtifact(test_footer);
    const run_test_proto = b.addRunArtifact(test_proto);
    const run_test_integration = b.addRunArtifact(test_integration);

    const test_step = b.step("test", "Run all unit tests");
    test_step.dependOn(&run_test_footer.step);
    test_step.dependOn(&run_test_proto.step);
    test_step.dependOn(&run_test_integration.step);

    const test_footer_step = b.step("test-footer", "Run footer tests");
    test_footer_step.dependOn(&run_test_footer.step);

    const test_proto_step = b.step("test-proto", "Run protobuf tests");
    test_proto_step.dependOn(&run_test_proto.step);

    const test_integration_step = b.step("test-integration", "Run integration tests with real .lance files");
    test_integration_step.dependOn(&run_test_integration.step);

    // Parquet parser tests - use ReleaseFast for benchmark
    const test_parquet = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("tests/test_parquet.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.format", .module = format_mod },
                .{ .name = "lanceql.encoding.parquet", .module = parquet_encoding_mod },
            },
        }),
    });

    const run_test_parquet = b.addRunArtifact(test_parquet);
    test_step.dependOn(&run_test_parquet.step);

    const test_parquet_step = b.step("test-parquet", "Run Parquet parser tests");
    test_parquet_step.dependOn(&run_test_parquet.step);

    // Query module tests (with Metal/Accelerate for logic_table)
    const test_query = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/query/query.zig"),
            .target = target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "lanceql.value", .module = value_mod },
                .{ .name = "lanceql.metal", .module = metal_mod },
            },
        }),
    });

    // Link macOS frameworks for Metal/Accelerate support in logic_table tests
    if (use_metal) {
        test_query.root_module.linkFramework("Metal", .{});
        test_query.root_module.linkFramework("Foundation", .{});
        test_query.root_module.addCSourceFiles(.{
            .files = &.{"src/metal/metal_backend.m"},
            .flags = &.{ "-fobjc-arc", "-fno-objc-exceptions" },
        });
    }
    if (use_accelerate) {
        test_query.root_module.linkFramework("Accelerate", .{});
    }

    const run_test_query = b.addRunArtifact(test_query);
    test_step.dependOn(&run_test_query.step);

    const test_query_step = b.step("test-query", "Run query module tests");
    test_query_step.dependOn(&run_test_query.step);

    // Value module tests
    const test_value = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/value.zig"),
            .target = target,
            .optimize = optimize,
        }),
    });

    const run_test_value = b.addRunArtifact(test_value);
    test_step.dependOn(&run_test_value.step);

    // DataFrame module tests
    const test_dataframe = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/dataframe.zig"),
            .target = target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "lanceql.value", .module = value_mod },
                .{ .name = "lanceql.query", .module = query_mod },
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });

    const run_test_dataframe = b.addRunArtifact(test_dataframe);
    test_step.dependOn(&run_test_dataframe.step);

    // LogicTable end-to-end tests (with Metal/Accelerate for GPU acceleration)
    const test_logic_table_e2e = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("tests/test_logic_table_e2e.zig"),
            .target = target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "lanceql", .module = lanceql_mod },
                .{ .name = "lanceql.format", .module = format_mod },
                .{ .name = "lanceql.table", .module = table_mod },
                .{ .name = "lanceql.query", .module = query_mod },
            },
        }),
    });

    // Link macOS frameworks for Metal/Accelerate support
    if (use_metal) {
        test_logic_table_e2e.root_module.linkFramework("Metal", .{});
        test_logic_table_e2e.root_module.linkFramework("Foundation", .{});
        test_logic_table_e2e.root_module.addCSourceFiles(.{
            .files = &.{"src/metal/metal_backend.m"},
            .flags = &.{ "-fobjc-arc", "-fno-objc-exceptions" },
        });
    }
    if (use_accelerate) {
        test_logic_table_e2e.root_module.linkFramework("Accelerate", .{});
    }

    const run_test_logic_table_e2e = b.addRunArtifact(test_logic_table_e2e);
    test_step.dependOn(&run_test_logic_table_e2e.step);

    const test_logic_table_step = b.step("test-logic-table", "Run @logic_table end-to-end tests");
    test_logic_table_step.dependOn(&run_test_logic_table_e2e.step);

    const test_dataframe_step = b.step("test-dataframe", "Run DataFrame module tests");
    test_dataframe_step.dependOn(&run_test_dataframe.step);

    // Metal module tests (with framework linking on macOS)
    const test_metal = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/metal/metal.zig"),
            .target = target,
            .optimize = optimize,
        }),
    });

    // Link Accelerate framework on macOS for vDSP
    if (use_accelerate) {
        test_metal.root_module.linkFramework("Accelerate", .{});
    }

    const run_test_metal = b.addRunArtifact(test_metal);
    test_step.dependOn(&run_test_metal.step);

    const test_metal_step = b.step("test-metal", "Run Metal/Accelerate module tests");
    test_metal_step.dependOn(&run_test_metal.step);

    // Vector benchmark (Metal/Accelerate)
    const bench_vector = b.addExecutable(.{
        .name = "bench_vector",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_vector_ops.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });
    const run_bench_vector = b.addRunArtifact(bench_vector);
    const bench_vector_step = b.step("bench-vector", "FAIR end-to-end: L2 norm (vector ops)");
    bench_vector_step.dependOn(&run_bench_vector.step);

    // SQL clause benchmark
    const bench_sql = b.addExecutable(.{
        .name = "bench_sql",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_sql_clauses.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });
    const run_bench_sql = b.addRunArtifact(bench_sql);
    const bench_sql_step = b.step("bench-sql", "FAIR end-to-end: SQL clauses (FILTER, AGGREGATE)");
    bench_sql_step.dependOn(&run_bench_sql.step);

    // @logic_table benchmark - uses REAL metal0 compiled lib/vector_ops.a
    // Build with: metal0 build --emit-logic-table benchmarks/vector_ops.py -o lib/vector_ops.a
    const bench_logic_table = b.addExecutable(.{
        .name = "bench_logic_table",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_logic_table.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });
    // Link the REAL metal0-compiled static library
    bench_logic_table.addObjectFile(b.path("lib/vector_ops.a"));
    const run_bench_logic_table = b.addRunArtifact(bench_logic_table);
    const bench_logic_table_step = b.step("bench-logic-table", "Benchmark REAL @logic_table (metal0 compiled Python)");
    bench_logic_table_step.dependOn(&run_bench_logic_table.step);

    // Compiled @logic_table benchmark (uses actual .a library from metal0)
    const bench_compiled = b.addExecutable(.{
        .name = "bench_compiled_logic_table",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_compiled_logic_table.zig"),
            .target = target,
            .optimize = .ReleaseFast,
        }),
    });
    // Link the compiled @logic_table static library
    bench_compiled.addObjectFile(b.path("lib/vector_ops.a"));
    const run_bench_compiled = b.addRunArtifact(bench_compiled);
    const bench_compiled_step = b.step("bench-compiled-logic-table", "Benchmark compiled @logic_table (Python -> native via metal0)");
    bench_compiled_step.dependOn(&run_bench_compiled.step);

    // @logic_table End-to-End benchmark - full pipeline with comparisons
    const bench_logic_table_e2e = b.addExecutable(.{
        .name = "bench_logic_table_e2e",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_logic_table_e2e.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });
    // Link the compiled @logic_table static library
    bench_logic_table_e2e.addObjectFile(b.path("lib/vector_ops.a"));
    const run_bench_logic_table_e2e = b.addRunArtifact(bench_logic_table_e2e);
    const bench_logic_table_e2e_step = b.step("bench-logic-table-e2e", "End-to-end @logic_table benchmark with DuckDB/Polars comparison");
    bench_logic_table_e2e_step.dependOn(&run_bench_logic_table_e2e.step);

    // @logic_table Pushdown benchmark - demonstrates filtered_indices optimization
    const bench_pushdown = b.addExecutable(.{
        .name = "bench_pushdown",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_pushdown.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });
    const run_bench_pushdown = b.addRunArtifact(bench_pushdown);
    const bench_pushdown_step = b.step("bench-pushdown", "Benchmark @logic_table pushdown (filtered_indices optimization)");
    bench_pushdown_step.dependOn(&run_bench_pushdown.step);

    // Tiered dispatch benchmark - SIMD vs GPU for batch vector operations
    const bench_tiered = b.addExecutable(.{
        .name = "bench_tiered_dispatch",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_tiered_dispatch.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });
    const run_bench_tiered = b.addRunArtifact(bench_tiered);
    const bench_tiered_step = b.step("bench-tiered", "FAIR end-to-end: SIMD dot product");
    bench_tiered_step.dependOn(&run_bench_tiered.step);

    // Parquet benchmark - LanceQL vs DuckDB vs Polars
    const bench_parquet = b.addExecutable(.{
        .name = "bench_parquet",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_parquet.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.format", .module = format_mod },
                .{ .name = "lanceql.encoding.parquet", .module = parquet_encoding_mod },
            },
        }),
    });
    b.installArtifact(bench_parquet);
    const bench_parquet_step = b.step("bench-parquet", "Benchmark Parquet reading: LanceQL vs DuckDB vs Polars");
    bench_parquet_step.dependOn(&b.addInstallArtifact(bench_parquet, .{}).step);

    // In-process benchmark: LanceQL vs DuckDB C API (FAIR comparison)
    const bench_inprocess = b.addExecutable(.{
        .name = "bench_inprocess",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_inprocess.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });
    const run_bench_inprocess = b.addRunArtifact(bench_inprocess);
    const bench_inprocess_step = b.step("bench-inprocess", "FAIR end-to-end: LanceQL vs DuckDB vs Polars");
    bench_inprocess_step.dependOn(&run_bench_inprocess.step);

    // RAG Pipeline benchmark - end-to-end document retrieval
    const bench_rag = b.addExecutable(.{
        .name = "bench_rag_pipeline",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_rag_pipeline.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });
    const run_bench_rag = b.addRunArtifact(bench_rag);
    const bench_rag_step = b.step("bench-rag", "FAIR end-to-end: similarity search (RAG pipeline)");
    bench_rag_step.dependOn(&run_bench_rag.step);

    // Hybrid Search benchmark - vector + SQL filters
    const bench_hybrid = b.addExecutable(.{
        .name = "bench_hybrid_search",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_hybrid_search.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.metal", .module = metal_mod },
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });
    if (use_metal) {
        bench_hybrid.root_module.linkFramework("Metal", .{});
        bench_hybrid.root_module.linkFramework("Foundation", .{});
        bench_hybrid.root_module.addCSourceFiles(.{
            .files = &.{"src/metal/metal_backend.m"},
            .flags = &.{ "-fobjc-arc", "-fno-objc-exceptions" },
        });
    }
    if (use_accelerate) {
        bench_hybrid.root_module.linkFramework("Accelerate", .{});
    }
    const run_bench_hybrid = b.addRunArtifact(bench_hybrid);
    const bench_hybrid_step = b.step("bench-hybrid", "Hybrid search: vector similarity + SQL filters");
    bench_hybrid_step.dependOn(&run_bench_hybrid.step);

    // Feature Engineering benchmark - ML transformations
    const bench_feature = b.addExecutable(.{
        .name = "bench_feature_engineering",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_feature_engineering.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });
    const run_bench_feature = b.addRunArtifact(bench_feature);
    const bench_feature_step = b.step("bench-feature", "Feature engineering: normalization, binning, transforms");
    bench_feature_step.dependOn(&run_bench_feature.step);

    // Analytics benchmark - aggregations, window functions
    const bench_analytics = b.addExecutable(.{
        .name = "bench_analytics",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_analytics.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });
    const run_bench_analytics = b.addRunArtifact(bench_analytics);
    const bench_analytics_step = b.step("bench-analytics", "Analytics: aggregations, GROUP BY, window functions");
    bench_analytics_step.dependOn(&run_bench_analytics.step);

    // Embedding Pipeline benchmark - text to vector
    const bench_embed = b.addExecutable(.{
        .name = "bench_embedding_pipeline",
        .root_module = b.createModule(.{
            .root_source_file = b.path("benchmarks/bench_embedding_pipeline.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });
    const run_bench_embed = b.addRunArtifact(bench_embed);
    const bench_embed_step = b.step("bench-embed", "Embedding pipeline: chunking, tokenization, embedding");
    bench_embed_step.dependOn(&run_bench_embed.step);

    // LanceQL CLI
    const cli = b.addExecutable(.{
        .name = "lanceql",
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/cli.zig"),
            .target = target,
            .optimize = .ReleaseFast,
            .imports = &.{
                .{ .name = "lanceql", .module = lanceql_mod },
                .{ .name = "lanceql.metal", .module = metal_mod },
                .{ .name = "lanceql.query", .module = query_mod },
                .{ .name = "lanceql.table", .module = table_mod },
                .{ .name = "lanceql.parquet_table", .module = parquet_table_mod },
                .{ .name = "lanceql.sql.ast", .module = sql_ast_mod },
                .{ .name = "lanceql.sql.lexer", .module = sql_lexer_mod },
                .{ .name = "lanceql.sql.parser", .module = sql_parser_mod },
                .{ .name = "lanceql.sql.executor", .module = sql_executor_mod },
            },
        }),
    });
    if (use_metal) {
        cli.root_module.linkFramework("Metal", .{});
        cli.root_module.linkFramework("Foundation", .{});
        cli.root_module.addCSourceFiles(.{
            .files = &.{"src/metal/metal_backend.m"},
            .flags = &.{ "-fobjc-arc", "-fno-objc-exceptions" },
        });
    }
    if (use_accelerate) {
        cli.root_module.linkFramework("Accelerate", .{});
    }
    b.installArtifact(cli);
    const run_cli = b.addRunArtifact(cli);
    run_cli.step.dependOn(b.getInstallStep());
    if (b.args) |args| {
        run_cli.addArgs(args);
    }
    const cli_step = b.step("cli", "Build and run LanceQL CLI");
    cli_step.dependOn(&run_cli.step);

    // SQL executor tests
    const test_sql_executor = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("tests/test_sql_executor.zig"),
            .target = target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "lanceql.table", .module = table_mod },
                .{ .name = "lanceql.sql.ast", .module = sql_ast_mod },
                .{ .name = "lanceql.sql.parser", .module = sql_parser_mod },
                .{ .name = "lanceql.sql.executor", .module = sql_executor_mod },
                .{ .name = "lanceql.sql.column_deps", .module = sql_column_deps_mod },
            },
        }),
    });

    const run_test_sql_executor = b.addRunArtifact(test_sql_executor);
    test_step.dependOn(&run_test_sql_executor.step);

    // Column dependency extraction tests
    const test_column_deps = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/sql/column_deps.zig"),
            .target = target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "ast", .module = sql_ast_mod },
            },
        }),
    });
    const run_test_column_deps = b.addRunArtifact(test_column_deps);
    test_step.dependOn(&run_test_column_deps.step);

    // Batch codegen tests
    const test_batch_codegen = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/sql/batch_codegen.zig"),
            .target = target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "ast", .module = sql_ast_mod },
                .{ .name = "column_deps", .module = sql_column_deps_mod },
            },
        }),
    });
    const run_test_batch_codegen = b.addRunArtifact(test_batch_codegen);
    test_step.dependOn(&run_test_batch_codegen.step);

    const test_sql_step = b.step("test-sql", "Run SQL executor tests");
    test_sql_step.dependOn(&run_test_sql_executor.step);
    test_sql_step.dependOn(&run_test_column_deps.step);
    test_sql_step.dependOn(&run_test_batch_codegen.step);

    // @logic_table FFI tests - verify compiled Python functions work via C FFI
    const test_logic_table_ffi = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/tests/test_logic_table_ffi.zig"),
            .target = target,
            .optimize = optimize,
        }),
    });
    // Link against the compiled @logic_table static library
    test_logic_table_ffi.addObjectFile(b.path("lib/simple_logic_table.a"));
    // Link system libraries that the .a depends on
    test_logic_table_ffi.linkLibC();

    const run_test_logic_table_ffi = b.addRunArtifact(test_logic_table_ffi);
    const test_logic_table_ffi_step = b.step("test-logic-table-ffi", "Run @logic_table FFI tests (compiled Python functions)");
    test_logic_table_ffi_step.dependOn(&run_test_logic_table_ffi.step);

    // JIT codegen tests - metal0 integration and JIT compilation
    const test_codegen = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/codegen/metal0_jit.zig"),
            .target = target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "metal0", .module = metal0_mod },
                .{ .name = "lanceql.format", .module = format_mod },
                .{ .name = "lanceql.proto", .module = proto_mod },
                .{ .name = "lanceql.query.expr", .module = query_expr_mod },
            },
        }),
    });
    const run_test_codegen = b.addRunArtifact(test_codegen);
    const test_codegen_step = b.step("test-codegen", "Run JIT codegen tests (metal0 integration)");
    test_codegen_step.dependOn(&run_test_codegen.step);
    test_step.dependOn(&run_test_codegen.step);

    // Stress tests - large datasets, memory pressure, edge cases
    const test_stress = b.addTest(.{
        .root_module = b.createModule(.{
            .root_source_file = b.path("tests/stress/stress_tests.zig"),
            .target = target,
            .optimize = .ReleaseFast, // Use ReleaseFast for performance tests
            .imports = &.{
                .{ .name = "lanceql", .module = lanceql_mod },
                .{ .name = "lanceql.format", .module = format_mod },
                .{ .name = "lanceql.io", .module = io_mod },
                .{ .name = "lanceql.table", .module = table_mod },
            },
        }),
    });

    const run_test_stress = b.addRunArtifact(test_stress);
    const test_stress_step = b.step("test-stress", "Run stress tests (large datasets, memory, edge cases)");
    test_stress_step.dependOn(&run_test_stress.step);

    // === Metal Shader Compilation (macOS with Xcode) ===
    // Compiles .metal shaders to .metallib for faster startup
    if (use_metal) {
        // Step 1: Compile .metal to .air (Metal IR)
        const metal_compile = b.addSystemCommand(&.{
            "xcrun", "-sdk", "macosx", "metal",
            "-O3", // Optimize for performance
            "-c", "src/metal/vector_search.metal",
            "-o",
        });
        const air_output = metal_compile.addOutputFileArg("vector_search.air");

        // Step 2: Link .air to .metallib
        const metallib_link = b.addSystemCommand(&.{
            "xcrun", "-sdk", "macosx", "metallib",
        });
        metallib_link.addFileArg(air_output);
        metallib_link.addArg("-o");
        const metallib_output = metallib_link.addOutputFileArg("vector_search.metallib");

        // Install to zig-out/lib/
        const install_metallib = b.addInstallFileWithDir(
            metallib_output,
            .lib,
            "vector_search.metallib",
        );

        const metal_shaders_step = b.step("metal-shaders", "Compile Metal shaders to .metallib (requires Xcode)");
        metal_shaders_step.dependOn(&install_metallib.step);

        // Make lib and bench-vector depend on metal shaders
        // install_lib.step.dependOn(&install_metallib.step); // Optional: auto-build shaders
    }

    // === WASM Build ===
    const wasm_target = b.resolveTargetQuery(.{
        .cpu_arch = .wasm32,
        .os_tag = .freestanding,
    });

    const wasm = b.addExecutable(.{
        .name = "lanceql",
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/wasm.zig"),
            .target = wasm_target,
            .optimize = .ReleaseSmall,
            // No imports needed - wasm.zig is self-contained
        }),
    });
    wasm.entry = .disabled;
    wasm.rdynamic = true;

    const wasm_step = b.step("wasm", "Build WASM module");
    const install_wasm = b.addInstallArtifact(wasm, .{});
    wasm_step.dependOn(&install_wasm.step);

    // === WASM Tests (Node.js) ===
    // Requires: node tests/wasm_test.mjs
    // This step builds WASM first, then runs the Node.js test suite
    const wasm_test = b.addSystemCommand(&.{ "node", "tests/wasm_test.mjs" });
    wasm_test.step.dependOn(&install_wasm.step);

    const wasm_test_step = b.step("test-wasm", "Run WASM parser tests (requires Node.js)");
    wasm_test_step.dependOn(&wasm_test.step);

    // Add to main test step
    test_step.dependOn(&wasm_test.step);

    // Arrow C Data Interface module for zero-copy Python interop
    const arrow_c_mod = b.addModule("arrow_c", .{
        .root_source_file = b.path("src/arrow_c.zig"),
    });

    // === Native Shared Library for Python ===
    const lib = b.addLibrary(.{
        .name = "lanceql",
        .linkage = .dynamic,
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/python.zig"),
            .target = target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "lanceql", .module = lanceql_mod },
                .{ .name = "lanceql.table", .module = table_mod },
                .{ .name = "lanceql.format", .module = format_mod },
                .{ .name = "lanceql.proto", .module = proto_mod },
                .{ .name = "lanceql.io", .module = io_mod },
                .{ .name = "lanceql.encoding", .module = encoding_mod },
                .{ .name = "lanceql.value", .module = value_mod },
                .{ .name = "lanceql.metal", .module = metal_mod },
                .{ .name = "arrow_c", .module = arrow_c_mod },
            },
        }),
    });

    // Link macOS frameworks for Metal/Accelerate support
    if (use_metal) {
        lib.root_module.linkFramework("Metal", .{});
        lib.root_module.linkFramework("Foundation", .{});
        // Add Objective-C Metal backend
        lib.root_module.addCSourceFiles(.{
            .files = &.{"src/metal/metal_backend.m"},
            .flags = &.{ "-fobjc-arc", "-fno-objc-exceptions" },
        });
    }
    if (use_accelerate) {
        lib.root_module.linkFramework("Accelerate", .{});
    }

    const lib_step = b.step("lib", "Build native shared library for Python");
    const install_lib = b.addInstallArtifact(lib, .{});
    lib_step.dependOn(&install_lib.step);

    // === Node.js Shared Library ===
    const nodejs_lib = b.addLibrary(.{
        .name = "lanceql",
        .linkage = .dynamic,
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/nodejs.zig"),
            .target = target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "lanceql.format", .module = format_mod },
                .{ .name = "lanceql.io", .module = io_mod },
                .{ .name = "lanceql.proto", .module = proto_mod },
                .{ .name = "lanceql.encoding", .module = encoding_mod },
                .{ .name = "lanceql.table", .module = table_mod },
                .{ .name = "lanceql.value", .module = value_mod },
                .{ .name = "lanceql.sql.ast", .module = sql_ast_mod },
                .{ .name = "lanceql.sql.lexer", .module = sql_lexer_mod },
                .{ .name = "lanceql.sql.parser", .module = sql_parser_mod },
                .{ .name = "lanceql.sql.executor", .module = sql_executor_mod },
            },
        }),
    });

    const nodejs_lib_step = b.step("lib-nodejs", "Build native shared library for Node.js");
    const install_nodejs_lib = b.addInstallArtifact(nodejs_lib, .{});
    nodejs_lib_step.dependOn(&install_nodejs_lib.step);

    // Default build includes lib-nodejs
    b.default_step.dependOn(&install_nodejs_lib.step);

    // === Cross-compilation targets for NPM prebuilds ===
    const prebuild_step = b.step("prebuild", "Build prebuilt binaries for all platforms");

    // Cross-compilation targets
    const cross_targets = [_]struct {
        query: std.Target.Query,
        name: []const u8,
    }{
        .{ .query = .{ .cpu_arch = .x86_64, .os_tag = .macos }, .name = "darwin-x64" },
        .{ .query = .{ .cpu_arch = .aarch64, .os_tag = .macos }, .name = "darwin-arm64" },
        .{ .query = .{ .cpu_arch = .x86_64, .os_tag = .linux, .abi = .gnu }, .name = "linux-x64" },
        .{ .query = .{ .cpu_arch = .aarch64, .os_tag = .linux, .abi = .gnu }, .name = "linux-arm64" },
        .{ .query = .{ .cpu_arch = .x86_64, .os_tag = .windows }, .name = "win32-x64" },
    };

    for (cross_targets) |cross_target| {
        const resolved_target = b.resolveTargetQuery(cross_target.query);

        const cross_lib = b.addLibrary(.{
            .name = "lanceql",
            .linkage = .dynamic,
            .root_module = b.createModule(.{
                .root_source_file = b.path("src/nodejs.zig"),
                .target = resolved_target,
                .optimize = .ReleaseFast,
                .imports = &.{
                    .{ .name = "lanceql.format", .module = format_mod },
                    .{ .name = "lanceql.io", .module = io_mod },
                    .{ .name = "lanceql.proto", .module = proto_mod },
                    .{ .name = "lanceql.encoding", .module = encoding_mod },
                    .{ .name = "lanceql.table", .module = table_mod },
                    .{ .name = "lanceql.value", .module = value_mod },
                    .{ .name = "lanceql.sql.ast", .module = sql_ast_mod },
                    .{ .name = "lanceql.sql.lexer", .module = sql_lexer_mod },
                    .{ .name = "lanceql.sql.parser", .module = sql_parser_mod },
                    .{ .name = "lanceql.sql.executor", .module = sql_executor_mod },
                },
            }),
        });

        // Install to prebuilds/{platform}/
        const install_cross = b.addInstallArtifact(cross_lib, .{
            .dest_dir = .{ .override = .{ .custom = b.fmt("prebuilds/{s}", .{cross_target.name}) } },
        });
        prebuild_step.dependOn(&install_cross.step);

        // Also create individual platform steps
        const platform_step = b.step(b.fmt("prebuild-{s}", .{cross_target.name}), b.fmt("Build for {s}", .{cross_target.name}));
        platform_step.dependOn(&install_cross.step);
    }
}
