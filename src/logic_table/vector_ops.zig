// Generated by metal0 --emit-logic-table
// Import this file into LanceQL to use compiled @logic_table functions

const std = @import("std");
const runtime = @import("runtime");
const c_interop = @import("c_interop");

// Global allocator for logic_table functions - using GPA for flexibility
var __gpa = std.heap.GeneralPurposeAllocator(.{ .safety = true, .thread_safe = true }){};
pub var __global_allocator: std.mem.Allocator = __gpa.allocator();

pub const VectorOps = struct {
    pub const __logic_table__ = true;

fn cosine_sim(_: std.mem.Allocator, _: runtime.PyValue, query: i64, docs: i64) !i64 {
        _ = &query;
        _ = &docs;
        _ = "Cosine similarity between query and document embeddings.";
        return try runtime.divideFloat(@as(*runtime.PyObject, @ptrCast(c_interop.callModuleFunction("numpy", "sum", .{(runtime.PyValue.from(query.embedding)).mul(runtime.PyValue.from(docs.embedding))}).?)), (mul_0: { const _lhs = @as(*runtime.PyObject, @ptrCast(c_interop.callModuleFunction("numpy.linalg", "norm", .{query.embedding}).?)); const _rhs = @as(*runtime.PyObject, @ptrCast(c_interop.callModuleFunction("numpy.linalg", "norm", .{docs.embedding}).?)); break :mul_0 if (@TypeOf(_lhs) == []const u8) (if (_rhs < 0) "" else runtime.strRepeat(__global_allocator, _lhs, @as(usize, @intCast(_rhs)))) else _lhs * _rhs; }));
    }
fn dot_product(_: runtime.PyValue, query: i64, docs: i64) i64 {
        _ = &query;
        _ = &docs;
        _ = "Dot product between query and document embeddings.";
        return @as(*runtime.PyObject, @ptrCast(c_interop.callModuleFunction("numpy", "dot", .{query.embedding, docs.embedding}).?));
    }
fn weighted_score(_: runtime.PyValue, query: i64, docs: i64) i64 {
        _ = &query;
        _ = &docs;
        _ = "Weighted combination of query score and document boost.";
        return ((runtime.PyValue.from(query.score)).mul(runtime.PyValue.from(@as(f64, @as(f64, 0.5)))) + (runtime.PyValue.from(docs.boost)).mul(runtime.PyValue.from(@as(f64, @as(f64, 0.5)))));
    }
    pub const methods = [_][]const u8{
        "cosine_sim",
        "dot_product",
        "weighted_score",
    };
};

pub const FeatureEngineering = struct {
    pub const __logic_table__ = true;

fn log_transform(_: runtime.PyValue, data: i64) i64 {
        _ = &data;
        _ = "Log transform with offset for zero handling.";
        return @as(*runtime.PyObject, @ptrCast(c_interop.callModuleFunction("numpy", "log", .{(runtime.PyValue.from(data.value)).add(runtime.PyValue.from(@as(f64, @as(f64, 1.0))))}).?));
    }
fn normalize(_: std.mem.Allocator, _: runtime.PyValue, data: i64) !i64 {
        _ = &data;
        _ = "Min-max normalization.";
        return try runtime.divideFloat((runtime.PyValue.from(data.value)).sub(runtime.PyValue.from(data.min)), runtime.addNum((runtime.PyValue.from(data.max)).sub(runtime.PyValue.from(data.min)), @as(f64, 0.00000001)));
    }
fn z_score(_: std.mem.Allocator, _: runtime.PyValue, data: i64) !i64 {
        _ = &data;
        _ = "Z-score standardization.";
        return try runtime.divideFloat((runtime.PyValue.from(data.value)).sub(runtime.PyValue.from(data.mean)), (runtime.PyValue.from(data.std)).add(runtime.PyValue.from(@as(f64, @as(f64, 0.00000001)))));
    }
    pub const methods = [_][]const u8{
        "log_transform",
        "normalize",
        "z_score",
    };
};

pub const RiskScoring = struct {
    pub const __logic_table__ = true;

fn fraud_score(_: std.mem.Allocator, _: runtime.PyValue, txn: i64) !i64 {
        _ = &txn;
        _ = "Multi-factor fraud risk score.";
        var score: f64 = 0.0;
        score = runtime.addNum(score, @as(*runtime.PyObject, @ptrCast(c_interop.callModuleFunction("numpy", "where", .{(runtime.PyValue.from(txn.amount).gt(runtime.PyValue.from(10000))), @as(*runtime.PyObject, @ptrCast(c_interop.callModuleFunction("numpy", "minimum", .{@as(f64, 0.4), (runtime.PyValue.from(txn.amount)).div(runtime.PyValue.from(@as(i64, 125000)))}).?)), @as(f64, 0.0)}).?)));
        score = runtime.addNum(score, @as(*runtime.PyObject, @ptrCast(c_interop.callModuleFunction("numpy", "where", .{(runtime.PyValue.from(txn.customer_age).lt(runtime.PyValue.from(30))), @as(f64, 0.3), @as(f64, 0.0)}).?)));
        score = runtime.addNum(score, @as(*runtime.PyObject, @ptrCast(c_interop.callModuleFunction("numpy", "where", .{(runtime.PyValue.from(txn.velocity).gt(runtime.PyValue.from(5))), @as(*runtime.PyObject, @ptrCast(c_interop.callModuleFunction("numpy", "minimum", .{@as(f64, 0.2), (runtime.PyValue.from(txn.velocity)).div(runtime.PyValue.from(@as(i64, 100)))}).?)), @as(f64, 0.0)}).?)));
        score = runtime.addNum(score, @as(*runtime.PyObject, @ptrCast(c_interop.callModuleFunction("numpy", "where", .{txn.previous_fraud, @as(f64, 0.5), @as(f64, 0.0)}).?)));
        score = runtime.addNum(score, @as(*runtime.PyObject, @ptrCast(c_interop.callModuleFunction("numpy", "where", .{~@as(i64, txn.verified), @as(f64, 0.2), @as(f64, 0.0)}).?)));
        return @as(*runtime.PyObject, @ptrCast(c_interop.callModuleFunction("numpy", "minimum", .{@as(f64, 1.0), score}).?));
    }
    pub const methods = [_][]const u8{
        "fraud_score",
    };
};

