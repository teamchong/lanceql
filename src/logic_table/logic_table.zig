// Logic Table Integration for LanceQL
// This module loads and executes @logic_table functions compiled by metal0
//
// Workflow:
// 1. Python code with @logic_table decorator
// 2. metal0 --emit-logic-table compiles to Zig using metal0 runtime
// 3. LanceQL imports and links against metal0 runtime

const std = @import("std");
const runtime = @import("runtime");
const c_interop = @import("c_interop");

// Import compiled logic_table modules (generated by metal0 --emit-logic-table)
pub const vector_ops = @import("vector_ops.zig");

/// Registry of all available logic_table structs
pub const LogicTableRegistry = struct {
    allocator: std.mem.Allocator,

    pub fn init(allocator: std.mem.Allocator) LogicTableRegistry {
        return .{ .allocator = allocator };
    }

    /// Get metadata about a logic_table struct by name
    pub fn getTable(self: *LogicTableRegistry, name: []const u8) ?LogicTableMeta {
        _ = self;
        if (std.mem.eql(u8, name, "VectorOps")) {
            return LogicTableMeta{
                .name = "VectorOps",
                .methods = &vector_ops.VectorOps.methods,
            };
        }
        if (std.mem.eql(u8, name, "FeatureEngineering")) {
            return LogicTableMeta{
                .name = "FeatureEngineering",
                .methods = &vector_ops.FeatureEngineering.methods,
            };
        }
        if (std.mem.eql(u8, name, "RiskScoring")) {
            return LogicTableMeta{
                .name = "RiskScoring",
                .methods = &vector_ops.RiskScoring.methods,
            };
        }
        return null;
    }
};

pub const LogicTableMeta = struct {
    name: []const u8,
    methods: []const []const u8,
};
