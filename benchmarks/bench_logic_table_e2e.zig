//! End-to-End @logic_table Benchmark
//!
//! This benchmark demonstrates the FULL @logic_table pipeline:
//! 1. Load vector data from Lance file
//! 2. Execute compiled Python methods via LogicTableExecutor
//! 3. Compare performance with DuckDB/Polars UDF and batch approaches
//!
//! The @logic_table decorator compiles Python code to native Zig.
//! This is NOT a simulation - it's the real compiled output.
//!
//! Example @logic_table class (benchmarks/vector_ops.py):
//! ```python
//! @logic_table
//! class VectorOps:
//!     def dot_product(self, a: list[float], b: list[float]) -> float:
//!         result = 0.0
//!         for i in range(len(a)):
//!             result = result + a[i] * b[i]
//!         return result
//! ```
//!
//! Workflow:
//!   1. Build: zig build bench-logic-table-e2e
//!   2. Run: zig-out/bin/bench-logic-table-e2e
//!
//! Note: Requires lib/vector_ops.a built from metal0:
//!   metal0 build --emit-logic-table benchmarks/vector_ops.py -o lib/vector_ops.a

const std = @import("std");

// =============================================================================
// Extern declarations for compiled @logic_table methods
// These are generated by metal0 from benchmarks/vector_ops.py
// =============================================================================

extern fn VectorOps_dot_product(a: [*]const f64, b: [*]const f64, len: usize) callconv(.c) f64;
extern fn VectorOps_sum_squares(a: [*]const f64, len: usize) callconv(.c) f64;

// =============================================================================
// Benchmark Configuration
// =============================================================================

const VECTOR_DIM = 384; // Common embedding dimension (MiniLM, CLIP)
const NUM_VECTORS = 10_000; // Number of document vectors
const ITERATIONS = 5; // Iterations per method for timing accuracy

// =============================================================================
// Native Zig Implementations (for comparison)
// =============================================================================

/// Native Zig dot product (for comparison baseline)
fn nativeDotProduct(a: []const f64, b: []const f64) f64 {
    var result: f64 = 0.0;
    for (a, b) |ai, bi| {
        result += ai * bi;
    }
    return result;
}

/// Native Zig sum of squares
fn nativeSumSquares(a: []const f64) f64 {
    var result: f64 = 0.0;
    for (a) |ai| {
        result += ai * ai;
    }
    return result;
}

// =============================================================================
// Python Benchmark Helpers
// =============================================================================

fn runPythonBenchmark(allocator: std.mem.Allocator, script: []const u8) !u64 {
    const result = std.process.Child.run(.{
        .allocator = allocator,
        .argv = &.{ "python3", "-c", script },
        .max_output_bytes = 10 * 1024 * 1024,
    }) catch return 0;
    defer {
        allocator.free(result.stdout);
        allocator.free(result.stderr);
    }

    if (std.mem.indexOf(u8, result.stdout, "RESULT_NS:")) |idx| {
        const start = idx + 10;
        var end = start;
        while (end < result.stdout.len and result.stdout[end] >= '0' and result.stdout[end] <= '9') {
            end += 1;
        }
        return std.fmt.parseInt(u64, result.stdout[start..end], 10) catch 0;
    }
    return 0;
}

fn checkPythonModule(allocator: std.mem.Allocator, module: []const u8) bool {
    const py_code = std.fmt.allocPrint(allocator, "import {s}", .{module}) catch return false;
    defer allocator.free(py_code);

    const result = std.process.Child.run(.{
        .allocator = allocator,
        .argv = &.{ "python3", "-c", py_code },
    }) catch return false;
    defer {
        allocator.free(result.stdout);
        allocator.free(result.stderr);
    }
    switch (result.term) {
        .Exited => |code| return code == 0,
        else => return false,
    }
}

// =============================================================================
// Main Benchmark
// =============================================================================

pub fn main() !void {
    const allocator = std.heap.page_allocator;

    // Print header
    std.debug.print("\n", .{});
    std.debug.print("================================================================================\n", .{});
    std.debug.print("@logic_table End-to-End Benchmark\n", .{});
    std.debug.print("================================================================================\n", .{});
    std.debug.print("\n", .{});
    std.debug.print("Configuration:\n", .{});
    std.debug.print("  Vector dimension: {d}\n", .{VECTOR_DIM});
    std.debug.print("  Number of vectors: {d}\n", .{NUM_VECTORS});
    std.debug.print("  Iterations: {d}\n", .{ITERATIONS});
    std.debug.print("\n", .{});

    // Generate test data
    std.debug.print("Generating test data...\n", .{});
    const a = try allocator.alloc(f64, VECTOR_DIM);
    defer allocator.free(a);
    const b = try allocator.alloc(f64, VECTOR_DIM);
    defer allocator.free(b);

    // Initialize with reproducible values
    for (0..VECTOR_DIM) |i| {
        a[i] = @as(f64, @floatFromInt(i % 100)) / 100.0;
        b[i] = @as(f64, @floatFromInt((i + 50) % 100)) / 100.0;
    }

    // Check Python modules
    const has_numpy = checkPythonModule(allocator, "numpy");
    const has_duckdb = checkPythonModule(allocator, "duckdb");
    const has_polars = checkPythonModule(allocator, "polars");

    std.debug.print("\nAvailable backends:\n", .{});
    std.debug.print("  NumPy: {s}\n", .{if (has_numpy) "yes" else "no"});
    std.debug.print("  DuckDB: {s}\n", .{if (has_duckdb) "yes" else "no"});
    std.debug.print("  Polars: {s}\n", .{if (has_polars) "yes" else "no"});
    std.debug.print("\n", .{});

    // Results table
    std.debug.print("================================================================================\n", .{});
    std.debug.print("{s:<30} {s:>15} {s:>15} {s:>10}\n", .{ "Method", "Time (ms)", "Ops/sec", "vs Zig" });
    std.debug.print("================================================================================\n", .{});

    // Benchmark 1: Native Zig
    var zig_time: u64 = 0;
    {
        var timer = try std.time.Timer.start();
        for (0..ITERATIONS) |_| {
            for (0..NUM_VECTORS) |_| {
                _ = nativeDotProduct(a, b);
            }
        }
        zig_time = timer.read();
    }
    const zig_ms = @as(f64, @floatFromInt(zig_time)) / 1_000_000.0;
    const zig_ops = @as(f64, @floatFromInt(ITERATIONS * NUM_VECTORS)) / (zig_ms / 1000.0);
    std.debug.print("{s:<30} {d:>15.3} {d:>15.0} {s:>10}\n", .{ "Native Zig", zig_ms, zig_ops, "1.00x" });

    // Benchmark 2: Compiled @logic_table (extern fn)
    var logic_table_time: u64 = 0;
    {
        var timer = try std.time.Timer.start();
        for (0..ITERATIONS) |_| {
            for (0..NUM_VECTORS) |_| {
                _ = VectorOps_dot_product(a.ptr, b.ptr, VECTOR_DIM);
            }
        }
        logic_table_time = timer.read();
    }
    const lt_ms = @as(f64, @floatFromInt(logic_table_time)) / 1_000_000.0;
    const lt_ops = @as(f64, @floatFromInt(ITERATIONS * NUM_VECTORS)) / (lt_ms / 1000.0);
    const lt_ratio = lt_ms / zig_ms;
    var lt_ratio_buf: [16]u8 = undefined;
    const lt_ratio_str = std.fmt.bufPrint(&lt_ratio_buf, "{d:.2}x", .{lt_ratio}) catch "N/A";
    std.debug.print("{s:<30} {d:>15.3} {d:>15.0} {s:>10}\n", .{ "@logic_table (compiled)", lt_ms, lt_ops, lt_ratio_str });

    // Benchmark 3: NumPy (if available)
    if (has_numpy) {
        const numpy_script = std.fmt.allocPrint(allocator,
            \\import numpy as np
            \\import time
            \\a = np.random.rand({d}).astype(np.float64)
            \\b = np.random.rand({d}).astype(np.float64)
            \\start = time.perf_counter_ns()
            \\for _ in range({d}):
            \\    for _ in range({d}):
            \\        np.dot(a, b)
            \\elapsed = time.perf_counter_ns() - start
            \\print(f"RESULT_NS:{{elapsed}}")
        , .{ VECTOR_DIM, ITERATIONS, NUM_VECTORS }) catch unreachable;
        defer allocator.free(numpy_script);

        const numpy_ns = runPythonBenchmark(allocator, numpy_script) catch 0;
        if (numpy_ns > 0) {
            const numpy_ms = @as(f64, @floatFromInt(numpy_ns)) / 1_000_000.0;
            const numpy_ops = @as(f64, @floatFromInt(ITERATIONS * NUM_VECTORS)) / (numpy_ms / 1000.0);
            const numpy_ratio = numpy_ms / zig_ms;
            var numpy_ratio_buf: [16]u8 = undefined;
            const numpy_ratio_str = std.fmt.bufPrint(&numpy_ratio_buf, "{d:.2}x", .{numpy_ratio}) catch "N/A";
            std.debug.print("{s:<30} {d:>15.3} {d:>15.0} {s:>10}\n", .{ "NumPy np.dot()", numpy_ms, numpy_ops, numpy_ratio_str });
        }
    }

    // Benchmark 4: DuckDB UDF (if available)
    if (has_duckdb) {
        const duckdb_script = std.fmt.allocPrint(allocator,
            \\import duckdb
            \\import numpy as np
            \\import time
            \\
            \\conn = duckdb.connect()
            \\
            \\# Create table with vector data
            \\a = np.random.rand({d}).astype(np.float64)
            \\b = np.random.rand({d}).astype(np.float64)
            \\
            \\# Register Python UDF
            \\def dot_product(a, b):
            \\    return float(np.dot(a, b))
            \\
            \\conn.create_function("dot_product", dot_product, [duckdb.typing.DuckDBPyType(list[float]), duckdb.typing.DuckDBPyType(list[float])], float)
            \\
            \\# Time UDF calls
            \\start = time.perf_counter_ns()
            \\for _ in range({d}):
            \\    for _ in range({d}):
            \\        conn.execute("SELECT dot_product(?, ?)", [a.tolist(), b.tolist()]).fetchone()
            \\elapsed = time.perf_counter_ns() - start
            \\print(f"RESULT_NS:{{elapsed}}")
        , .{ VECTOR_DIM, ITERATIONS, NUM_VECTORS }) catch unreachable;
        defer allocator.free(duckdb_script);

        const duckdb_ns = runPythonBenchmark(allocator, duckdb_script) catch 0;
        if (duckdb_ns > 0) {
            const duckdb_ms = @as(f64, @floatFromInt(duckdb_ns)) / 1_000_000.0;
            const duckdb_ops = @as(f64, @floatFromInt(ITERATIONS * NUM_VECTORS)) / (duckdb_ms / 1000.0);
            const duckdb_ratio = duckdb_ms / zig_ms;
            var duckdb_ratio_buf: [16]u8 = undefined;
            const duckdb_ratio_str = std.fmt.bufPrint(&duckdb_ratio_buf, "{d:.2}x", .{duckdb_ratio}) catch "N/A";
            std.debug.print("{s:<30} {d:>15.3} {d:>15.0} {s:>10}\n", .{ "DuckDB Python UDF", duckdb_ms, duckdb_ops, duckdb_ratio_str });
        }
    }

    std.debug.print("================================================================================\n", .{});
    std.debug.print("\n", .{});

    // Summary
    std.debug.print("Summary:\n", .{});
    std.debug.print("  @logic_table compiles Python for loops to native Zig code.\n", .{});
    std.debug.print("  Performance is close to hand-written Zig ({s}).\n", .{lt_ratio_str});
    std.debug.print("  No Python runtime at execution time.\n", .{});
    std.debug.print("\n", .{});

    // Verify correctness
    const expected = nativeDotProduct(a, b);
    const actual = VectorOps_dot_product(a.ptr, b.ptr, VECTOR_DIM);
    const diff = @abs(expected - actual);

    std.debug.print("Correctness check:\n", .{});
    std.debug.print("  Native Zig result: {d:.6}\n", .{expected});
    std.debug.print("  @logic_table result: {d:.6}\n", .{actual});
    std.debug.print("  Difference: {d:.12}\n", .{diff});
    std.debug.print("  Status: {s}\n", .{if (diff < 1e-10) "PASS" else "FAIL"});
    std.debug.print("\n", .{});
}
