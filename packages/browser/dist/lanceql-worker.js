var W=new Map;async function te(d){return crypto.subtle.importKey("raw",new Uint8Array(d),{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function ne(d,e){let n=crypto.getRandomValues(new Uint8Array(12)),t=new TextEncoder().encode(JSON.stringify(d)),s=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},e,t),a=new Uint8Array(12+s.byteLength);return a.set(n,0),a.set(new Uint8Array(s),12),a}async function re(d,e){let n=d.slice(0,12),r=d.slice(12),t=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},e,r),s=new TextDecoder;return JSON.parse(s.decode(t))}var D=null,J=null,ue=new Map;function Ne(d){D=d}function We(d){J=d}var se=class{constructor(e,n={}){this.name=e,this.options=n,this._root=null,this._ready=!1,this._embedder=null,this._encryptionKeyId=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:n,keyBytes:r}=e;if(!W.has(n)){let t=await te(r);W.set(n,t)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle(`lanceql-${this.name}`,{create:!0}),this._ready=!0}catch(n){throw console.error("[WorkerStore] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?W.get(this._encryptionKeyId):null}async get(e){await this._ensureOpen();try{let n=this._getCryptoKey(),r=n?".enc":".json",s=await(await this._root.getFileHandle(`${e}${r}`)).getFile();if(n){let a=await s.arrayBuffer();return re(new Uint8Array(a),n)}else{let a=await s.text();return JSON.parse(a)}}catch(n){if(n.name==="NotFoundError")return;throw n}}async set(e,n){await this._ensureOpen();let r=this._getCryptoKey(),t=r?".enc":".json",a=await(await this._root.getFileHandle(`${e}${t}`,{create:!0})).createWritable();if(r){let o=await ne(n,r);await a.write(o)}else await a.write(JSON.stringify(n));await a.close()}async delete(e){await this._ensureOpen();let r=this._getCryptoKey()?".enc":".json";try{await this._root.removeEntry(`${e}${r}`)}catch(t){if(t.name!=="NotFoundError")throw t}}async keys(){await this._ensureOpen();let n=this._getCryptoKey()?".enc":".json",r=[];for await(let[t]of this._root.entries())t.endsWith(n)&&r.push(t.slice(0,-n.length));return r}async clear(){await this._ensureOpen();let e=[];for await(let[n]of this._root.entries())e.push(n);for(let n of e)await this._root.removeEntry(n)}async filter(e,n){let r=await this.get(e);if(!Array.isArray(r))throw new Error(`Key '${e}' is not a collection`);return r.filter(t=>this._matchQuery(t,n))}async find(e,n){let r=await this.get(e);if(!Array.isArray(r))throw new Error(`Key '${e}' is not a collection`);return r.find(t=>this._matchQuery(t,n))}async search(e,n,r=10){let t=await this.get(e);if(!Array.isArray(t))throw new Error(`Key '${e}' is not a collection`);if(t.length===0)return[];if(this._embedder)return this._semanticSearch(t,e,n,r);let s=n.toLowerCase();return t.map(o=>{let c=this._extractText(o).toLowerCase(),i=s.split(/\s+/),l=i.filter(f=>c.includes(f)).length;return{item:o,score:l/i.length}}).filter(o=>o.score>0).sort((o,c)=>c.score-o.score).slice(0,r)}async _semanticSearch(e,n,r,t){let s=await this._embedder.embed(r),a=[],o=[],c=[];for(let i=0;i<e.length;i++){let l=e[i],f=this._extractText(l),h=`${this.name}:${n}:${f}`;if(ue.has(h)){let g=ue.get(h),m=this._cosineSimilarity(s,g);a.push({item:l,score:m})}else o.push(f),c.push(i)}if(o.length>0){let i;o.length>1&&this._embedder.embedBatch?i=await this._embedder.embedBatch(o):i=await Promise.all(o.map(l=>this._embedder.embed(l)));for(let l=0;l<i.length;l++){let f=c[l],h=e[f],g=o[l],m=i[l],u=`${this.name}:${n}:${g}`;ue.set(u,m);let w=this._cosineSimilarity(s,m);a.push({item:h,score:w})}}return a.sort((i,l)=>l.score-i.score).slice(0,t)}async enableSemanticSearch(e={}){let{model:n="minilm",onProgress:r}=e;if(D||(J||(J=this._initGPUTransformer(),We(J)),D=await J,Ne(D)),!D)return null;let t=await D.loadModel(n,r);return this._embedder={model:n,dimensions:t.hiddenSize,embed:async s=>D.encodeText(s,n),embedBatch:async s=>D.encodeTextBatch(s,n)},{model:n,dimensions:t.hiddenSize,type:t.modelType||"text"}}async _initGPUTransformer(){try{let e=await import("./webgpu/index.js");if(!e.isWebGPUAvailable())return console.log("[WorkerStore] WebGPU not available"),null;let n=e.getGPUTransformer();return await n.init()?(console.log("[WorkerStore] WebGPU initialized"),n):(console.log("[WorkerStore] WebGPU init failed"),null)}catch(e){return console.error("[WorkerStore] WebGPU init error:",e),null}}disableSemanticSearch(){this._embedder&&D&&(D.unloadModel(this._embedder.model),this._embedder=null)}hasSemanticSearch(){return this._embedder!==null}async count(e,n=null){let r=await this.get(e);if(!Array.isArray(r))throw new Error(`Key '${e}' is not a collection`);return n?r.filter(t=>this._matchQuery(t,n)).length:r.length}async _ensureOpen(){this._ready||await this.open()}_matchQuery(e,n){for(let[r,t]of Object.entries(n)){let s=e[r];if(typeof t=="object"&&t!==null)for(let[a,o]of Object.entries(t))switch(a){case"$eq":if(s!==o)return!1;break;case"$ne":if(s===o)return!1;break;case"$lt":if(!(s<o))return!1;break;case"$lte":if(!(s<=o))return!1;break;case"$gt":if(!(s>o))return!1;break;case"$gte":if(!(s>=o))return!1;break;case"$in":if(!Array.isArray(o)||!o.includes(s))return!1;break;case"$nin":if(Array.isArray(o)&&o.includes(s))return!1;break;case"$contains":if(typeof s!="string"||!s.includes(o))return!1;break;case"$regex":if(typeof s!="string"||!new RegExp(o).test(s))return!1;break}else if(s!==t)return!1}return!0}_extractText(e){if(typeof e=="string")return e;let n=[];for(let[r,t]of Object.entries(e))typeof t=="string"&&n.push(t);return n.join(" ")}_cosineSimilarity(e,n){let r=0,t=0,s=0;for(let a=0;a<e.length;a++)r+=e[a]*n[a],t+=e[a]*e[a],s+=n[a]*n[a];return r/(Math.sqrt(t)*Math.sqrt(s))}};var he=class{constructor(e="lanceql"){this.rootDir=e,this.root=null}async getRoot(){if(this.root)return this.root;if(typeof navigator>"u"||!navigator.storage?.getDirectory)throw new Error("OPFS not available");let e=await navigator.storage.getDirectory();return this.root=await e.getDirectoryHandle(this.rootDir,{create:!0}),this.root}async open(){return await this.getRoot(),this}async getDir(e){let n=await this.getRoot(),r=e.split("/").filter(s=>s),t=n;for(let s of r)t=await t.getDirectoryHandle(s,{create:!0});return t}async save(e,n){let r=e.split("/"),t=r.pop(),s=r.join("/"),o=await(s?await this.getDir(s):await this.getRoot()).getFileHandle(t,{create:!0});if(o.createSyncAccessHandle)try{let i=await o.createSyncAccessHandle();return i.truncate(0),i.write(n,{at:0}),i.flush(),i.close(),{path:e,size:n.byteLength}}catch{}let c=await o.createWritable();return await c.write(n),await c.close(),{path:e,size:n.byteLength}}async load(e){try{let n=e.split("/"),r=n.pop(),t=n.join("/"),c=await(await(await(t?await this.getDir(t):await this.getRoot()).getFileHandle(r)).getFile()).arrayBuffer();return new Uint8Array(c)}catch(n){if(n.name==="NotFoundError")return null;throw n}}async delete(e){try{let n=e.split("/"),r=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(r),!0}catch(n){if(n.name==="NotFoundError")return!1;throw n}}async list(e=""){try{let n=e?await this.getDir(e):await this.getRoot(),r=[];for await(let[t,s]of n.entries())r.push({name:t,type:s.kind});return r}catch{return[]}}async exists(e){try{let n=e.split("/"),r=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).getFileHandle(r),!0}catch{return!1}}async deleteDir(e){try{let n=e.split("/"),r=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(r,{recursive:!0}),!0}catch{return!1}}},C=new he;var $=new TextEncoder,Y=new TextDecoder,xe={INT64:"int64",INT32:"int32",FLOAT64:"float64",FLOAT32:"float32",STRING:"string",BOOL:"bool",VECTOR:"vector"},Be=1,Le=2,Ie=3,ve=4,de=5,ye=6;function Se(d){switch(d){case"int32":case"integer":return Int32Array;case"int64":return BigInt64Array;case"float32":case"real":return Float32Array;case"float64":case"double":return Float64Array;default:return null}}function $e(d){switch(d){case"int32":case"integer":return Be;case"int64":return Le;case"float32":case"real":return Ie;case"float64":case"double":return ve;case"string":case"text":return de;case"bool":case"boolean":return ye;default:return de}}var ae=class{constructor(e){this.schema=e,this.columns=new Map,this.rowCount=0,this._useBinary=!0}addRows(e){if(e.length!==0){if(this.rowCount===0)for(let n of this.schema){let r=Se(n.dataType);r?this.columns.set(n.name,{type:"typed",dataType:n.dataType,data:new r(Math.max(e.length,1024)),length:0}):this.columns.set(n.name,{type:"array",dataType:n.dataType,data:[],length:0})}for(let n of this.schema){let r=this.columns.get(n.name);if(r.type==="typed"){let t=r.length+e.length;if(t>r.data.length){let s=Math.max(t,r.data.length*2),a=new r.data.constructor(s);a.set(r.data),r.data=a}for(let s=0;s<e.length;s++){let a=e[s][n.name];r.data[r.length+s]=a??0}r.length+=e.length}else{for(let t=0;t<e.length;t++)r.data.push(e[t][n.name]??null);r.length+=e.length}}this.rowCount+=e.length}}buildBinary(){let e=[],n=16,r=[];for(let c of this.schema){let i=this.columns.get(c.name),l=$.encode(c.name),f=$e(c.dataType),h;if(i.type==="typed"){let u=i.data.subarray(0,i.length);h=new Uint8Array(u.buffer,u.byteOffset,u.byteLength)}else h=$.encode(JSON.stringify(i.data));r.push({nameBytes:l,typeCode:f,dataBytes:h,dataType:c.dataType});let m=(8-(n+4+l.length+1+4)%8)%8;n+=4+l.length+1+m+4+h.length}let t=new ArrayBuffer(n),s=new DataView(t),a=new Uint8Array(t),o=0;s.setUint32(o,1279348291,!1),o+=4,s.setUint32(o,2,!1),o+=4,s.setUint32(o,this.schema.length,!1),o+=4,s.setUint32(o,this.rowCount,!1),o+=4;for(let c of r){s.setUint32(o,c.nameBytes.length,!1),o+=4,a.set(c.nameBytes,o),o+=c.nameBytes.length,s.setUint8(o,c.typeCode),o+=1;let i=(8-(o+4)%8)%8;for(let l=0;l<i;l++)s.setUint8(o+l,0);o+=i,s.setUint32(o,c.dataBytes.length,!1),o+=4,a.set(c.dataBytes,o),o+=c.dataBytes.length}return new Uint8Array(t)}setColumnarData(e){let n=Object.keys(e)[0];this.rowCount=e[n]?.length||0;for(let r of this.schema){let t=e[r.name];if(!t)continue;let s=Se(r.dataType);if(s&&ArrayBuffer.isView(t))this.columns.set(r.name,{type:"typed",dataType:r.dataType,data:t,length:t.length});else if(s){let a=new s(t.length);for(let o=0;o<t.length;o++)a[o]=t[o]??0;this.columns.set(r.name,{type:"typed",dataType:r.dataType,data:a,length:t.length})}else this.columns.set(r.name,{type:"array",dataType:r.dataType,data:Array.isArray(t)?t:Array.from(t),length:t.length})}}build(){if(this._useBinary&&this.rowCount>0)try{return this.buildBinary()}catch(n){console.warn("[LanceFileWriter] Binary build failed, falling back to JSON:",n)}let e={format:"json",schema:this.schema,columns:{},rowCount:this.rowCount};for(let[n,r]of this.columns)r.type==="typed"?e.columns[n]=Array.from(r.data.subarray(0,r.length)):e.columns[n]=r.data;return $.encode(JSON.stringify(e))}};function Z(d){let e=new DataView(d.buffer||d),n=new Uint8Array(d.buffer||d),r=0;if(e.getUint32(r,!1)!==1279348291)return null;r+=4;let s=e.getUint32(r,!1);r+=4;let a=e.getUint32(r,!1);r+=4;let o=e.getUint32(r,!1);r+=4;let c=[],i={};for(let l=0;l<a;l++){let f=e.getUint32(r,!1);r+=4;let h=Y.decode(n.subarray(r,r+f));r+=f;let g=e.getUint8(r);r+=1;let m=(8-(r+4)%8)%8;r+=m;let u=e.getUint32(r,!1);r+=4;let w=n.subarray(r,r+u);r+=u;let y,b;try{switch(g){case Be:b="int32",w.byteOffset%4!==0?y=new Int32Array(w.slice().buffer):y=new Int32Array(w.buffer,w.byteOffset,w.byteLength/4);break;case Ie:b="float32",w.byteOffset%4!==0?y=new Float32Array(w.slice().buffer):y=new Float32Array(w.buffer,w.byteOffset,w.byteLength/4);break;case ve:b="float64",w.byteOffset%8!==0?y=new Float64Array(w.slice().buffer):y=new Float64Array(w.buffer,w.byteOffset,w.byteLength/8);break;case Le:b="int64",w.byteOffset%8!==0?y=new BigInt64Array(w.slice().buffer):y=new BigInt64Array(w.buffer,w.byteOffset,w.byteLength/8);break;case de:case ye:default:b=g===ye?"bool":"string",y=JSON.parse(Y.decode(w));break}}catch(p){throw console.error(`[LanceQLWorker] Error parsing column '${h}' (type ${g}, len ${u}):`,p),p}c.push({name:h,dataType:b}),i[h]=y}return{schema:c,columns:i,rowCount:o,format:"binary"}}var G=class{constructor(e=512*1024*1024){this.maxBytes=e,this.currentBytes=0,this.cache=new Map,this.head=null,this.tail=null}get(e){let n=this.cache.get(e);if(n)return this._moveToHead(n),n.value}set(e,n,r=0){let t=this.cache.get(e);if(t)this.currentBytes-=t.size,this.currentBytes+=r,t.value=n,t.size=r,this._moveToHead(t);else{let s={key:e,value:n,size:r,prev:null,next:null};this.cache.set(e,s),this._addToHead(s),this.currentBytes+=r}this._evictIfNeeded()}has(e){return this.cache.has(e)}delete(e){let n=this.cache.get(e);n&&(this._removeNode(n),this.cache.delete(e),this.currentBytes-=n.size)}clear(){this.cache.clear(),this.head=null,this.tail=null,this.currentBytes=0}_moveToHead(e){e!==this.head&&(this._removeNode(e),this._addToHead(e))}_addToHead(e){e.next=this.head,e.prev=null,this.head&&(this.head.prev=e),this.head=e,this.tail||(this.tail=e)}_removeNode(e){e.prev?e.prev.next=e.next:this.head=e.next,e.next?e.next.prev=e.prev:this.tail=e.prev}_evictIfNeeded(){for(;this.currentBytes>this.maxBytes&&this.tail;){let e=this.tail;this._removeNode(e),this.cache.delete(e.key),this.currentBytes-=e.size}}static estimateSize(e){return e?e.byteLength?e.byteLength:Array.isArray(e)?e.length*100:e.buffer&&e.buffer.byteLength?e.buffer.byteLength:1e3:0}};var we=new Map,Pe=1,Q=class{constructor(e,n){this.name=e,this.tables=new Map,this.version=0,this.manifestKey=`${e}/__manifest__`,this.bufferPool=n||new G,this._writeBuffer=new Map,this._flushTimer=null,this._flushInterval=2e3,this._flushThreshold=1e4,this._columnarBuffer=new Map,this._flushing=!1,this._readCache=new Map,this._columnarCache=new Map}async open(){let e=await C.load(this.manifestKey);if(e){let n=JSON.parse(Y.decode(e));this.version=n.version||0,this.tables=new Map(Object.entries(n.tables||{}))}return this}async _saveManifest(){this.version++;let e={version:this.version,timestamp:Date.now(),tables:Object.fromEntries(this.tables)},n=$.encode(JSON.stringify(e));await C.save(this.manifestKey,n)}async createTable(e,n,r=!1){if(this.tables.has(e)){if(r)return{success:!0,existed:!0};throw new Error(`Table '${e}' already exists`)}let t=n.map(a=>({name:a.name,type:xe[(a.dataType||a.type)?.toUpperCase()]||a.dataType||a.type||"string",primaryKey:a.primaryKey||!1,vectorDim:a.vectorDim||null})),s={name:e,schema:t,fragments:[],deletionVector:[],rowCount:0,nextRowId:0,version:0,createdAt:Date.now()};return this.tables.set(e,s),await this._saveManifest(),{success:!0,table:e}}async dropTable(e,n=!1){if(!this.tables.has(e)){if(n)return this._writeBuffer.delete(e),{success:!0,existed:!1};throw new Error(`Table '${e}' does not exist`)}let r=this.tables.get(e);this._writeBuffer.delete(e);for(let t of r.fragments)this._readCache.delete(t),await C.delete(t);return this.tables.delete(e),await this._saveManifest(),{success:!0,table:e}}async insert(e,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=this.tables.get(e),t=n.length;if(!this._columnarBuffer.has(e)){let c=Math.max(1024,t*2),i={__rowId:new Float64Array(c),__length:0,__capacity:c,__schema:r.schema};for(let l of r.schema){let f=(l.dataType||l.type||"").toLowerCase();f==="text"||f==="string"||f==="varchar"?i[l.name]=new Array(c):f==="int64"||f==="bigint"?i[l.name]=new BigInt64Array(c):i[l.name]=new Float64Array(c)}this._columnarBuffer.set(e,i)}let s=this._columnarBuffer.get(e),a=s.__length,o=s.__capacity;if(a+t>o){let c=Math.max(o*2,a+t),i=new Float64Array(c);i.set(s.__rowId.subarray(0,a)),s.__rowId=i;for(let l of r.schema){let f=s[l.name];if(f instanceof Float64Array){let h=new Float64Array(c);h.set(f.subarray(0,a)),s[l.name]=h}else if(f instanceof BigInt64Array){let h=new BigInt64Array(c);h.set(f.subarray(0,a)),s[l.name]=h}else s[l.name].length=c}s.__capacity=c}for(let c=0;c<t;c++){let i=n[c];s.__rowId[a+c]=r.nextRowId++;for(let l of r.schema){let f=i[l.name];s[l.name]instanceof Float64Array?s[l.name][a+c]=f!=null?Number(f):NaN:s[l.name]instanceof BigInt64Array?s[l.name][a+c]=f!=null?BigInt(f):0n:s[l.name][a+c]=f??null}}return s.__length=a+t,r.rowCount+=t,r.version=(r.version||0)+1,this._scheduleFlush(),s.__length>=this._flushThreshold&&await this._flushTable(e),{success:!0,inserted:t}}_scheduleFlush(){this._flushTimer||(this._flushTimer=setTimeout(()=>{this._flushTimer=null,this.flush().catch(e=>console.warn("[WorkerDatabase] Flush error:",e))},this._flushInterval))}async flush(){if(!this._flushing){this._flushing=!0;try{let e=[...this._columnarBuffer.keys()];for(let n of e)await this._flushTable(n)}finally{this._flushing=!1}}}async _flushTable(e){let n=this._columnarBuffer.get(e),r=n?.__length||0;if(!n||r===0)return;let t=this.tables.get(e);if(!t)return;let s=[{name:"__rowId",type:"int64",dataType:"float64",primaryKey:!0},...t.schema.filter(l=>l.name!=="__rowId").map(l=>{let f=(l.dataType||l.type||"").toLowerCase();return f==="int64"||f==="bigint"?{...l,dataType:"int64"}:{...l,dataType:f==="float64"||f==="float32"||f==="int32"||f==="integer"||f==="real"||f==="double"?"float64":l.dataType||l.type||"float64"}})],a={};for(let l of s){let f=n[l.name];f&&(f instanceof Float64Array||f instanceof BigInt64Array?a[l.name]=f.subarray(0,r):a[l.name]=f.slice(0,r))}n.__length=0;let o=new ae(s);o.setColumnarData(a);let c=o.build(),i=`${this.name}/${e}/frag_${Date.now()}_${Math.random().toString(36).slice(2)}.lance`;await C.save(i,c),t.fragments.push(i),await this._saveManifest()}async delete(e,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=this.tables.get(e),t=0,s=this._columnarBuffer.get(e),a=s?.__length||0;if(s&&a>0){let o=r.schema.map(c=>c.name);for(let c=0;c<a;c++){let i={__rowId:s.__rowId[c]};for(let l of o){let f=s[l][c];i[l]=Number.isNaN(f)?null:f}n(i)&&(r.deletionVector.includes(s.__rowId[c])||(r.deletionVector.push(s.__rowId[c]),t++))}}for(let o of r.fragments){let c=await C.load(o);if(c){let i=this._parseFragment(c,r.schema);for(let l of i)!r.deletionVector.includes(l.__rowId)&&n(l)&&(r.deletionVector.push(l.__rowId),t++)}}return r.rowCount-=t,r.version=(r.version||0)+1,await this._saveManifest(),{success:!0,deleted:t}}async update(e,n,r){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let t=this.tables.get(e),s=0,a=this._writeBuffer.get(e);if(a&&a.length>0)for(let c of a)r(c)&&(Object.assign(c,n),s++);let o=[];for(let c of t.fragments){let i=await C.load(c);if(i){let l=this._parseFragment(i,t.schema);for(let f of l)if(!t.deletionVector.includes(f.__rowId)&&r(f)){t.deletionVector.push(f.__rowId),t.rowCount--;let h={...f,...n};delete h.__rowId,o.push(h),s++}}}return o.length>0?await this.insert(e,o):await this._saveManifest(),{success:!0,updated:s}}async updateWithExpr(e,n,r,t){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=this.tables.get(e),a=0,o=this._columnarBuffer.get(e),c=o?.__length||0;if(o&&c>0){let l=s.schema.map(f=>f.name);for(let f=0;f<c;f++){let h={__rowId:o.__rowId[f]};for(let g of l){let m=o[g][f];h[g]=Number.isNaN(m)?null:m}if(r(h)){for(let[g,m]of Object.entries(n)){let u=t(m,h);o[g]!==void 0&&(o[g][f]=u??(o[g]instanceof Float64Array?NaN:null))}s.version=(s.version||0)+1,a++}}}let i=[];for(let l of s.fragments){let f=await C.load(l);if(f){let h=this._parseFragment(f,s.schema);for(let g of h)if(!s.deletionVector.includes(g.__rowId)&&r(g)){s.deletionVector.push(g.__rowId),s.rowCount--;let m={...g};for(let[u,w]of Object.entries(n))m[u]=t(w,g);delete m.__rowId,i.push(m),a++}}}return i.length>0?await this.insert(e,i):await this._saveManifest(),{success:!0,updated:a}}async select(e,n={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=await this._readAllRows(e);if(n.where&&(r=r.filter(n.where)),n.orderBy){let{column:a,desc:o}=n.orderBy;r.sort((c,i)=>{let l=c[a]<i[a]?-1:c[a]>i[a]?1:0;return o?-l:l})}n.offset&&(r=r.slice(n.offset)),n.limit&&(r=r.slice(0,n.limit));let t=n.columns&&n.columns.length>0&&n.columns[0]!=="*"?n.columns:null,s=new Array(r.length);for(let a=0;a<r.length;a++){let o=r[a];if(t){let c={};for(let i of t)c[i]=o[i];s[a]=c}else{let{__rowId:c,...i}=o;s[a]=i}}return s}async _readAllRows(e){let n=this.tables.get(e),r=this._columnarBuffer.get(e),s=n.deletionVector.length>0?new Set(n.deletionVector):null,a=[];for(let c of n.fragments){let i=this.bufferPool.get(c),l=null;if(!i){let f=await C.load(c);f&&(i=Z(f),i?this.bufferPool.set(c,i,f.byteLength):l=this._parseFragment(f,n.schema))}if(i&&!l&&(l=this._hydrateRowsFromBinary(i,n.schema)),l=l||[],!s)a.push(...l);else for(let f of l)s.has(f.__rowId)||a.push(f)}let o=r?.__length||0;if(r&&o>0){let c=n.schema.map(i=>i.name);for(let i=0;i<o;i++){if(s&&s.has(r.__rowId[i]))continue;let l={__rowId:r.__rowId[i]};for(let f of c){let h=r[f][i];l[f]=Number.isNaN(h)?null:h}a.push(l)}}return a}_hydrateRowsFromBinary(e,n){let{columns:r,rowCount:t}=e,s=n.map(o=>o.name),a=new Array(t);for(let o=0;o<t;o++){let c={__rowId:r.__rowId[o]};for(let i of s)r[i]&&(c[i]=r[i][o]);a[o]=c}return a}_parseFragment(e,n){try{let r=Z(e);if(r)return this._parseBinaryColumnar(r);let t=Y.decode(e),s=JSON.parse(t);return s.format==="json"&&s.columns?this._parseJsonColumnar(s):Array.isArray(s)?s:[s]}catch(r){return console.warn("[WorkerDatabase] Failed to parse fragment:",r),[]}}async selectColumnar(e){let n=this.tables.get(e);if(!n)return null;let r=this._columnarBuffer.get(e)?.__length||0,t=`${n.fragments.length}:${r}:${n.deletionVector.length}:${n.version||0}`,s=this._columnarCache.get(e);if(s&&s.version===t){let u={};for(let[w,y]of Object.entries(s.data.columns))ArrayBuffer.isView(y)?u[w]=new y.constructor(y.buffer,y.byteOffset,y.length):u[w]=y;return{schema:n.schema,columns:u,rowCount:s.data.rowCount}}let o=n.deletionVector.length>0?new Set(n.deletionVector):null,c={},i=n.schema.map(u=>u.name);for(let u of i)c[u]=[];c.__rowId=[];for(let u of n.fragments){let w=this.bufferPool.get(u);if(!w){let p=await C.load(u);if(!p)continue;w=Z(p),w&&this.bufferPool.set(u,w,p.byteLength)}if(!w)continue;let{columns:y,rowCount:b}=w;if(o){let p=y.__rowId,_=[];for(let A=0;A<b;A++)o.has(p[A])||_.push(A);for(let A of i)if(y[A]){let x=y[A],T=new x.constructor(_.length);for(let U=0;U<_.length;U++)T[U]=x[_[U]];c[A].push(T)}}else{for(let p of i)y[p]&&c[p].push(y[p]);y.__rowId&&c.__rowId.push(y.__rowId)}}let l=this._columnarBuffer.get(e),f=l?.__length||0;if(l&&f>0)if(o){let u=[];for(let b=0;b<f;b++)o.has(l.__rowId[b])||u.push(b);let w=u.length;for(let b of n.schema){let p=l[b.name];if(p)if(p instanceof Float64Array){let _=new Float64Array(w);for(let A=0;A<w;A++)_[A]=p[u[A]];c[b.name].push(_)}else c[b.name].push(u.map(_=>p[_]))}let y=new Float64Array(w);for(let b=0;b<w;b++)y[b]=l.__rowId[u[b]];c.__rowId.push(y)}else{for(let w of n.schema){let y=l[w.name];if(y)if(y instanceof Float64Array){let b=new Float64Array(f);b.set(y.subarray(0,f)),c[w.name].push(b)}else c[w.name].push(y.slice(0,f))}let u=new Float64Array(f);u.set(l.__rowId.subarray(0,f)),c.__rowId.push(u)}let h={},g=0;for(let u of[...i,"__rowId"]){let w=c[u];if(w.length===0)h[u]=new Float64Array(0);else if(w.length===1)h[u]=w[0],g===0&&(g=w[0].length);else{let y=w.reduce((A,x)=>A+x.length,0);g===0&&(g=y);let b=w[0],p=ArrayBuffer.isView(b)?new b.constructor(y):new Array(y),_=0;for(let A of w){if(ArrayBuffer.isView(p))p.set(A,_);else for(let x=0;x<A.length;x++)p[_+x]=A[x];_+=A.length}h[u]=p}}let m={schema:n.schema,columns:h,rowCount:g};return this._columnarCache.set(e,{version:t,data:m}),m}async _readColumn(e,n){let r=this.tables.get(e);if(!r)return null;let t=this._writeBuffer.get(e),s=[];for(let i of r.fragments){let l=await C.load(i);if(!l)continue;let f=Z(l);if(f&&f.columns[n]){let h=f.columns[n];h.length>0&&s.push(h)}}if(t&&t.length>0){let i=new Float64Array(t.length);for(let l=0;l<t.length;l++){let f=t[l][n];i[l]=typeof f=="number"?f:0}s.push(i)}if(s.length===0)return new Float64Array(0);if(s.length===1)return s[0];let a=s.reduce((i,l)=>i+l.length,0),o=new Float64Array(a),c=0;for(let i of s)o.set(i,c),c+=i.length;return o}_parseBinaryColumnar(e){let{schema:n,columns:r,rowCount:t}=e,s=new Array(t),a=n.map(i=>i.name),o=a.map(i=>r[i]),c=a.length;for(let i=0;i<t;i++){let l={};for(let f=0;f<c;f++)l[a[f]]=o[f][i]??null;s[i]=l}return s}_parseJsonColumnar(e){let{schema:n,columns:r,rowCount:t}=e,s=new Array(t),a=n.map(i=>i.name),o=a.map(i=>r[i]||[]),c=a.length;for(let i=0;i<t;i++){let l={};for(let f=0;f<c;f++)l[a[f]]=o[f][i]??null;s[i]=l}return s}getTable(e){return this.tables.get(e)}listTables(){return Array.from(this.tables.keys())}getFragmentPaths(e){let n=this.tables.get(e);return n?n.fragments:[]}getColumnIndex(e,n){let r=this.tables.get(e);if(!r)return-1;let t=r.schema.findIndex(s=>s.name===n);return t>=0?t+1:-1}hasBufferedData(e){let n=this._columnarBuffer.get(e);return n&&(n.__length||0)>0}async compact(){for(let[e,n]of this.tables){let r=await this._readAllRows(e);for(let t of n.fragments)await C.delete(t);if(n.fragments=[],n.deletionVector=[],n.rowCount=0,n.nextRowId=0,r.length>0){let t=r.map(({__rowId:s,...a})=>a);await this.insert(e,t)}}return{success:!0,compacted:this.tables.size}}async scanStart(e,n={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=Pe++,t=this.tables.get(e),s=new Set(t.deletionVector),a=[];for(let c of t.fragments){let i=await C.load(c);if(i){let l=this._parseFragment(i,t.schema);for(let f of l)s.has(f.__rowId)||a.push(f)}}let o=this._writeBuffer.get(e);if(o)for(let c of o)s.has(c.__rowId)||a.push(c);return we.set(r,{rows:a,index:0,batchSize:n.batchSize||1e4,columns:n.columns}),r}scanNext(e){let n=we.get(e);if(!n)return{batch:[],done:!0};let r=[],t=Math.min(n.index+n.batchSize,n.rows.length);for(let a=n.index;a<t;a++){let o=n.rows[a],c;if(n.columns&&n.columns.length>0&&n.columns[0]!=="*"){c={};for(let i of n.columns)c[i]=o[i]}else{let{__rowId:i,...l}=o;c=l}r.push(c)}n.index=t;let s=n.index>=n.rows.length;return s&&we.delete(e),{batch:r,done:s}}};var oe=class{constructor(){this._root=null,this._ready=!1,this._kv={},this._encryptionKeyId=null,this._db=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:n,keyBytes:r}=e;if(!W.has(n)){let t=await te(r);W.set(n,t)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle("vault",{create:!0}),await this._loadKV(),this._db=new Q("vault"),await this._db.open(),this._ready=!0}catch(n){throw console.error("[WorkerVault] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?W.get(this._encryptionKeyId):null}async _loadKV(){try{let e=this._getCryptoKey(),n=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(n)).getFile();if(e){let s=await t.arrayBuffer();this._kv=await re(new Uint8Array(s),e)}else{let s=await t.text();this._kv=JSON.parse(s)}}catch(e){if(e.name==="NotFoundError")this._kv={};else throw e}}async _saveKV(){let e=this._getCryptoKey(),n=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(n,{create:!0})).createWritable();if(e){let s=await ne(this._kv,e);await t.write(s)}else await t.write(JSON.stringify(this._kv));await t.close()}async get(e){return this._kv[e]}async set(e,n){this._kv[e]=n,await this._saveKV()}async delete(e){delete this._kv[e],await this._saveKV()}async keys(){return Object.keys(this._kv)}async has(e){return e in this._kv}};var Re=1;var Ce={INT64:0,FLOAT64:1,INT32:2,FLOAT32:3,STRING:4,LIST:5},me=class{constructor(){this._registered=new Map}getLastError(){let e=O();if(!e)return"WASM not loaded";let n=M(),r=e.alloc(4096);console.log(`[WASM LOG] getLastError alloc ptr: ${r}`);let t=e.getLastError(r,4096);if(console.log(`[WASM LOG] getLastError len: ${t}`),t===0)return"Unknown Error";let s=new Uint8Array(n.buffer,r,t),a=new TextDecoder().decode(s);return console.log(`[WASM LOG] getLastError msg: ${a}`),a}getTableNames(e){let n=O();if(!n)throw new Error("WASM not loaded");let r=M(),t=new TextEncoder().encode(e),s=n.alloc(t.length);new Uint8Array(r.buffer,s,t.length).set(t);let a=n.getTableNames(s,t.length);if(a===0)return[];let o=new Uint8Array(r.buffer,a),c=0;for(;o[c]!==0&&c<1024;)c++;let i=new TextDecoder().decode(o.subarray(0,c));return i?i.split(",").filter(l=>l):[]}hasTable(e){let n=O();if(!n)return!1;let r=M(),t=new TextEncoder().encode(e),s=n.alloc(t.length);return new Uint8Array(r.buffer,s,t.length).set(t),n.hasTable(s,t.length)===1}registerTable(e,n,r,t=""){let s=O();if(!s)throw new Error("WASM not loaded");let a=this._registered.get(e);if(a&&a.version===t)return;if(a){let f=new TextEncoder().encode(e);s.clearTable(f,f.length)}let o=M(),c=new TextEncoder().encode(e),i=s.alloc(c.length);new Uint8Array(o.buffer,i,c.length).set(c);let l=new Set;for(let[f,h]of Object.entries(n)){if(f.startsWith("__"))continue;let g=new TextEncoder().encode(f),m=s.alloc(g.length);if(new Uint8Array(o.buffer,m,g.length).set(g),h instanceof Float64Array){let u=s.allocFloat64Buffer(h.length);new Float64Array(o.buffer,u,h.length).set(h),s.registerTableFloat64(i,c.length,m,g.length,u,h.length),l.add(f)}else if(h instanceof BigInt64Array){let u=s.allocInt64Buffer(h.length);new BigInt64Array(o.buffer,u,h.length).set(h),s.registerTableInt64(i,c.length,m,g.length,u,h.length),l.add(f)}else if(h instanceof Int32Array){let u=new Float64Array(h.length);for(let y=0;y<h.length;y++)u[y]=h[y];let w=s.allocFloat64Buffer(u.length);new Float64Array(o.buffer,w,u.length).set(u),s.registerTableFloat64(i,c.length,m,g.length,w,u.length),l.add(f)}else if(Array.isArray(h)){let u=new Uint32Array(h.length),w=new Uint32Array(h.length),y=0;for(let T=0;T<h.length;T++){let U=String(h[T]||"");w[T]=U.length,u[T]=y,y+=U.length}let b=new Uint8Array(y),p=0;for(let T=0;T<h.length;T++){let U=String(h[T]||""),N=new TextEncoder().encode(U);b.set(N,p),p+=N.length}let _=s.alloc(u.byteLength);new Uint32Array(o.buffer,_,u.length).set(u);let A=s.alloc(w.byteLength);new Uint32Array(o.buffer,A,w.length).set(w);let x=s.alloc(b.length);new Uint8Array(o.buffer,x,b.length).set(b),s.registerTableString(i,c.length,m,g.length,_,A,x,y,h.length),l.add(f)}}this._registered.set(e,{version:t,columns:l,rowCount:r})}registerTableFromFiles(e,n,r=""){let t=O();if(!t)throw new Error("WASM not loaded");let s=this._registered.get(e);if(s&&s.version===r)return;if(s){let i=new TextEncoder().encode(e);t.clearTable(i,i.length)}let a=new TextEncoder,o=a.encode(e),c=t.alloc(o.length);new Uint8Array(M().buffer,c,o.length).set(o);for(let i of n){let l=a.encode(i),f=t.alloc(l.length);new Uint8Array(M().buffer,f,l.length).set(l);let h=t.registerTableFromOPFS(c,o.length,f,l.length);h!==0&&console.warn(`Failed to register fragment ${i} for table ${e}: error ${h}`)}this._registered.set(e,{version:r,type:"files"})}appendTableMemory(e,n,r){let t=O();if(!t)throw new Error("WASM not loaded");let s=M(),a=new TextEncoder().encode(e),o=t.alloc(a.length);new Uint8Array(s.buffer,o,a.length).set(a);for(let[c,i]of Object.entries(n)){if(c.startsWith("__"))continue;let l=new TextEncoder().encode(c),f=t.alloc(l.length);if(new Uint8Array(s.buffer,f,l.length).set(l),i instanceof Float64Array){let h=t.allocFloat64Buffer(i.length);new Float64Array(s.buffer,h,i.length).set(i),t.appendTableMemory(o,a.length,f,l.length,h,4,r)}else if(i instanceof BigInt64Array){let h=t.allocInt64Buffer(i.length);new BigInt64Array(s.buffer,h,i.length).set(i),t.appendTableMemory(o,a.length,f,l.length,h,2,r)}else if(i instanceof Int32Array){let h=t.alloc(i.byteLength);new Int32Array(s.buffer,h,i.length).set(i),t.appendTableMemory(o,a.length,f,l.length,h,1,r)}else if(i instanceof Float32Array){let h=t.alloc(i.byteLength);new Float32Array(s.buffer,h,i.length).set(i),t.appendTableMemory(o,a.length,f,l.length,h,3,r)}}}execute(e){let n=O();if(!n)throw new Error("WASM not loaded");let r=M(),t=n.getSqlInputBuffer(),s=n.getSqlInputBufferSize(),a=new TextEncoder().encode(e);if(a.length>s)throw new Error(`SQL too long: ${a.length} > ${s}`);new Uint8Array(r.buffer,t,a.length).set(a),n.setSqlInputLength(a.length);let o=n.executeSql();if(o===0){let h=this.getLastError();throw console.log(`[WASM LOG] execute throwing: "${h}"`),new Error(h)}let c=n.getResultSize(),i=this.getLastError();i&&i.length>0&&console.log(`[WASM DEBUG CAPTURED] ${i}`),i.length>0&&i.startsWith("DEBUG:");let l=n.memory.buffer,f=this._parseResult(r.buffer,o,c);return n.resetResult(),f}_parseResult(e,n,r){let t=new DataView(e,n,r),s=new TextDecoder;if(r>=40){let a=r-40,o=[t.getUint8(a+36),t.getUint8(a+37),t.getUint8(a+38),t.getUint8(a+39)];if(String.fromCharCode(...o)==="LANC")return this._parseLanceResult(e,n,r,a,t,s)}if(r>=36&&t.getUint32(0,!0)===Re)return this._parseLegacyResult(e,n,r);throw new Error(`Invalid result format (Size: ${r}). Not a Lance file.`)}_parseLanceResult(e,n,r,t,s,a){let o=Number(s.getBigUint64(t+8,!0)),c=s.getUint32(t+28,!0),i=[],l={},f=0;for(let h=0;h<c;h++){let g=o+h*8,u=Number(s.getBigUint64(g,!0));s.getUint8(u++);let[w,y]=this._readVarint(s,u);u+=y;let b=new Uint8Array(e,n+u,w),p=a.decode(b);u+=w,i.push(p),s.getUint8(u++);let[_,A]=this._readVarint(s,u);u+=A;let x=new Uint8Array(e,n+u,_),T=a.decode(x);u+=_,s.getUint8(u++);let[U,N]=this._readVarint(s,u);u+=N,s.getUint8(u++);let le=Number(s.getBigUint64(u,!0));u+=8,s.getUint8(u++);let[B,V]=this._readVarint(s,u);u+=V,f=B,s.getUint8(u++);let[fe,Me]=this._readVarint(s,u);u+=Me;let j=n+le;if(T==="float64"||T==="int64"||T==="int32"||T==="float32")if(T==="float64"){let E=new Float64Array(e,j,B).slice(),I=!1;for(let S=0;S<B;S++)if(Number.isNaN(E[S])){I=!0;break}if(I){console.log(`[WASM LOG] Column ${p} has NaNs, converting to nulls`);let S=new Array(B);for(let L=0;L<B;L++){let P=E[L];S[L]=Number.isNaN(P)?null:P}l[p]=S}else l[p]=E}else if(T==="int64"){let E=new BigInt64Array(e,j,B),I=new Array(B),S=-9223372036854775808n;for(let L=0;L<B;L++){let P=E[L];I[L]=P===S?null:Number(P)}l[p]=I}else if(T==="int32"){let E=new Int32Array(e,j,B),I=new Array(B);for(let S=0;S<B;S++){let L=E[S];L===-2147483648?I[S]=null:I[S]=L}l[p]=I}else{let E=new Float32Array(e,j,B),I=new Array(B);for(let S=0;S<B;S++){let L=E[S];I[S]=isNaN(L)?null:L}l[p]=I}else if(T==="string"||T==="list"){let E=T==="list",I=(B+1)*4,S=fe-I,L=new Uint8Array(e,j,S).slice(),P=new Uint32Array(e,j+S,B+1).slice();l[p]={_arrowString:!0,offsets:P,bytes:L,isList:T==="list"}}}return{_format:"columnar",columns:i,rowCount:f,data:l}}_readVarint(e,n){let r=0,t=0,s=0;for(;;){let a=e.getUint8(n+s);if(s++,r|=(a&127)<<t,(a&128)===0)break;t+=7}return[r,s]}_parseLegacyResult(e,n,r){let t=new DataView(e,n,r),s=new TextDecoder,a=t.getUint32(4,!0),o=Number(t.getBigUint64(8,!0)),c=t.getUint32(24,!0),i=t.getUint32(32,!0),l=[],f={};for(let h=0;h<a;h++){let g=36+h*16,m=t.getUint32(g,!0),u=t.getUint32(g+4,!0),w=t.getUint32(g+8,!0),y=t.getUint32(g+12,!0),b=new Uint8Array(e,n+i+u,w),p=s.decode(b);l.push(p);let _=Object.keys(Ce).find(x=>Ce[x]===m).toLowerCase(),A=n+c+y;if(_==="float64"||_==="int64"||_==="int32"||_==="float32")_==="float64"?f[p]=new Float64Array(e,A,o).slice():_==="int64"?f[p]=new Float64Array(e,A,o).slice():_==="int32"?f[p]=new Int32Array(e,A,o).slice():_==="float32"&&(f[p]=new Float32Array(e,A,o).slice());else if(_==="string"||_==="list"){let x=new Uint32Array(o+1),T=0;x[0]=0;let U=A,N=0;for(let V=0;V<o;V++){let fe=t.getUint32(U+V*8+4,!0);N+=fe,x[V+1]=N}let le=A+o*8,B=new Uint8Array(e,le,N).slice();f[p]={_arrowString:!0,offsets:x,bytes:B,isList:_==="list"}}}return{_format:"columnar",columns:l,rowCount:o,data:f}}clear(){let e=O();e&&e.clearTables(),this._registered.clear()}},ge=null;function X(){return ge||(ge=new me),ge}async function Fe(d,e){if(!k&&(await ee(),!k))throw new Error("WASM not loaded");let n=X(),r=n.getTableNames(e);for(let t of r){if(n.hasTable(t))continue;let a=d.tables.get(t);if(!a)continue;let o=d._columnarBuffer?.get(t),c=o?.__length||0,i=`${t}:${a.fragments?.length||0}:${c}:${a.deletionVector?.length||0}`,l=a.fragments.length>0,f=c>0;if(l){let h=[];for(let g of a.fragments){let m=await Ve(g);m&&h.push(m)}if(n.registerTableFromFiles(t,a.fragments,i),f){let g={};for(let m of a.schema){let u=o[m.name];u&&ArrayBuffer.isView(u)&&(g[m.name]=u.subarray(0,c))}n.appendTableMemory(t,g,c)}}else if(f){let h=await d.selectColumnar(t);if(h){let{columns:g,rowCount:m}=h;n.registerTable(t,g,m,i)}}}return n.execute(e)}var k=null,H=null,z=new Map,Ke=1;async function Oe(d){let e=await navigator.storage.getDirectory();e=await e.getDirectoryHandle("lanceql",{create:!0});for(let n of d)e=await e.getDirectoryHandle(n,{create:!0});return e}function He(){return{env:{opfs_open:(d,e)=>{try{let n=new Uint8Array(H.buffer,d,e),r=new TextDecoder().decode(n);for(let[t,s]of z.entries())if(s._path===r)return t;return console.warn("[LanceQLWorker] WASM tried to open unregistered path:",r),0}catch(n){return console.error("[LanceQLWorker] Error:",n),0}},opfs_read:(d,e,n,r)=>{let t=z.get(d);if(!t)return 0;try{let s=new Uint8Array(H.buffer,e,n);return t.read(s,{at:Number(r)})}catch{return 0}},opfs_size:d=>{let e=z.get(d);if(!e)return BigInt(0);try{return BigInt(e.getSize())}catch{return BigInt(0)}},opfs_close:d=>{},__assert_fail:(d,e,n,r)=>{let s=new TextDecoder().decode(new Uint8Array(H.buffer,d).subarray(0,100));console.error(`[WASM ASSERT] ${s} at line ${n}`)},js_log:(d,e)=>{let r=new TextDecoder().decode(new Uint8Array(H.buffer,d,e));console.log(`[WASM LOG] ${r}`)}}}}async function Ve(d){try{let e=d.split("/").filter(o=>o),n=e.pop(),s=await(await(await Oe(e)).getFileHandle(n)).createSyncAccessHandle(),a=Ke++;return s._path=d,z.set(a,s),a}catch(e){return console.warn("[LanceQLWorker] Failed to register OPFS file:",d,e),0}}function It(d){let e=z.get(d);if(e){try{e.close()}catch{}z.delete(d)}}async function ee(){if(k)return k;try{let d=new URL("./lanceql.wasm",import.meta.url);d.searchParams.set("v",Date.now().toString());let n=await(await fetch(d)).arrayBuffer(),r=He();return k=(await WebAssembly.instantiate(n,r)).instance.exports,H=k.memory,console.log("[LanceQLWorker] WASM loaded with OPFS support"),k}catch(d){return console.warn("[LanceQLWorker] WASM not available:",d.message),null}}function O(){return k}function M(){return H}var pe=0,Ue=0,je=1024*1024;function Ge(d){if(!k)return 0;if(d<=Ue&&pe!==0)return pe;let e=Math.max(d,je),n=k.alloc(e);return n&&(pe=n,Ue=e),n}async function vt(d){let e=await ee();if(!e)return 0;try{let n=d.split("/").filter(f=>f),r=n.pop(),a=await(await(await Oe(n)).getFileHandle(r)).createSyncAccessHandle(),o=a.getSize(),c=Ge(o);if(!c)return a.close(),0;let i=new Uint8Array(H.buffer,c,o),l=a.read(i,{at:0});return a.close(),l!==o?0:e.openFile(c,o)}catch(n){return console.warn("[LanceQLWorker] Failed to load fragment:",d,n),0}}async function Qe(d,e){let n=e.split("/").filter(t=>t),r=d;for(let t=0;t<n.length-1;t++)r=await r.getDirectoryHandle(n[t],{create:!1});return await r.getFileHandle(n[n.length-1],{create:!1})}var be=null;async function qe(d){let e=Te.get(d);if(e)return e;be||(be=await navigator.storage.getDirectory());let t=await(await(await Qe(be,d)).getFile()).arrayBuffer();return e=new Uint8Array(t),e&&Te.set(d,e,e.byteLength),e}async function Ct(d,e,n){if(!await qe(d))return null;let t=k;switch(n){case"sum":return t.opfsSumFloat64Column(e);case"min":return t.opfsMinFloat64Column(e);case"max":return t.opfsMaxFloat64Column(e);case"avg":return t.opfsAvgFloat64Column(e);case"count":return Number(t.opfsCountRows());default:return null}}ee();var Te=new G,_e=new Map,Ae=new Map,ie=null,ke=new Set,q=null,K=0,ze=1024,ce=new Map,Ee=1;async function R(d=null){return ie||(ie=new oe),await ie.open(d),ie}async function F(d,e={},n=null){let r=n?.keyId||"none",t=`${d}:${r}:${JSON.stringify(e)}`;if(!_e.has(t)){let s=new se(d,e);await s.open(n),_e.set(t,s)}return _e.get(t)}async function v(d){if(!Ae.has(d)){let e=new Q(d,Te);await e.open(),Ae.set(d,e)}return Ae.get(d)}function Je(d,e,n){if(n&&n._format==="wasm_binary"){d.postMessage({id:e,result:{_format:"wasm_binary",buffer:n.buffer,columns:n.columns,rowCount:n.rowCount,schema:n.schema}},[n.buffer]);return}if(n&&n._format==="columnar"&&n.data){let r=n.columns,t=n.rowCount;if(t<1e5){let g=[],m={},u=new Set;for(let w of r){let y=n.data[w];if(ArrayBuffer.isView(y)){let b=y.byteOffset!==0||y.byteLength<y.buffer.byteLength,p=u.has(y.buffer);if(b||p){let _=new y.constructor(y);m[w]=_,g.push(_.buffer)}else m[w]=y,g.push(y.buffer),u.add(y.buffer)}else y&&y._arrowString?(m[w]=y,y.offsets&&y.offsets.buffer&&!u.has(y.offsets.buffer)&&(g.push(y.offsets.buffer),u.add(y.offsets.buffer)),y.bytes&&y.bytes.buffer&&!u.has(y.bytes.buffer)&&(g.push(y.bytes.buffer),u.add(y.bytes.buffer))):m[w]=y}d.postMessage({id:e,result:{_format:"columnar",columns:r,rowCount:t,data:m}},g);return}let s=[],a=[],o=0;for(let g of r){let m=n.data[g];ArrayBuffer.isView(m)?(s.push({name:g,arr:m}),o+=m.byteLength):Array.isArray(m)&&a.push({name:g,arr:m})}let c=o>0?new ArrayBuffer(o):null,i={},l=0;if(c){let g=new Uint8Array(c);for(let{name:m,arr:u}of s){let w=new Uint8Array(u.buffer,u.byteOffset,u.byteLength);g.set(w,l),i[m]={offset:l,length:u.length,type:u.constructor.name},l+=u.byteLength}}let f={};for(let{name:g,arr:m}of a)f[g]=m;let h=[];c&&h.push(c),d.postMessage({id:e,result:{_format:"packed",columns:r,rowCount:t,packedBuffer:c,colOffsets:i,stringData:f}},h);return}if(q&&n!==void 0){let r=JSON.stringify(n);if(r.length>ze){let t=$.encode(r);if(K+t.length<=q.byteLength){new Uint8Array(q,K,t.length).set(t),d.postMessage({id:e,sharedOffset:K,sharedLength:t.length}),K+=t.length,K>q.byteLength/2&&(K=0);return}}}d.postMessage({id:e,result:n})}async function De(d,e){if(e.type==="initSharedBuffer"){q=e.buffer,K=0,console.log("[LanceQLWorker] SharedArrayBuffer initialized:",q.byteLength,"bytes");return}let{id:n,method:r,args:t}=e;try{let s;if(r==="ping")s="pong";else if(r==="open")await F(t.name,t.options,t.encryption),s=!0;else if(r==="get")s=await(await F(t.name)).get(t.key);else if(r==="set")await(await F(t.name)).set(t.key,t.value),s=!0;else if(r==="delete")await(await F(t.name)).delete(t.key),s=!0;else if(r==="keys")s=await(await F(t.name)).keys();else if(r==="clear")await(await F(t.name)).clear(),s=!0;else if(r==="filter")s=await(await F(t.name)).filter(t.key,t.query);else if(r==="find")s=await(await F(t.name)).find(t.key,t.query);else if(r==="search")s=await(await F(t.name)).search(t.key,t.text,t.limit);else if(r==="count")s=await(await F(t.name)).count(t.key,t.query);else if(r==="enableSemanticSearch")s=await(await F(t.name)).enableSemanticSearch(t.options);else if(r==="disableSemanticSearch")(await F(t.name)).disableSemanticSearch(),s=!0;else if(r==="hasSemanticSearch")s=(await F(t.name)).hasSemanticSearch();else if(r==="db:open")console.log(`[LanceQLWorker] db:open ${t.name}`),await v(t.name),s=!0;else if(r==="db:createTable")console.log(`[LanceQLWorker] db:createTable ${t.tableName}`),s=await(await v(t.db)).createTable(t.tableName,t.columns,t.ifNotExists),console.log(`[LanceQLWorker] db:createTable ${t.tableName} done`);else if(r==="db:dropTable"){console.log(`[LanceQLWorker] db:dropTable ${t.tableName}`),s=await(await v(t.db)).dropTable(t.tableName,t.ifExists);let o=$.encode(t.tableName);X().clearTable(o,o.length)}else if(r==="db:insert")console.log(`[LanceQLWorker] db:insert into ${t.tableName}, rows: ${t.rows?.length}`),s=await(await v(t.db)).insert(t.tableName,t.rows),console.log("[LanceQLWorker] db:insert done");else if(r==="db:delete"){let a=await v(t.db),o=t.where?c=>evalWhere(t.where,c):()=>!0;s=await a.delete(t.tableName,o)}else if(r==="db:update"){let a=await v(t.db),o=t.where?c=>evalWhere(t.where,c):()=>!0;s=await a.update(t.tableName,t.updates,o)}else if(r==="db:select"){let a=await v(t.db),o={...t.options};t.where&&(o.where=c=>evalWhere(t.where,c)),s=await a.select(t.tableName,o)}else if(r==="db:exec"){let a=await v(t.db),c=X().getTableNames(t.sql),i=c[0]?a.tables.get(c[0]):null,l=i?i.rowCount:0;if(s=await Fe(a,t.sql),s&&s._format==="columnar"&&s.rowCount>=1e5){let f=Ee++;ce.set(f,s),s={_format:"cursor",cursorId:f,columns:s.columns,rowCount:s.rowCount}}}else if(r==="cursor:fetch"){let a=ce.get(t.cursorId);if(!a)throw new Error("Cursor not found");s=a,ce.delete(t.cursorId)}else if(r==="db:flush")console.log(`[LanceQLWorker] db:flush ${t.db}`),await(await v(t.db)).flush(),console.log(`[LanceQLWorker] db:flush ${t.db} done`),s=!0;else if(r==="db:compact")s=await(await v(t.db)).compact();else if(r==="db:listTables")s=(await v(t.db)).listTables();else if(r==="db:getTable")s=(await v(t.db)).getTable(t.tableName);else if(r==="db:scanStart")s=await(await v(t.db)).scanStart(t.tableName,t.options);else if(r==="db:scanNext")s=(await v(t.db)).scanNext(t.streamId);else if(r==="vault:open")await R(t.encryption),s=!0;else if(r==="vault:get")s=await(await R()).get(t.key);else if(r==="vault:set")await(await R()).set(t.key,t.value),s=!0;else if(r==="vault:delete")await(await R()).delete(t.key),s=!0;else if(r==="vault:keys")s=await(await R()).keys();else if(r==="vault:has")s=await(await R()).has(t.key);else if(r==="vault:exec"){let a=await R(),c=X().getTableNames(t.sql),i=c[0]?a._db.tables.get(c[0]):null,l=i?i.rowCount:0;if(s=await Fe(a._db,t.sql),s&&s._format==="columnar"&&s.rowCount>=1e5){let f=Ee++;ce.set(f,s),s={_format:"cursor",cursorId:f,columns:s.columns,rowCount:s.rowCount}}}else throw new Error(`Unknown method: ${r}`);Je(d,n,s)}catch(s){d.postMessage({id:n,error:s.stack||s.message})}}var Ye=typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope;Ye?self.onconnect=d=>{let e=d.ports[0];ke.add(e),e.onmessage=n=>{De(e,n.data)},e.onmessageerror=n=>{console.error("[LanceQLWorker] Message error:",n)},ee().then(()=>{e.postMessage({type:"ready"})}).catch(n=>{console.error("[LanceQLWorker] Failed to load WASM:",n),e.postMessage({type:"ready",error:"WASM load failed"})}),e.start(),console.log("[LanceQLWorker] New connection, total ports:",ke.size)}:(self.onmessage=d=>{De(self,d.data)},ee().then(()=>{self.postMessage({type:"ready"})}).catch(d=>{console.error("[LanceQLWorker] Failed to load WASM:",d),self.postMessage({type:"ready",error:"WASM load failed"})}));console.log("[LanceQLWorker] Initialized");export{It as closeOPFSFile,O as getWasm,M as getWasmMemory,vt as loadFragmentToWasm,Ve as registerOPFSFile,Ct as wasmAggregate};
//# sourceMappingURL=lanceql-worker.js.map
