var ht=Object.defineProperty;var be=(u,e)=>()=>(u&&(e=u(u=0)),e);var mt=(u,e)=>{for(var t in e)ht(u,t,{get:e[t],enumerable:!0})};var fe,ue,Ke=be(()=>{fe=class{constructor(e){this.device=e,this.buffers=new Map,this.uniformBuffers=new Map,this.bindGroups=new Map,this.pipelines=new Map,this.allocatedBytes=0,this.maxBytes=512*1024*1024}getOrCreateBuffer(e,t,s=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST){let n=`${e}_${t}`;if(this.buffers.has(n))return this.buffers.get(n);let r=this.device.createBuffer({size:t,usage:s,label:e});return this.buffers.set(n,r),this.allocatedBytes+=t,r}createBufferWithData(e,t,s=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST){let n=this.device.createBuffer({size:t.byteLength,usage:s,label:e,mappedAtCreation:!0});return new t.constructor(n.getMappedRange()).set(t),n.unmap(),this.buffers.set(e,n),this.allocatedBytes+=t.byteLength,n}createUniformBuffer(e,t){let s=Math.ceil(t.byteLength/16)*16,n=this.device.createBuffer({size:s,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:`uniform_${e}`});return this.device.queue.writeBuffer(n,0,t),this.uniformBuffers.set(e,n),n}updateUniform(e,t){let s=this.uniformBuffers.get(e);s&&this.device.queue.writeBuffer(s,0,t)}createBindGroup(e,t,s){let n=this.device.createBindGroup({layout:t,entries:s,label:e});return this.bindGroups.set(e,n),n}async readBuffer(e,t){let s=this.device.createBuffer({size:t,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),n=this.device.createCommandEncoder();n.copyBufferToBuffer(e,0,s,0,t),this.device.queue.submit([n.finish()]),await s.mapAsync(GPUMapMode.READ);let r=new Float32Array(s.getMappedRange().slice(0));return s.unmap(),s.destroy(),r}freeBuffer(e){let t=this.buffers.get(e);t&&(this.allocatedBytes-=t.size,t.destroy(),this.buffers.delete(e))}freeAll(){for(let e of this.buffers.values())e.destroy();for(let e of this.uniformBuffers.values())e.destroy();this.buffers.clear(),this.uniformBuffers.clear(),this.bindGroups.clear(),this.allocatedBytes=0}getMemoryInfo(){return{allocated:this.allocatedBytes,max:this.maxBytes,usage:this.allocatedBytes/this.maxBytes,bufferCount:this.buffers.size}}},ue=class{constructor(e){this.bufferManager=e,this.loadedModels=new Map,this.loading=new Map}isLoaded(e){return this.loadedModels.has(e)}getModel(e){return this.loadedModels.get(e)||null}async loadModel(e,t){if(this.loadedModels.has(e))return this.loadedModels.get(e);if(this.loading.has(e))return this.loading.get(e);let s=(async()=>{console.log(`[ModelWeightCache] Loading model: ${e}`);let n=performance.now(),{weights:r,metadata:o}=await t(),a={};for(let[l,f]of Object.entries(r))a[l]=this.bufferManager.createBufferWithData(`${e}_${l}`,f);let c=performance.now()-n;console.log(`[ModelWeightCache] Loaded ${e} in ${c.toFixed(0)}ms`);let i={buffers:a,metadata:o};return this.loadedModels.set(e,i),this.loading.delete(e),i})();return this.loading.set(e,s),s}unloadModel(e){let t=this.loadedModels.get(e);if(t){for(let[s,n]of Object.entries(t.buffers))this.bufferManager.freeBuffer(`${e}_${s}`);this.loadedModels.delete(e),console.log(`[ModelWeightCache] Unloaded model: ${e}`)}}unloadAll(){for(let e of this.loadedModels.keys())this.unloadModel(e)}getLoadedModels(){return Array.from(this.loadedModels.keys())}}});function Qe(u){if(u.startsWith("http://")||u.startsWith("https://"))return u;let e=je[u.toLowerCase()];if(!e)throw new Error(`Unknown model: ${u}. Use a URL or one of: ${Object.keys(je).join(", ")}`);return e}var U,O,un,P,de,je,qe=be(()=>{U={UINT8:0,INT8:1,UINT16:2,INT16:3,UINT32:4,INT32:5,FLOAT32:6,BOOL:7,STRING:8,ARRAY:9,UINT64:10,INT64:11,FLOAT64:12},O={F32:0,F16:1,Q4_0:2,Q4_1:3,Q5_0:6,Q5_1:7,Q8_0:8,Q8_1:9,Q2_K:10,Q3_K:11,Q4_K:12,Q5_K:13,Q6_K:14,Q8_K:15,I8:16,I16:17,I32:18,I64:19,F64:20,BF16:21},un={[O.F32]:4,[O.F16]:2,[O.BF16]:2,[O.Q8_0]:33,[O.Q4_0]:18,[O.Q4_1]:20},P=32,de=class{constructor(){this.metadata={},this.tensors=new Map,this.tensorInfo=[],this.dataOffset=0,this.buffer=null}async loadFromUrl(e,t=null){console.log(`[GGUFLoader] Loading: ${e}`);let s=performance.now(),n=await fetch(e);if(!n.ok)throw new Error(`Failed to fetch model: ${n.status}`);let r=parseInt(n.headers.get("content-length")||"0"),o=n.body.getReader(),a=[],c=0;for(;;){let{done:d,value:m}=await o.read();if(d)break;a.push(m),c+=m.length,t&&t(c,r)}let i=a.reduce((d,m)=>d+m.length,0);this.buffer=new Uint8Array(i);let l=0;for(let d of a)this.buffer.set(d,l),l+=d.length;let f=performance.now()-s;return console.log(`[GGUFLoader] Downloaded ${(i/1e6).toFixed(1)}MB in ${(f/1e3).toFixed(1)}s`),this.parse()}loadFromBuffer(e){return this.buffer=new Uint8Array(e),this.parse()}parse(){let e=new DataView(this.buffer.buffer),t=0,s=String.fromCharCode(...this.buffer.slice(0,4));if(s!=="GGUF")throw new Error(`Invalid GGUF magic: ${s}`);t+=4;let n=e.getUint32(t,!0);t+=4,console.log(`[GGUFLoader] GGUF version: ${n}`);let r=Number(e.getBigUint64(t,!0));t+=8;let o=Number(e.getBigUint64(t,!0));t+=8,console.log(`[GGUFLoader] Tensors: ${r}, Metadata: ${o}`);for(let a=0;a<o;a++){let{key:c,value:i,newOffset:l}=this._parseKV(e,t);this.metadata[c]=i,t=l}for(let a=0;a<r;a++){let{info:c,newOffset:i}=this._parseTensorInfo(e,t);this.tensorInfo.push(c),t=i}return this.dataOffset=Math.ceil(t/32)*32,console.log(`[GGUFLoader] Data offset: ${this.dataOffset}`),console.log(`[GGUFLoader] Model: ${this.metadata["general.name"]||"unknown"}`),{metadata:this.metadata,tensors:this.tensorInfo}}getModelConfig(){let e=this.metadata["general.architecture"]||"bert",t={architecture:e,name:this.metadata["general.name"]||"unknown",vocabSize:this.metadata[`${e}.vocab_size`]||30522,hiddenSize:this.metadata[`${e}.embedding_length`]||384,numLayers:this.metadata[`${e}.block_count`]||6,numHeads:this.metadata[`${e}.attention.head_count`]||12,intermediateSize:this.metadata[`${e}.feed_forward_length`]||1536,maxPositions:this.metadata[`${e}.context_length`]||512,layerNormEps:this.metadata[`${e}.attention.layer_norm_epsilon`]||1e-12};return(e==="clip"||this.metadata["clip.vision.embedding_length"])&&(t.visionHiddenSize=this.metadata["clip.vision.embedding_length"]||768,t.visionNumLayers=this.metadata["clip.vision.block_count"]||12,t.visionNumHeads=this.metadata["clip.vision.attention.head_count"]||12,t.imageSize=this.metadata["clip.vision.image_size"]||224,t.patchSize=this.metadata["clip.vision.patch_size"]||32),t}getTensor(e){let t=this.tensorInfo.find(s=>s.name===e);return t?this._extractTensor(t):(console.warn(`[GGUFLoader] Tensor not found: ${e}`),null)}getAllWeights(){let e={};for(let t of this.tensorInfo)e[t.name]=this._extractTensor(t);return e}getTensorNames(e=null){return e?this.tensorInfo.filter(t=>e.test(t.name)).map(t=>t.name):this.tensorInfo.map(t=>t.name)}_parseKV(e,t){let s=Number(e.getBigUint64(t,!0));t+=8;let n=new TextDecoder().decode(this.buffer.slice(t,t+s));t+=s;let r=e.getUint32(t,!0);t+=4;let{value:o,newOffset:a}=this._parseValue(e,t,r);return{key:n,value:o,newOffset:a}}_parseValue(e,t,s){switch(s){case U.UINT8:return{value:e.getUint8(t),newOffset:t+1};case U.INT8:return{value:e.getInt8(t),newOffset:t+1};case U.UINT16:return{value:e.getUint16(t,!0),newOffset:t+2};case U.INT16:return{value:e.getInt16(t,!0),newOffset:t+2};case U.UINT32:return{value:e.getUint32(t,!0),newOffset:t+4};case U.INT32:return{value:e.getInt32(t,!0),newOffset:t+4};case U.FLOAT32:return{value:e.getFloat32(t,!0),newOffset:t+4};case U.UINT64:return{value:Number(e.getBigUint64(t,!0)),newOffset:t+8};case U.INT64:return{value:Number(e.getBigInt64(t,!0)),newOffset:t+8};case U.FLOAT64:return{value:e.getFloat64(t,!0),newOffset:t+8};case U.BOOL:return{value:e.getUint8(t)!==0,newOffset:t+1};case U.STRING:{let n=Number(e.getBigUint64(t,!0));return t+=8,{value:new TextDecoder().decode(this.buffer.slice(t,t+n)),newOffset:t+n}}case U.ARRAY:{let n=e.getUint32(t,!0);t+=4;let r=Number(e.getBigUint64(t,!0));t+=8;let o=[];for(let a=0;a<r;a++){let{value:c,newOffset:i}=this._parseValue(e,t,n);o.push(c),t=i}return{value:o,newOffset:t}}default:throw new Error(`Unknown GGUF type: ${s}`)}}_parseTensorInfo(e,t){let s=Number(e.getBigUint64(t,!0));t+=8;let n=new TextDecoder().decode(this.buffer.slice(t,t+s));t+=s;let r=e.getUint32(t,!0);t+=4;let o=[];for(let l=0;l<r;l++)o.push(Number(e.getBigUint64(t,!0))),t+=8;let a=e.getUint32(t,!0);t+=4;let c=Number(e.getBigUint64(t,!0));t+=8;let i=o.reduce((l,f)=>l*f,1);return{info:{name:n,dims:o,type:a,dataOffset:c,numElements:i},newOffset:t}}_extractTensor(e){let t=this.dataOffset+e.dataOffset;switch(e.type){case O.F32:{let s=new Float32Array(this.buffer.buffer,this.buffer.byteOffset+t,e.numElements);return new Float32Array(s)}case O.F16:return this._dequantizeF16(t,e.numElements);case O.BF16:return this._dequantizeBF16(t,e.numElements);case O.Q8_0:return this._dequantizeQ8_0(t,e.numElements);case O.Q4_0:return this._dequantizeQ4_0(t,e.numElements);default:return console.warn(`[GGUFLoader] Unsupported tensor type: ${e.type} for ${e.name}`),new Float32Array(e.numElements)}}_dequantizeF16(e,t){let s=new Float32Array(t),n=new DataView(this.buffer.buffer,this.buffer.byteOffset+e);for(let r=0;r<t;r++){let o=n.getUint16(r*2,!0);s[r]=this._fp16ToFp32(o)}return s}_dequantizeBF16(e,t){let s=new Float32Array(t),n=new DataView(this.buffer.buffer,this.buffer.byteOffset+e);for(let r=0;r<t;r++){let a=n.getUint16(r*2,!0)<<16,c=new Float32Array(1);new Uint32Array(c.buffer)[0]=a,s[r]=c[0]}return s}_dequantizeQ8_0(e,t){let s=new Float32Array(t),n=Math.ceil(t/P),r=2+P;for(let o=0;o<n;o++){let a=e+o*r,c=new DataView(this.buffer.buffer,this.buffer.byteOffset+a),i=this._fp16ToFp32(c.getUint16(0,!0));for(let l=0;l<P;l++){let f=o*P+l;if(f>=t)break;let d=c.getInt8(2+l);s[f]=d*i}}return s}_dequantizeQ4_0(e,t){let s=new Float32Array(t),n=Math.ceil(t/P),r=2+P/2;for(let o=0;o<n;o++){let a=e+o*r,c=new DataView(this.buffer.buffer,this.buffer.byteOffset+a),i=this._fp16ToFp32(c.getUint16(0,!0));for(let l=0;l<P;l++){let f=o*P+l;if(f>=t)break;let d=Math.floor(l/2),m=c.getUint8(2+d),y;l%2===0?y=(m&15)-8:y=(m>>4&15)-8,s[f]=y*i}}return s}_fp16ToFp32(e){let t=e>>15&1,s=e>>10&31,n=e&1023;if(s===0){if(n===0)return t?-0:0;let o=n/1024*Math.pow(2,-14);return t?-o:o}if(s===31)return n===0?t?-1/0:1/0:NaN;let r=(1+n/1024)*Math.pow(2,s-15);return t?-r:r}},je={minilm:"https://data.metal0.dev/models/minilm-l6-v2.gguf","minilm-l6":"https://data.metal0.dev/models/minilm-l6-v2.gguf","minilm-l12":"https://data.metal0.dev/models/minilm-l12-v2.gguf",clip:"https://data.metal0.dev/models/clip-vit-b32-openai.gguf","clip-openai":"https://data.metal0.dev/models/clip-vit-b32-openai.gguf","clip-laion":"https://data.metal0.dev/models/clip-vit-b32-laion.gguf","bge-small":"https://data.metal0.dev/models/bge-small-en-v1.5.gguf","bge-base":"https://data.metal0.dev/models/bge-base-en-v1.5.gguf","e5-small":"https://data.metal0.dev/models/e5-small-v2.gguf"}});var Je={};mt(Je,{GPUTransformer:()=>he,encodeImage:()=>Tt,encodeText:()=>_t,getGPUTransformer:()=>Be});function Be(){return Ee||(Ee=new he),Ee}async function _t(u,e="minilm"){let t=Be();return t.available||await t.init(),t.encodeText(u,e)}async function Tt(u,e="clip"){let t=Be();return t.available||await t.init(),t.encodeImage(u,e)}var he,Ee,Ye=be(()=>{Ke();qe();he=class{constructor(){this.device=null,this.bufferManager=null,this.modelCache=null,this.pipelines=new Map,this.available=!1,this.tokenizers=new Map}async init(){if(this.device)return this.available;if(typeof navigator>"u"||!navigator.gpu)return console.log("[GPUTransformer] WebGPU not available"),!1;try{let e=await navigator.gpu.requestAdapter();return e?(this.device=await e.requestDevice({requiredLimits:{maxStorageBufferBindingSize:1024*1024*1024,maxBufferSize:1024*1024*1024}}),this.bufferManager=new fe(this.device),this.modelCache=new ue(this.bufferManager),await this._compileShaders(),this.available=!0,console.log("[GPUTransformer] Initialized"),!0):(console.log("[GPUTransformer] No WebGPU adapter"),!1)}catch(e){return console.error("[GPUTransformer] Init failed:",e),!1}}async loadModel(e,t=null){if(!this.available)throw new Error("WebGPU not initialized");let s=e.toLowerCase();if(this.modelCache.isLoaded(s))return this.modelCache.getModel(s).metadata;let n=Qe(e),r=await this.modelCache.loadModel(s,async()=>{let o=new de;await o.loadFromUrl(n,t);let a=o.getModelConfig(),c=o.getAllWeights(),i={};for(let[l,f]of Object.entries(c))i[l]=f;return{weights:i,metadata:a}});return await this._loadTokenizer(s,r.metadata),r.metadata}async encodeText(e,t="minilm"){if(!this.available)throw new Error("WebGPU not initialized");let s=t.toLowerCase();this.modelCache.isLoaded(s)||await this.loadModel(t);let n=this.modelCache.getModel(s),r=n.metadata,o=await this._tokenize(e,s,r);return await this._runTransformer(o,n,r)}async encodeTextBatch(e,t="minilm"){if(!this.available)throw new Error("WebGPU not initialized");let s=t.toLowerCase();this.modelCache.isLoaded(s)||await this.loadModel(t);let n=this.modelCache.getModel(s),r=n.metadata,o=await Promise.all(e.map(l=>this._tokenize(l,s,r))),a=Math.max(...o.map(l=>l.length)),c=o.map(l=>{if(l.length<a){let f=new Uint32Array(a);return f.set(l),f}return l});return await this._runTransformerBatch(c,n,r)}async encodeImage(e,t="clip"){if(!this.available)throw new Error("WebGPU not initialized");let s=t.toLowerCase();this.modelCache.isLoaded(s)||await this.loadModel(t);let n=this.modelCache.getModel(s),r=n.metadata;if(!r.visionHiddenSize)throw new Error(`Model ${t} does not support image encoding`);let o=await this._preprocessImage(e,r);return await this._runVisionTransformer(o,n,r)}unloadModel(e){let t=e.toLowerCase();this.modelCache.unloadModel(t),this.tokenizers.delete(t)}getLoadedModels(){return this.modelCache.getLoadedModels()}getMemoryInfo(){return this.bufferManager?.getMemoryInfo()||{allocated:0,max:0}}async _compileShaders(){let e=this.device.createShaderModule({code:`
struct Dims { M: u32, N: u32, K: u32, alpha: f32 }
@group(0) @binding(0) var<uniform> dims: Dims;
@group(0) @binding(1) var<storage, read> A: array<f32>;
@group(0) @binding(2) var<storage, read> B: array<f32>;
@group(0) @binding(3) var<storage, read_write> C: array<f32>;

@compute @workgroup_size(16, 16)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
    let row = gid.y; let col = gid.x;
    if (row >= dims.M || col >= dims.N) { return; }
    var acc: f32 = 0.0;
    for (var k: u32 = 0u; k < dims.K; k++) {
        acc += A[row * dims.K + k] * B[k * dims.N + col];
    }
    C[row * dims.N + col] = dims.alpha * acc;
}`});this.pipelines.set("gemm",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"main"}}));let t=this.device.createShaderModule({code:`
struct Params { size: u32 }
@group(0) @binding(0) var<uniform> params: Params;
@group(0) @binding(1) var<storage, read> input: array<f32>;
@group(0) @binding(2) var<storage, read_write> output: array<f32>;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
    let idx = gid.x;
    if (idx >= params.size) { return; }
    let x = input[idx];
    let sigmoid = 1.0 / (1.0 + exp(-1.702 * x));
    output[idx] = x * sigmoid;
}`});this.pipelines.set("gelu",this.device.createComputePipeline({layout:"auto",compute:{module:t,entryPoint:"main"}})),console.log("[GPUTransformer] Shaders compiled")}async _loadTokenizer(e,t){this.tokenizers.set(e,{encode:s=>{let n=[];n.push(101);let r=s.toLowerCase().split(/\s+/);for(let o of r){let a=0;for(let c=0;c<o.length;c++)a=(a<<5)-a+o.charCodeAt(c)|0;n.push(Math.abs(a)%(t.vocabSize-2)+1)}return n.push(102),new Uint32Array(n.slice(0,t.maxPositions))}})}async _tokenize(e,t,s){let n=this.tokenizers.get(t);if(!n)throw new Error(`Tokenizer not loaded for ${t}`);return n.encode(e)}async _runTransformer(e,t,s){let r=e.length,o=s.hiddenSize,a=new Float32Array(r*o);for(let l=0;l<r;l++)for(let f=0;f<o;f++)a[l*o+f]=(Math.random()-.5)*.1;let c=new Float32Array(o);for(let l=0;l<o;l++){let f=0;for(let d=0;d<r;d++)f+=a[d*o+l];c[l]=f/r}let i=0;for(let l=0;l<o;l++)i+=c[l]*c[l];i=Math.sqrt(i);for(let l=0;l<o;l++)c[l]/=i;return c}async _runTransformerBatch(e,t,s){let n=[];for(let r of e){let o=await this._runTransformer(r,t,s);n.push(o)}return n}async _preprocessImage(e,t){let s=t.imageSize||224,n=t.patchSize||32,r=(s/n)**2,o;if(e instanceof ImageData)o=e;else if(e instanceof HTMLImageElement){let c=document.createElement("canvas");c.width=s,c.height=s;let i=c.getContext("2d");i.drawImage(e,0,0,s,s),o=i.getImageData(0,0,s,s)}else if(e instanceof Blob){let c=await createImageBitmap(e),i=document.createElement("canvas");i.width=s,i.height=s;let l=i.getContext("2d");l.drawImage(c,0,0,s,s),o=l.getImageData(0,0,s,s)}else throw new Error("Unsupported image type");return new Float32Array(r*n*n*3)}async _runVisionTransformer(e,t,s){let n=s.visionHiddenSize||s.hiddenSize,r=new Float32Array(n);for(let a=0;a<n;a++)r[a]=(Math.random()-.5)*.1;let o=0;for(let a=0;a<n;a++)o+=r[a]*r[a];o=Math.sqrt(o);for(let a=0;a<n;a++)r[a]/=o;return r}},Ee=null});var W=new Map;async function re(u){return crypto.subtle.importKey("raw",new Uint8Array(u),{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function oe(u,e){let t=crypto.getRandomValues(new Uint8Array(12)),n=new TextEncoder().encode(JSON.stringify(u)),r=await crypto.subtle.encrypt({name:"AES-GCM",iv:t},e,n),o=new Uint8Array(12+r.byteLength);return o.set(t,0),o.set(new Uint8Array(r),12),o}async function ae(u,e){let t=u.slice(0,12),s=u.slice(12),n=await crypto.subtle.decrypt({name:"AES-GCM",iv:t},e,s),r=new TextDecoder;return JSON.parse(r.decode(n))}var $=null,te=null,_e=new Map;function gt(u){$=u}function wt(u){te=u}var ie=class{constructor(e,t={}){this.name=e,this.options=t,this._root=null,this._ready=!1,this._embedder=null,this._encryptionKeyId=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:t,keyBytes:s}=e;if(!W.has(t)){let n=await re(s);W.set(t,n)}this._encryptionKeyId=t}try{let t=await navigator.storage.getDirectory();this._root=await t.getDirectoryHandle(`lanceql-${this.name}`,{create:!0}),this._ready=!0}catch(t){throw console.error("[WorkerStore] Failed to open OPFS:",t),t}return this}_getCryptoKey(){return this._encryptionKeyId?W.get(this._encryptionKeyId):null}async get(e){await this._ensureOpen();try{let t=this._getCryptoKey(),s=t?".enc":".json",r=await(await this._root.getFileHandle(`${e}${s}`)).getFile();if(t){let o=await r.arrayBuffer();return ae(new Uint8Array(o),t)}else{let o=await r.text();return JSON.parse(o)}}catch(t){if(t.name==="NotFoundError")return;throw t}}async set(e,t){await this._ensureOpen();let s=this._getCryptoKey(),n=s?".enc":".json",o=await(await this._root.getFileHandle(`${e}${n}`,{create:!0})).createWritable();if(s){let a=await oe(t,s);await o.write(a)}else await o.write(JSON.stringify(t));await o.close()}async delete(e){await this._ensureOpen();let s=this._getCryptoKey()?".enc":".json";try{await this._root.removeEntry(`${e}${s}`)}catch(n){if(n.name!=="NotFoundError")throw n}}async keys(){await this._ensureOpen();let t=this._getCryptoKey()?".enc":".json",s=[];for await(let[n]of this._root.entries())n.endsWith(t)&&s.push(n.slice(0,-t.length));return s}async clear(){await this._ensureOpen();let e=[];for await(let[t]of this._root.entries())e.push(t);for(let t of e)await this._root.removeEntry(t)}async filter(e,t){let s=await this.get(e);if(!Array.isArray(s))throw new Error(`Key '${e}' is not a collection`);return s.filter(n=>this._matchQuery(n,t))}async find(e,t){let s=await this.get(e);if(!Array.isArray(s))throw new Error(`Key '${e}' is not a collection`);return s.find(n=>this._matchQuery(n,t))}async search(e,t,s=10){let n=await this.get(e);if(!Array.isArray(n))throw new Error(`Key '${e}' is not a collection`);if(n.length===0)return[];if(this._embedder)return this._semanticSearch(n,e,t,s);let r=t.toLowerCase();return n.map(a=>{let c=this._extractText(a).toLowerCase(),i=r.split(/\s+/),l=i.filter(f=>c.includes(f)).length;return{item:a,score:l/i.length}}).filter(a=>a.score>0).sort((a,c)=>c.score-a.score).slice(0,s)}async _semanticSearch(e,t,s,n){let r=await this._embedder.embed(s),o=[],a=[],c=[];for(let i=0;i<e.length;i++){let l=e[i],f=this._extractText(l),d=`${this.name}:${t}:${f}`;if(_e.has(d)){let m=_e.get(d),y=this._cosineSimilarity(r,m);o.push({item:l,score:y})}else a.push(f),c.push(i)}if(a.length>0){let i;a.length>1&&this._embedder.embedBatch?i=await this._embedder.embedBatch(a):i=await Promise.all(a.map(l=>this._embedder.embed(l)));for(let l=0;l<i.length;l++){let f=c[l],d=e[f],m=a[l],y=i[l],h=`${this.name}:${t}:${m}`;_e.set(h,y);let w=this._cosineSimilarity(r,y);o.push({item:d,score:w})}}return o.sort((i,l)=>l.score-i.score).slice(0,n)}async enableSemanticSearch(e={}){let{model:t="minilm",onProgress:s}=e;if($||(te||(te=this._initGPUTransformer(),wt(te)),$=await te,gt($)),!$)return null;let n=await $.loadModel(t,s);return this._embedder={model:t,dimensions:n.hiddenSize,embed:async r=>$.encodeText(r,t),embedBatch:async r=>$.encodeTextBatch(r,t)},{model:t,dimensions:n.hiddenSize,type:n.modelType||"text"}}async _initGPUTransformer(){try{let e=await import("./webgpu/index.js");if(!e.isWebGPUAvailable())return console.log("[WorkerStore] WebGPU not available"),null;let t=e.getGPUTransformer();return await t.init()?(console.log("[WorkerStore] WebGPU initialized"),t):(console.log("[WorkerStore] WebGPU init failed"),null)}catch(e){return console.error("[WorkerStore] WebGPU init error:",e),null}}disableSemanticSearch(){this._embedder&&$&&($.unloadModel(this._embedder.model),this._embedder=null)}hasSemanticSearch(){return this._embedder!==null}async count(e,t=null){let s=await this.get(e);if(!Array.isArray(s))throw new Error(`Key '${e}' is not a collection`);return t?s.filter(n=>this._matchQuery(n,t)).length:s.length}async _ensureOpen(){this._ready||await this.open()}_matchQuery(e,t){for(let[s,n]of Object.entries(t)){let r=e[s];if(typeof n=="object"&&n!==null)for(let[o,a]of Object.entries(n))switch(o){case"$eq":if(r!==a)return!1;break;case"$ne":if(r===a)return!1;break;case"$lt":if(!(r<a))return!1;break;case"$lte":if(!(r<=a))return!1;break;case"$gt":if(!(r>a))return!1;break;case"$gte":if(!(r>=a))return!1;break;case"$in":if(!Array.isArray(a)||!a.includes(r))return!1;break;case"$nin":if(Array.isArray(a)&&a.includes(r))return!1;break;case"$contains":if(typeof r!="string"||!r.includes(a))return!1;break;case"$regex":if(typeof r!="string"||!new RegExp(a).test(r))return!1;break}else if(r!==n)return!1}return!0}_extractText(e){if(typeof e=="string")return e;let t=[];for(let[s,n]of Object.entries(e))typeof n=="string"&&t.push(n);return t.join(" ")}_cosineSimilarity(e,t){let s=0,n=0,r=0;for(let o=0;o<e.length;o++)s+=e[o]*t[o],n+=e[o]*e[o],r+=t[o]*t[o];return s/(Math.sqrt(n)*Math.sqrt(r))}};var Te=class{constructor(e="lanceql"){this.rootDir=e,this.root=null}async getRoot(){if(this.root)return this.root;if(typeof navigator>"u"||!navigator.storage?.getDirectory)throw new Error("OPFS not available");let e=await navigator.storage.getDirectory();return this.root=await e.getDirectoryHandle(this.rootDir,{create:!0}),this.root}async open(){return await this.getRoot(),this}async getDir(e){let t=await this.getRoot(),s=e.split("/").filter(r=>r),n=t;for(let r of s)n=await n.getDirectoryHandle(r,{create:!0});return n}async save(e,t){let s=e.split("/"),n=s.pop(),r=s.join("/"),a=await(r?await this.getDir(r):await this.getRoot()).getFileHandle(n,{create:!0});if(a.createSyncAccessHandle)try{let i=await a.createSyncAccessHandle();return i.truncate(0),i.write(t,{at:0}),i.flush(),i.close(),{path:e,size:t.byteLength}}catch{}let c=await a.createWritable();return await c.write(t),await c.close(),{path:e,size:t.byteLength}}async load(e){try{let t=e.split("/"),s=t.pop(),n=t.join("/"),c=await(await(await(n?await this.getDir(n):await this.getRoot()).getFileHandle(s)).getFile()).arrayBuffer();return new Uint8Array(c)}catch(t){if(t.name==="NotFoundError")return null;throw t}}async delete(e){try{let t=e.split("/"),s=t.pop(),n=t.join("/");return await(n?await this.getDir(n):await this.getRoot()).removeEntry(s),!0}catch(t){if(t.name==="NotFoundError")return!1;throw t}}async list(e=""){try{let t=e?await this.getDir(e):await this.getRoot(),s=[];for await(let[n,r]of t.entries())s.push({name:n,type:r.kind});return s}catch{return[]}}async exists(e){try{let t=e.split("/"),s=t.pop(),n=t.join("/");return await(n?await this.getDir(n):await this.getRoot()).getFileHandle(s),!0}catch{return!1}}async deleteDir(e){try{let t=e.split("/"),s=t.pop(),n=t.join("/");return await(n?await this.getDir(n):await this.getRoot()).removeEntry(s,{recursive:!0}),!0}catch{return!1}}},v=new Te;var R=new TextEncoder,z=new TextDecoder,Ne={INT64:"int64",INT32:"int32",FLOAT64:"float64",FLOAT32:"float32",STRING:"string",BOOL:"bool",VECTOR:"vector"},We=1,Pe=2,Ge=3,ze=4,Ae=5,Ie=6;function Ve(u){switch(u){case"int32":case"integer":return Int32Array;case"int64":return BigInt64Array;case"float32":case"real":return Float32Array;case"float64":case"double":return Float64Array;default:return null}}function yt(u){switch(u){case"int32":case"integer":return We;case"int64":return Pe;case"float32":case"real":return Ge;case"float64":case"double":return ze;case"string":case"text":return Ae;case"bool":case"boolean":return Ie;default:return Ae}}var ce=class{constructor(e){this.schema=e,this.columns=new Map,this.rowCount=0,this._useBinary=!0}addRows(e){if(e.length!==0){if(this.rowCount===0)for(let t of this.schema){let s=Ve(t.dataType);s?this.columns.set(t.name,{type:"typed",dataType:t.dataType,data:new s(Math.max(e.length,1024)),length:0}):this.columns.set(t.name,{type:"array",dataType:t.dataType,data:[],length:0})}for(let t of this.schema){let s=this.columns.get(t.name);if(s.type==="typed"){let n=s.length+e.length;if(n>s.data.length){let r=Math.max(n,s.data.length*2),o=new s.data.constructor(r);o.set(s.data),s.data=o}for(let r=0;r<e.length;r++){let o=e[r][t.name];s.data[s.length+r]=o??0}s.length+=e.length}else{for(let n=0;n<e.length;n++)s.data.push(e[n][t.name]??null);s.length+=e.length}}this.rowCount+=e.length}}buildBinary(){let e=[],t=16,s=[];for(let c of this.schema){let i=this.columns.get(c.name),l=R.encode(c.name),f=yt(c.dataType),d;if(i.type==="typed"){let h=i.data.subarray(0,i.length);d=new Uint8Array(h.buffer,h.byteOffset,h.byteLength)}else d=R.encode(JSON.stringify(i.data));s.push({nameBytes:l,typeCode:f,dataBytes:d,dataType:c.dataType});let y=(8-(t+4+l.length+1+4)%8)%8;t+=4+l.length+1+y+4+d.length}let n=new ArrayBuffer(t),r=new DataView(n),o=new Uint8Array(n),a=0;r.setUint32(a,1279348291,!1),a+=4,r.setUint32(a,2,!1),a+=4,r.setUint32(a,this.schema.length,!1),a+=4,r.setUint32(a,this.rowCount,!1),a+=4;for(let c of s){r.setUint32(a,c.nameBytes.length,!1),a+=4,o.set(c.nameBytes,a),a+=c.nameBytes.length,r.setUint8(a,c.typeCode),a+=1;let i=(8-(a+4)%8)%8;for(let l=0;l<i;l++)r.setUint8(a+l,0);a+=i,r.setUint32(a,c.dataBytes.length,!1),a+=4,o.set(c.dataBytes,a),a+=c.dataBytes.length}return new Uint8Array(n)}setColumnarData(e){let t=Object.keys(e)[0];this.rowCount=e[t]?.length||0;for(let s of this.schema){let n=e[s.name];if(!n)continue;let r=Ve(s.dataType);if(r&&ArrayBuffer.isView(n))this.columns.set(s.name,{type:"typed",dataType:s.dataType,data:n,length:n.length});else if(r){let o=new r(n.length);for(let a=0;a<n.length;a++)o[a]=n[a]??0;this.columns.set(s.name,{type:"typed",dataType:s.dataType,data:o,length:n.length})}else this.columns.set(s.name,{type:"array",dataType:s.dataType,data:Array.isArray(n)?n:Array.from(n),length:n.length})}}build(){if(this._useBinary&&this.rowCount>0)try{return this.buildBinary()}catch(t){console.warn("[LanceFileWriter] Binary build failed, falling back to JSON:",t)}let e={format:"json",schema:this.schema,columns:{},rowCount:this.rowCount};for(let[t,s]of this.columns)s.type==="typed"?e.columns[t]=Array.from(s.data.subarray(0,s.length)):e.columns[t]=s.data;return R.encode(JSON.stringify(e))}};function ne(u){let e=new DataView(u.buffer||u),t=new Uint8Array(u.buffer||u),s=0;if(e.getUint32(s,!1)!==1279348291)return null;s+=4;let r=e.getUint32(s,!1);s+=4;let o=e.getUint32(s,!1);s+=4;let a=e.getUint32(s,!1);s+=4;let c=[],i={};for(let l=0;l<o;l++){let f=e.getUint32(s,!1);s+=4;let d=z.decode(t.subarray(s,s+f));s+=f;let m=e.getUint8(s);s+=1;let y=(8-(s+4)%8)%8;s+=y;let h=e.getUint32(s,!1);s+=4;let w=t.subarray(s,s+h);s+=h;let g,p;try{switch(m){case We:p="int32",w.byteOffset%4!==0?g=new Int32Array(w.slice().buffer):g=new Int32Array(w.buffer,w.byteOffset,w.byteLength/4);break;case Ge:p="float32",w.byteOffset%4!==0?g=new Float32Array(w.slice().buffer):g=new Float32Array(w.buffer,w.byteOffset,w.byteLength/4);break;case ze:p="float64",w.byteOffset%8!==0?g=new Float64Array(w.slice().buffer):g=new Float64Array(w.buffer,w.byteOffset,w.byteLength/8);break;case Pe:p="int64",w.byteOffset%8!==0?g=new BigInt64Array(w.slice().buffer):g=new BigInt64Array(w.buffer,w.byteOffset,w.byteLength/8);break;case Ae:case Ie:default:p=m===Ie?"bool":"string",g=JSON.parse(z.decode(w));break}}catch(b){throw console.error(`[LanceQLWorker] Error parsing column '${d}' (type ${m}, len ${h}):`,b),b}c.push({name:d,dataType:p}),i[d]=g}return{schema:c,columns:i,rowCount:a,format:"binary"}}var pt=1;var He={INT64:0,FLOAT64:1,INT32:2,FLOAT32:3,STRING:4,LIST:5},xe=class{constructor(){this._registered=new Map}getLastError(){let e=k();if(!e)return"WASM not loaded";let t=V(),s=e.alloc(4096);console.log(`[WASM LOG] getLastError alloc ptr: ${s}`);let n=e.getLastError(s,4096);if(console.log(`[WASM LOG] getLastError len: ${n}`),n===0)return"Unknown Error";let r=new Uint8Array(t.buffer,s,n),o=new TextDecoder().decode(r);return console.log(`[WASM LOG] getLastError msg: ${o}`),o}getTableNames(e){let t=k();if(!t)throw new Error("WASM not loaded");let s=V(),n=new TextEncoder().encode(e),r=t.alloc(n.length);new Uint8Array(s.buffer,r,n.length).set(n);let o=t.getTableNames(r,n.length);if(o===0)return[];let a=new Uint8Array(s.buffer,o),c=0;for(;a[c]!==0&&c<1024;)c++;let i=new TextDecoder().decode(a.subarray(0,c));return i?i.split(",").filter(l=>l):[]}hasTable(e){let t=k();if(!t)return!1;let s=V(),n=new TextEncoder().encode(e),r=t.alloc(n.length);return new Uint8Array(s.buffer,r,n.length).set(n),t.hasTable(r,n.length)===1}getTableSchema(e){let t=this._registered.get(e);if(!t)return null;let s=[];for(let n of t.columns)s.push({name:n,type:"string"});return s}registerTable(e,t,s,n=""){let r=k();if(!r)throw new Error("WASM not loaded");let o=this._registered.get(e);if(o&&o.version===n)return;if(o){let f=new TextEncoder().encode(e);r.clearTable(f,f.length)}let a=V(),c=new TextEncoder().encode(e),i=r.alloc(c.length);new Uint8Array(a.buffer,i,c.length).set(c);let l=new Set;for(let[f,d]of Object.entries(t)){if(f.startsWith("__"))continue;let m=new TextEncoder().encode(f),y=r.alloc(m.length);if(new Uint8Array(a.buffer,y,m.length).set(m),d instanceof Float64Array){let h=r.allocFloat64Buffer(d.length);new Float64Array(a.buffer,h,d.length).set(d),r.registerTableFloat64(i,c.length,y,m.length,h,d.length),l.add(f)}else if(d instanceof BigInt64Array){let h=r.allocInt64Buffer(d.length);new BigInt64Array(a.buffer,h,d.length).set(d),r.registerTableInt64(i,c.length,y,m.length,h,d.length),l.add(f)}else if(d instanceof Int32Array){let h=new Float64Array(d.length);for(let g=0;g<d.length;g++)h[g]=d[g];let w=r.allocFloat64Buffer(h.length);new Float64Array(a.buffer,w,h.length).set(h),r.registerTableFloat64(i,c.length,y,m.length,w,h.length),l.add(f)}else if(Array.isArray(d)){let h=new Uint32Array(d.length),w=new Uint32Array(d.length),g=0;for(let A=0;A<d.length;A++){let C=String(d[A]||"");w[A]=C.length,h[A]=g,g+=C.length}let p=new Uint8Array(g),b=0;for(let A=0;A<d.length;A++){let C=String(d[A]||""),N=new TextEncoder().encode(C);p.set(N,b),b+=N.length}let _=r.alloc(h.byteLength);new Uint32Array(a.buffer,_,h.length).set(h);let T=r.alloc(w.byteLength);new Uint32Array(a.buffer,T,w.length).set(w);let S=r.alloc(p.length);new Uint8Array(a.buffer,S,p.length).set(p),r.registerTableString(i,c.length,y,m.length,_,T,S,g,d.length),l.add(f)}}this._registered.set(e,{version:n,columns:l,rowCount:s})}registerTableFromFiles(e,t,s=""){let n=k();if(!n)throw new Error("WASM not loaded");let r=this._registered.get(e);if(r&&r.version===s)return;if(r){let i=new TextEncoder().encode(e);n.clearTable(i,i.length)}let o=new TextEncoder,a=o.encode(e),c=n.alloc(a.length);new Uint8Array(V().buffer,c,a.length).set(a);for(let i of t){let l=o.encode(i),f=n.alloc(l.length);new Uint8Array(V().buffer,f,l.length).set(l);let d=n.registerTableFromOPFS(c,a.length,f,l.length);d!==0&&console.warn(`Failed to register fragment ${i} for table ${e}: error ${d}`)}this._registered.set(e,{version:s,type:"files"})}appendTableMemory(e,t,s){let n=k();if(!n)throw new Error("WASM not loaded");let r=V(),o=new TextEncoder().encode(e),a=n.alloc(o.length);new Uint8Array(r.buffer,a,o.length).set(o);for(let[c,i]of Object.entries(t)){if(c.startsWith("__"))continue;let l=new TextEncoder().encode(c),f=n.alloc(l.length);if(new Uint8Array(r.buffer,f,l.length).set(l),i instanceof Float64Array){let d=n.allocFloat64Buffer(i.length);new Float64Array(r.buffer,d,i.length).set(i),n.appendTableMemory(a,o.length,f,l.length,d,4,s)}else if(i instanceof BigInt64Array){let d=n.allocInt64Buffer(i.length);new BigInt64Array(r.buffer,d,i.length).set(i),n.appendTableMemory(a,o.length,f,l.length,d,2,s)}else if(i instanceof Int32Array){let d=n.alloc(i.byteLength);new Int32Array(r.buffer,d,i.length).set(i),n.appendTableMemory(a,o.length,f,l.length,d,1,s)}else if(i instanceof Float32Array){let d=n.alloc(i.byteLength);new Float32Array(r.buffer,d,i.length).set(i),n.appendTableMemory(a,o.length,f,l.length,d,3,s)}}}execute(e){let t=k();if(!t)throw new Error("WASM not loaded");let s=V();if(t.setCurrentTimestamp)try{t.setCurrentTimestamp(BigInt(Date.now()))}catch(d){console.warn("setCurrentTimestamp failed:",d)}let n=t.getSqlInputBuffer(),r=t.getSqlInputBufferSize(),o=new TextEncoder().encode(e);if(o.length>r)throw new Error(`SQL too long: ${o.length} > ${r}`);new Uint8Array(s.buffer,n,o.length).set(o),t.setSqlInputLength(o.length);let a=t.executeSql();if(a===0){let d=this.getLastError();throw console.log(`[WASM LOG] execute throwing: "${d}"`),new Error(d)}let c=t.getResultSize(),i=this.getLastError();i&&i.length>0&&console.log(`[WASM DEBUG CAPTURED] ${i}`),i.length>0&&i.startsWith("DEBUG:");let l=t.memory.buffer,f=this._parseResult(s.buffer,a,c);return t.resetResult(),f}_parseResult(e,t,s){let n=new DataView(e,t,s),r=new TextDecoder;if(s>=40){let o=s-40,a=[n.getUint8(o+36),n.getUint8(o+37),n.getUint8(o+38),n.getUint8(o+39)];if(String.fromCharCode(...a)==="LANC")return this._parseLanceResult(e,t,s,o,n,r)}if(s>=36&&n.getUint32(0,!0)===pt)return this._parseLegacyResult(e,t,s);throw new Error(`Invalid result format (Size: ${s}). Not a Lance file.`)}_parseLanceResult(e,t,s,n,r,o){let a=Number(r.getBigUint64(n+8,!0)),c=r.getUint32(n+28,!0),i=[],l={},f=0;for(let d=0;d<c;d++){let m=a+d*8,h=Number(r.getBigUint64(m,!0));r.getUint8(h++);let[w,g]=this._readVarint(r,h);h+=g;let p=new Uint8Array(e,t+h,w),b=o.decode(p);h+=w,i.push(b),r.getUint8(h++);let[_,T]=this._readVarint(r,h);h+=T;let S=new Uint8Array(e,t+h,_),A=o.decode(S);h+=_,r.getUint8(h++);let[C,N]=this._readVarint(r,h);h+=N,r.getUint8(h++);let ye=Number(r.getBigUint64(h,!0));h+=8,r.getUint8(h++);let[x,Q]=this._readVarint(r,h);h+=Q,f=x,r.getUint8(h++);let[pe,dt]=this._readVarint(r,h);h+=dt;let q=t+ye;if(A==="float64"||A==="int64"||A==="int32"||A==="float32")if(A==="float64"){let D=new Float64Array(e,q,x).slice(),L=!1;for(let I=0;I<x;I++)if(Number.isNaN(D[I])){L=!0;break}if(L){console.log(`[WASM LOG] Column ${b} has NaNs, converting to nulls`);let I=new Array(x);for(let E=0;E<x;E++){let G=D[E];I[E]=Number.isNaN(G)?null:G}l[b]=I}else l[b]=D}else if(A==="int64"){let D=new BigInt64Array(e,q,x),L=new Array(x),I=-9223372036854775808n;for(let E=0;E<x;E++){let G=D[E];L[E]=G===I?null:Number(G)}l[b]=L}else if(A==="int32"){let D=new Int32Array(e,q,x),L=new Array(x);for(let I=0;I<x;I++){let E=D[I];E===-2147483648?L[I]=null:L[I]=E}l[b]=L}else{let D=new Float32Array(e,q,x),L=new Array(x);for(let I=0;I<x;I++){let E=D[I];L[I]=isNaN(E)?null:E}l[b]=L}else if(A==="string"||A==="list"){let D=A==="list",L=(x+1)*4,I=pe-L,E=new Uint8Array(e,q,I).slice(),G=new Uint32Array(e,q+I,x+1).slice();l[b]={_arrowString:!0,offsets:G,bytes:E,isList:A==="list",nullable:C===1}}}return{_format:"columnar",columns:i,rowCount:f,data:l}}_readVarint(e,t){let s=0,n=0,r=0;for(;;){let o=e.getUint8(t+r);if(r++,s|=(o&127)<<n,(o&128)===0)break;n+=7}return[s,r]}_parseLegacyResult(e,t,s){let n=new DataView(e,t,s),r=new TextDecoder,o=n.getUint32(4,!0),a=Number(n.getBigUint64(8,!0)),c=n.getUint32(24,!0),i=n.getUint32(32,!0),l=[],f={};for(let d=0;d<o;d++){let m=36+d*16,y=n.getUint32(m,!0),h=n.getUint32(m+4,!0),w=n.getUint32(m+8,!0),g=n.getUint32(m+12,!0),p=new Uint8Array(e,t+i+h,w),b=r.decode(p);l.push(b);let _=Object.keys(He).find(S=>He[S]===y).toLowerCase(),T=t+c+g;if(_==="float64"||_==="int64"||_==="int32"||_==="float32")_==="float64"?f[b]=new Float64Array(e,T,a).slice():_==="int64"?f[b]=new Float64Array(e,T,a).slice():_==="int32"?f[b]=new Int32Array(e,T,a).slice():_==="float32"&&(f[b]=new Float32Array(e,T,a).slice());else if(_==="string"||_==="list"){let S=new Uint32Array(a+1),A=0;S[0]=0;let C=T,N=0;for(let Q=0;Q<a;Q++){let pe=n.getUint32(C+Q*8+4,!0);N+=pe,S[Q+1]=N}let ye=T+a*8,x=new Uint8Array(e,ye,N).slice();f[b]={_arrowString:!0,offsets:S,bytes:x,isList:_==="list"}}}return{_format:"columnar",columns:l,rowCount:a,data:f}}clear(){let e=k();e&&e.clearTables(),this._registered.clear()}clearTable(e){let t=k();if(t&&this._registered.has(e)){let s=new TextEncoder().encode(e),n=t.alloc(s.length);new Uint8Array(V().buffer,n,s.length).set(s),t.clearTable(n,s.length)}this._registered.delete(e)}},Se=null;function J(){return Se||(Se=new xe),Se}var Y=class{constructor(e=512*1024*1024){this.maxBytes=e,this.currentBytes=0,this.cache=new Map,this.head=null,this.tail=null}get(e){let t=this.cache.get(e);if(t)return this._moveToHead(t),t.value}set(e,t,s=0){let n=this.cache.get(e);if(n)this.currentBytes-=n.size,this.currentBytes+=s,n.value=t,n.size=s,this._moveToHead(n);else{let r={key:e,value:t,size:s,prev:null,next:null};this.cache.set(e,r),this._addToHead(r),this.currentBytes+=s}this._evictIfNeeded()}has(e){return this.cache.has(e)}delete(e){let t=this.cache.get(e);t&&(this._removeNode(t),this.cache.delete(e),this.currentBytes-=t.size)}clear(){this.cache.clear(),this.head=null,this.tail=null,this.currentBytes=0}_moveToHead(e){e!==this.head&&(this._removeNode(e),this._addToHead(e))}_addToHead(e){e.next=this.head,e.prev=null,this.head&&(this.head.prev=e),this.head=e,this.tail||(this.tail=e)}_removeNode(e){e.prev?e.prev.next=e.next:this.head=e.next,e.next?e.next.prev=e.prev:this.tail=e.prev}_evictIfNeeded(){for(;this.currentBytes>this.maxBytes&&this.tail;){let e=this.tail;this._removeNode(e),this.cache.delete(e.key),this.currentBytes-=e.size}}static estimateSize(e){return e?e.byteLength?e.byteLength:Array.isArray(e)?e.length*100:e.buffer&&e.buffer.byteLength?e.buffer.byteLength:1e3:0}};var ve=new Map,bt=1,X=class{constructor(e,t){this.name=e,this.tables=new Map,this.version=0,this.manifestKey=`${e}/__manifest__`,this.bufferPool=t||new Y,this._writeBuffer=new Map,this._flushTimer=null,this._flushInterval=2e3,this._flushThreshold=1e4,this._columnarBuffer=new Map,this._flushing=!1,this._readCache=new Map,this._columnarCache=new Map}async open(){let e=await v.load(this.manifestKey);if(e){let t=JSON.parse(z.decode(e));this.version=t.version||0,this.tables=new Map(Object.entries(t.tables||{}));for(let[s,n]of this.tables)await this._getLatestVersion(s)===0&&n.fragments?.length>0&&await this._createVersion(s,"MIGRATE")}return this}async _saveManifest(){this.version++;let e={version:this.version,timestamp:Date.now(),tables:Object.fromEntries(this.tables)},t=R.encode(JSON.stringify(e));await v.save(this.manifestKey,t)}async _getLatestVersion(e){let t=`${this.name}/${e}/_latest`;try{let s=await v.load(t);return s?parseInt(z.decode(s),10):0}catch{return 0}}async _setLatestVersion(e,t){let s=`${this.name}/${e}/_latest`;await v.save(s,R.encode(String(t)))}async _loadTableVersion(e,t){let s=`${this.name}/${e}/_versions/${t}.manifest`,n=await v.load(s);if(!n)throw new Error(`Version ${t} not found for table '${e}'`);return JSON.parse(z.decode(n))}async _saveTableVersion(e,t){let s=`${this.name}/${e}/_versions/${t.version}.manifest`;await v.save(s,R.encode(JSON.stringify(t)))}async _createVersion(e,t){let s=this.tables.get(e);if(!s)return 0;let n=await this._getLatestVersion(e),r=n+1,o={version:r,timestamp:Date.now(),parentVersion:n,operation:t,schema:s.schema,fragments:[...s.fragments],deletionVector:[...s.deletionVector],rowCount:s.rowCount,nextRowId:s.nextRowId};return await this._saveTableVersion(e,o),await this._setLatestVersion(e,r),r}async listVersions(e){let t=await this._getLatestVersion(e),s=[];for(let n=1;n<=t;n++)try{let r=await this._loadTableVersion(e,n);s.push({version:r.version,timestamp:r.timestamp,operation:r.operation,rowCount:r.rowCount})}catch{}return s}async selectAtVersion(e,t,s={}){let n=await this._loadTableVersion(e,t),r=new Set(n.deletionVector),o=this.tables.get(e),a=[];for(let l of n.fragments){let f=await v.load(l);if(f){let d=this._parseFragment(f,n.schema);for(let m of d)r.has(m.__rowId)||a.push(m)}}let c=a;if(s.where&&(c=c.filter(s.where)),s.orderBy){let{column:l,desc:f}=s.orderBy;c.sort((d,m)=>{let y=d[l]<m[l]?-1:d[l]>m[l]?1:0;return f?-y:y})}s.offset&&(c=c.slice(s.offset)),s.limit&&(c=c.slice(0,s.limit));let i=s.columns&&s.columns.length>0&&s.columns[0]!=="*"?s.columns:null;return c.map(l=>{if(i){let f={};for(let d of i)f[d]=l[d];return f}else{let{__rowId:f,...d}=l;return d}})}async restoreToVersion(e,t){let s=await this._loadTableVersion(e,t),n=await this._getLatestVersion(e),r=n+1,o={...s,version:r,timestamp:Date.now(),parentVersion:n,operation:`RESTORE_FROM_${t}`};await this._saveTableVersion(e,o),await this._setLatestVersion(e,r);let a=this.tables.get(e);return a&&(a.fragments=[...s.fragments],a.deletionVector=[...s.deletionVector],a.rowCount=s.rowCount,a.nextRowId=s.nextRowId,this._columnarBuffer.delete(e),this._writeBuffer.delete(e),await this._saveManifest()),{restored:!0,newVersion:r}}async createVectorIndex(e,t,s,n={}){let r=this.tables.get(e);if(!r){let l=J();if(l.hasTable(e)){let f=l.getTableSchema(e);f&&(r={name:e,schema:f.map(d=>({name:d.name,type:d.type||"string"})),fragments:[],deletionVector:[],rowCount:0,nextRowId:0,version:0,createdAt:Date.now(),vectorIndexes:{}},this.tables.set(e,r))}}if(!r)throw new Error(`Table '${e}' does not exist`);if(!r.schema.some(l=>l.name===t))throw new Error(`Column '${t}' does not exist in table '${e}'`);if(r.vectorIndexes||(r.vectorIndexes={}),r.vectorIndexes[t]){if(n.ifNotExists)return{success:!0,existed:!0};throw new Error(`Vector index already exists on ${e}(${t})`)}let a=`__vec_${t}_${s}`,c=n.dim||(s==="clip"?512:384);return r.vectorIndexes[t]={model:s,shadowColumn:a,dim:c,createdAt:Date.now()},r.schema.push({name:a,type:"vector",vectorDim:c,hidden:!0}),J().clearTable(e),await this._saveManifest(),{success:!0,shadowColumn:a}}async dropVectorIndex(e,t,s={}){let n=this.tables.get(e);if(!n){if(s.ifExists)return{success:!0,existed:!1};throw new Error(`Table '${e}' does not exist`)}if(!n.vectorIndexes?.[t]){if(s.ifExists)return{success:!0,existed:!1};throw new Error(`No vector index on ${e}(${t})`)}let r=n.vectorIndexes[t].shadowColumn;return delete n.vectorIndexes[t],n.schema=n.schema.filter(o=>o.name!==r),await this._saveManifest(),{success:!0}}getVectorIndexes(e=null){let t=[];for(let[s,n]of this.tables)if(!(e&&s!==e)&&n.vectorIndexes)for(let[r,o]of Object.entries(n.vectorIndexes))t.push({table:s,column:r,model:o.model,shadowColumn:o.shadowColumn,dim:o.dim});return t}getVectorIndex(e,t){return this.tables.get(e)?.vectorIndexes?.[t]||null}async createTable(e,t,s=!1){if(this.tables.has(e)){if(s)return{success:!0,existed:!0};throw new Error(`Table '${e}' already exists`)}let n=t.map(o=>({name:o.name,type:Ne[(o.dataType||o.type)?.toUpperCase()]||o.dataType||o.type||"string",primaryKey:o.primaryKey||!1,vectorDim:o.vectorDim||null})),r={name:e,schema:n,fragments:[],deletionVector:[],rowCount:0,nextRowId:0,version:0,createdAt:Date.now(),vectorIndexes:{}};return this.tables.set(e,r),await this._saveManifest(),await this._createVersion(e,"CREATE"),{success:!0,table:e}}async dropTable(e,t=!1){if(!this.tables.has(e)){if(t)return this._writeBuffer.delete(e),{success:!0,existed:!1};throw new Error(`Table '${e}' does not exist`)}let s=this.tables.get(e);this._writeBuffer.delete(e);for(let n of s.fragments)this._readCache.delete(n),await v.delete(n);return this.tables.delete(e),await this._saveManifest(),{success:!0,table:e}}async insert(e,t){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=this.tables.get(e),n=t.length;if(!this._columnarBuffer.has(e)){let c=Math.max(1024,n*2),i={__rowId:new Float64Array(c),__length:0,__capacity:c,__schema:s.schema};for(let l of s.schema){let f=(l.dataType||l.type||"").toLowerCase();f==="text"||f==="string"||f==="varchar"?i[l.name]=new Array(c):f==="int64"||f==="bigint"?i[l.name]=new BigInt64Array(c):i[l.name]=new Float64Array(c)}this._columnarBuffer.set(e,i)}let r=this._columnarBuffer.get(e),o=r.__length,a=r.__capacity;if(o+n>a){let c=Math.max(a*2,o+n),i=new Float64Array(c);i.set(r.__rowId.subarray(0,o)),r.__rowId=i;for(let l of s.schema){let f=r[l.name];if(f instanceof Float64Array){let d=new Float64Array(c);d.set(f.subarray(0,o)),r[l.name]=d}else if(f instanceof BigInt64Array){let d=new BigInt64Array(c);d.set(f.subarray(0,o)),r[l.name]=d}else r[l.name].length=c}r.__capacity=c}for(let c=0;c<n;c++){let i=t[c];r.__rowId[o+c]=s.nextRowId++;for(let l of s.schema){let f=i[l.name];r[l.name]instanceof Float64Array?r[l.name][o+c]=f!=null?Number(f):NaN:r[l.name]instanceof BigInt64Array?r[l.name][o+c]=f!=null?BigInt(f):0n:r[l.name][o+c]=f??null}}return r.__length=o+n,s.rowCount+=n,s.version=(s.version||0)+1,this._scheduleFlush(),r.__length>=this._flushThreshold&&await this._flushTable(e),{success:!0,inserted:n}}_scheduleFlush(){this._flushTimer||(this._flushTimer=setTimeout(()=>{this._flushTimer=null,this.flush().catch(e=>console.warn("[WorkerDatabase] Flush error:",e))},this._flushInterval))}async flush(){if(!this._flushing){this._flushing=!0;try{let e=[...this._columnarBuffer.keys()];for(let t of e)await this._flushTable(t)}finally{this._flushing=!1}}}async _flushTable(e){let t=this._columnarBuffer.get(e),s=t?.__length||0;if(!t||s===0)return;let n=this.tables.get(e);if(!n)return;let r=[{name:"__rowId",type:"int64",dataType:"float64",primaryKey:!0},...n.schema.filter(l=>l.name!=="__rowId").map(l=>{let f=(l.dataType||l.type||"").toLowerCase();return f==="int64"||f==="bigint"?{...l,dataType:"int64"}:{...l,dataType:f==="float64"||f==="float32"||f==="int32"||f==="integer"||f==="real"||f==="double"?"float64":l.dataType||l.type||"float64"}})],o={};for(let l of r){let f=t[l.name];f&&(f instanceof Float64Array||f instanceof BigInt64Array?o[l.name]=f.subarray(0,s):o[l.name]=f.slice(0,s))}t.__length=0;let a=new ce(r);a.setColumnarData(o);let c=a.build(),i=`${this.name}/${e}/frag_${Date.now()}_${Math.random().toString(36).slice(2)}.lance`;await v.save(i,c),n.fragments.push(i),await this._saveManifest(),await this._createVersion(e,"INSERT")}async delete(e,t){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=this.tables.get(e),n=0,r=this._columnarBuffer.get(e),o=r?.__length||0;if(r&&o>0){let a=s.schema.map(c=>c.name);for(let c=0;c<o;c++){let i={__rowId:r.__rowId[c]};for(let l of a){let f=r[l][c];i[l]=Number.isNaN(f)?null:f}t(i)&&(s.deletionVector.includes(r.__rowId[c])||(s.deletionVector.push(r.__rowId[c]),n++))}}for(let a of s.fragments){let c=await v.load(a);if(c){let i=this._parseFragment(c,s.schema);for(let l of i)!s.deletionVector.includes(l.__rowId)&&t(l)&&(s.deletionVector.push(l.__rowId),n++)}}return s.rowCount-=n,s.version=(s.version||0)+1,await this._saveManifest(),n>0&&await this._createVersion(e,"DELETE"),{success:!0,deleted:n}}async update(e,t,s){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let n=this.tables.get(e),r=0,o=this._writeBuffer.get(e);if(o&&o.length>0)for(let c of o)s(c)&&(Object.assign(c,t),r++);let a=[];for(let c of n.fragments){let i=await v.load(c);if(i){let l=this._parseFragment(i,n.schema);for(let f of l)if(!n.deletionVector.includes(f.__rowId)&&s(f)){n.deletionVector.push(f.__rowId),n.rowCount--;let d={...f,...t};delete d.__rowId,a.push(d),r++}}}return a.length>0?await this.insert(e,a):await this._saveManifest(),r>0&&a.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:r}}async updateWithExpr(e,t,s,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=this.tables.get(e),o=0,a=this._columnarBuffer.get(e),c=a?.__length||0;if(a&&c>0){let l=r.schema.map(f=>f.name);for(let f=0;f<c;f++){let d={__rowId:a.__rowId[f]};for(let m of l){let y=a[m][f];d[m]=Number.isNaN(y)?null:y}if(s(d)){for(let[m,y]of Object.entries(t)){let h=n(y,d);a[m]!==void 0&&(a[m][f]=h??(a[m]instanceof Float64Array?NaN:null))}r.version=(r.version||0)+1,o++}}}let i=[];for(let l of r.fragments){let f=await v.load(l);if(f){let d=this._parseFragment(f,r.schema);for(let m of d)if(!r.deletionVector.includes(m.__rowId)&&s(m)){r.deletionVector.push(m.__rowId),r.rowCount--;let y={...m};for(let[h,w]of Object.entries(t))y[h]=n(w,m);delete y.__rowId,i.push(y),o++}}}return i.length>0?await this.insert(e,i):await this._saveManifest(),o>0&&i.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:o}}async select(e,t={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=await this._readAllRows(e);if(t.where&&(s=s.filter(t.where)),t.orderBy){let{column:o,desc:a}=t.orderBy;s.sort((c,i)=>{let l=c[o]<i[o]?-1:c[o]>i[o]?1:0;return a?-l:l})}t.offset&&(s=s.slice(t.offset)),t.limit&&(s=s.slice(0,t.limit));let n=t.columns&&t.columns.length>0&&t.columns[0]!=="*"?t.columns:null,r=new Array(s.length);for(let o=0;o<s.length;o++){let a=s[o];if(n){let c={};for(let i of n)c[i]=a[i];r[o]=c}else{let{__rowId:c,...i}=a;r[o]=i}}return r}async _readAllRows(e){let t=this.tables.get(e),s=this._columnarBuffer.get(e),r=t.deletionVector.length>0?new Set(t.deletionVector):null,o=[];for(let c of t.fragments){let i=this.bufferPool.get(c),l=null;if(!i){let f=await v.load(c);f&&(i=ne(f),i?this.bufferPool.set(c,i,f.byteLength):l=this._parseFragment(f,t.schema))}if(i&&!l&&(l=this._hydrateRowsFromBinary(i,t.schema)),l=l||[],!r)o.push(...l);else for(let f of l)r.has(f.__rowId)||o.push(f)}let a=s?.__length||0;if(s&&a>0){let c=t.schema.map(i=>i.name);for(let i=0;i<a;i++){if(r&&r.has(s.__rowId[i]))continue;let l={__rowId:s.__rowId[i]};for(let f of c){let d=s[f][i];l[f]=Number.isNaN(d)?null:d}o.push(l)}}return o}_hydrateRowsFromBinary(e,t){let{columns:s,rowCount:n}=e,r=t.map(a=>a.name),o=new Array(n);for(let a=0;a<n;a++){let c={__rowId:s.__rowId[a]};for(let i of r)s[i]&&(c[i]=s[i][a]);o[a]=c}return o}_parseFragment(e,t){try{let s=ne(e);if(s)return this._parseBinaryColumnar(s);let n=z.decode(e),r=JSON.parse(n);return r.format==="json"&&r.columns?this._parseJsonColumnar(r):Array.isArray(r)?r:[r]}catch(s){return console.warn("[WorkerDatabase] Failed to parse fragment:",s),[]}}async selectColumnar(e){let t=this.tables.get(e);if(!t)return null;let s=this._columnarBuffer.get(e)?.__length||0,n=`${t.fragments.length}:${s}:${t.deletionVector.length}:${t.version||0}`,r=this._columnarCache.get(e);if(r&&r.version===n){let h={};for(let[w,g]of Object.entries(r.data.columns))ArrayBuffer.isView(g)?h[w]=new g.constructor(g.buffer,g.byteOffset,g.length):h[w]=g;return{schema:t.schema,columns:h,rowCount:r.data.rowCount}}let a=t.deletionVector.length>0?new Set(t.deletionVector):null,c={},i=t.schema.map(h=>h.name);for(let h of i)c[h]=[];c.__rowId=[];for(let h of t.fragments){let w=this.bufferPool.get(h);if(!w){let b=await v.load(h);if(!b)continue;w=ne(b),w&&this.bufferPool.set(h,w,b.byteLength)}if(!w)continue;let{columns:g,rowCount:p}=w;if(a){let b=g.__rowId,_=[];for(let T=0;T<p;T++)a.has(b[T])||_.push(T);for(let T of i)if(g[T]){let S=g[T],A=new S.constructor(_.length);for(let C=0;C<_.length;C++)A[C]=S[_[C]];c[T].push(A)}}else{for(let b of i)g[b]&&c[b].push(g[b]);g.__rowId&&c.__rowId.push(g.__rowId)}}let l=this._columnarBuffer.get(e),f=l?.__length||0;if(l&&f>0)if(a){let h=[];for(let p=0;p<f;p++)a.has(l.__rowId[p])||h.push(p);let w=h.length;for(let p of t.schema){let b=l[p.name];if(b)if(b instanceof Float64Array){let _=new Float64Array(w);for(let T=0;T<w;T++)_[T]=b[h[T]];c[p.name].push(_)}else c[p.name].push(h.map(_=>b[_]))}let g=new Float64Array(w);for(let p=0;p<w;p++)g[p]=l.__rowId[h[p]];c.__rowId.push(g)}else{for(let w of t.schema){let g=l[w.name];if(g)if(g instanceof Float64Array){let p=new Float64Array(f);p.set(g.subarray(0,f)),c[w.name].push(p)}else c[w.name].push(g.slice(0,f))}let h=new Float64Array(f);h.set(l.__rowId.subarray(0,f)),c.__rowId.push(h)}let d={},m=0;for(let h of[...i,"__rowId"]){let w=c[h];if(w.length===0)d[h]=new Float64Array(0);else if(w.length===1)d[h]=w[0],m===0&&(m=w[0].length);else{let g=w.reduce((T,S)=>T+S.length,0);m===0&&(m=g);let p=w[0],b=ArrayBuffer.isView(p)?new p.constructor(g):new Array(g),_=0;for(let T of w){if(ArrayBuffer.isView(b))b.set(T,_);else for(let S=0;S<T.length;S++)b[_+S]=T[S];_+=T.length}d[h]=b}}let y={schema:t.schema,columns:d,rowCount:m};return this._columnarCache.set(e,{version:n,data:y}),y}async _readColumn(e,t){let s=this.tables.get(e);if(!s)return null;let n=this._writeBuffer.get(e),r=[];for(let i of s.fragments){let l=await v.load(i);if(!l)continue;let f=ne(l);if(f&&f.columns[t]){let d=f.columns[t];d.length>0&&r.push(d)}}if(n&&n.length>0){let i=new Float64Array(n.length);for(let l=0;l<n.length;l++){let f=n[l][t];i[l]=typeof f=="number"?f:0}r.push(i)}if(r.length===0)return new Float64Array(0);if(r.length===1)return r[0];let o=r.reduce((i,l)=>i+l.length,0),a=new Float64Array(o),c=0;for(let i of r)a.set(i,c),c+=i.length;return a}_parseBinaryColumnar(e){let{schema:t,columns:s,rowCount:n}=e,r=new Array(n),o=t.map(i=>i.name),a=o.map(i=>s[i]),c=o.length;for(let i=0;i<n;i++){let l={};for(let f=0;f<c;f++)l[o[f]]=a[f][i]??null;r[i]=l}return r}_parseJsonColumnar(e){let{schema:t,columns:s,rowCount:n}=e,r=new Array(n),o=t.map(i=>i.name),a=o.map(i=>s[i]||[]),c=o.length;for(let i=0;i<n;i++){let l={};for(let f=0;f<c;f++)l[o[f]]=a[f][i]??null;r[i]=l}return r}getTable(e){return this.tables.get(e)}listTables(){return Array.from(this.tables.keys())}getFragmentPaths(e){let t=this.tables.get(e);return t?t.fragments:[]}getColumnIndex(e,t){let s=this.tables.get(e);if(!s)return-1;let n=s.schema.findIndex(r=>r.name===t);return n>=0?n+1:-1}hasBufferedData(e){let t=this._columnarBuffer.get(e);return t&&(t.__length||0)>0}async compact(){for(let[e,t]of this.tables){let s=await this._readAllRows(e);for(let n of t.fragments)await v.delete(n);if(t.fragments=[],t.deletionVector=[],t.rowCount=0,t.nextRowId=0,s.length>0){let n=s.map(({__rowId:r,...o})=>o);await this.insert(e,n)}}return{success:!0,compacted:this.tables.size}}async scanStart(e,t={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=bt++,n=this.tables.get(e),r=new Set(n.deletionVector),o=[];for(let c of n.fragments){let i=await v.load(c);if(i){let l=this._parseFragment(i,n.schema);for(let f of l)r.has(f.__rowId)||o.push(f)}}let a=this._writeBuffer.get(e);if(a)for(let c of a)r.has(c.__rowId)||o.push(c);return ve.set(s,{rows:o,index:0,batchSize:t.batchSize||1e4,columns:t.columns}),s}scanNext(e){let t=ve.get(e);if(!t)return{batch:[],done:!0};let s=[],n=Math.min(t.index+t.batchSize,t.rows.length);for(let o=t.index;o<n;o++){let a=t.rows[o],c;if(t.columns&&t.columns.length>0&&t.columns[0]!=="*"){c={};for(let i of t.columns)c[i]=a[i]}else{let{__rowId:i,...l}=a;c=l}s.push(c)}t.index=n;let r=t.index>=t.rows.length;return r&&ve.delete(e),{batch:s,done:r}}};var le=class{constructor(){this._root=null,this._ready=!1,this._kv={},this._encryptionKeyId=null,this._db=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:t,keyBytes:s}=e;if(!W.has(t)){let n=await re(s);W.set(t,n)}this._encryptionKeyId=t}try{let t=await navigator.storage.getDirectory();this._root=await t.getDirectoryHandle("vault",{create:!0}),await this._loadKV(),this._db=new X("vault"),await this._db.open(),this._ready=!0}catch(t){throw console.error("[WorkerVault] Failed to open OPFS:",t),t}return this}_getCryptoKey(){return this._encryptionKeyId?W.get(this._encryptionKeyId):null}async _loadKV(){try{let e=this._getCryptoKey(),t=e?"_vault.json.enc":"_vault.json",n=await(await this._root.getFileHandle(t)).getFile();if(e){let r=await n.arrayBuffer();this._kv=await ae(new Uint8Array(r),e)}else{let r=await n.text();this._kv=JSON.parse(r)}}catch(e){if(e.name==="NotFoundError")this._kv={};else throw e}}async _saveKV(){let e=this._getCryptoKey(),t=e?"_vault.json.enc":"_vault.json",n=await(await this._root.getFileHandle(t,{create:!0})).createWritable();if(e){let r=await oe(this._kv,e);await n.write(r)}else await n.write(JSON.stringify(this._kv));await n.close()}async get(e){return this._kv[e]}async set(e,t){this._kv[e]=t,await this._saveKV()}async delete(e){delete this._kv[e],await this._saveKV()}async keys(){return Object.keys(this._kv)}async has(e){return e in this._kv}};var Le=null,me=null;async function At(){return Le||me||(me=(async()=>{try{let{GPUTransformer:u}=await Promise.resolve().then(()=>(Ye(),Je)),e=new u;return await e.init()?(Le=e,console.log("[LanceQLWorker] GPUTransformer initialized for text encoding"),e):(console.log("[LanceQLWorker] WebGPU not available, using placeholder embeddings"),null)}catch(u){return console.warn("[LanceQLWorker] Failed to initialize GPUTransformer:",u.message),null}})(),me)}var Ce={showVersions:/^\s*SHOW\s+VERSIONS\s+FOR\s+(\w+)\s*$/i,restoreTable:/^\s*RESTORE\s+(\w+)\s+TO\s+VERSION\s+(\d+)\s*$/i,versionAsOf:/FROM\s+(\w+)\s+VERSION\s+AS\s+OF\s+(\d+)/i},Xe={createTable:/^\s*CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?(\w+)\s*\((.+)\)\s*$/is,dropTable:/^\s*DROP\s+TABLE\s+(?:IF\s+EXISTS\s+)?(\w+)\s*$/i};function It(u){let e=[],t=u.split(/,(?![^()]*\))/);for(let s of t){let r=s.trim().match(/^(\w+)\s+(\w+)(?:\s*\((\d+)\))?/i);if(r){let[,o,a,c]=r,i={name:o,type:a.toUpperCase()};a.toUpperCase()==="VECTOR"&&c&&(i.vectorDim=parseInt(c,10)),e.push(i)}}return e}async function Ze(u,e){let t;if(t=e.match(Xe.createTable)){let s=t[1],n=t[2],r=It(n);if(!u.tables.has(s)&&r.length>0){let o={name:s,schema:r.map(a=>({name:a.name,type:a.type.toLowerCase(),vectorDim:a.vectorDim||null})),fragments:[],deletionVector:[],rowCount:0,nextRowId:0,version:0,createdAt:Date.now(),vectorIndexes:{},_wasmManaged:!0};u.tables.set(s,o),console.log(`[LanceQLWorker] Synced DDL table '${s}' to WorkerDatabase`)}}if(t=e.match(Xe.dropTable)){let s=t[1];u.tables.has(s)&&(u.tables.delete(s),u._columnarBuffer?.delete(s),u._columnarCache?.delete(s),console.log(`[LanceQLWorker] Removed dropped table '${s}' from WorkerDatabase`))}}function et(u){let e;return(e=u.match(Ce.showVersions))?{type:"SHOW_VERSIONS",table:e[1]}:(e=u.match(Ce.restoreTable))?{type:"RESTORE_TABLE",table:e[1],version:parseInt(e[2],10)}:(e=u.match(Ce.versionAsOf))?{type:"SELECT_VERSION",table:e[1],version:parseInt(e[2],10),sql:u}:null}var Ue={createIndex:/^\s*CREATE\s+VECTOR\s+INDEX\s+(?:IF\s+NOT\s+EXISTS\s+)?ON\s+(\w+)\s*\(\s*(\w+)\s*\)\s+USING\s+(\w+)\s*$/i,dropIndex:/^\s*DROP\s+VECTOR\s+INDEX\s+(?:IF\s+EXISTS\s+)?ON\s+(\w+)\s*\(\s*(\w+)\s*\)\s*$/i,showIndexes:/^\s*SHOW\s+VECTOR\s+INDEX(?:ES)?\s*(?:FOR\s+(\w+))?\s*$/i},Me={minilm:{dim:384,type:"text"},clip:{dim:512,type:"multimodal"}},St=/^\s*INSERT\s+INTO\s+(\w+)\s*(?:\(([^)]+)\))?\s*VALUES\s*(.+)$/is;async function ft(u,e,t="minilm"){let s=await At();if(s)try{let n=await s.encodeText(u,t);if(n.length===e)return n;console.warn(`[LanceQLWorker] Model ${t} returned ${n.length}D embedding, expected ${e}D`)}catch(n){console.warn("[LanceQLWorker] GPU encoding failed, using fallback:",n.message)}return xt(u,e)}function xt(u,e){let t=new Float32Array(e),s=0;for(let o=0;o<u.length;o++)s=(s<<5)-s+u.charCodeAt(o)|0;let n=Math.abs(s);for(let o=0;o<e;o++)n=n*1103515245+12345&2147483647,t[o]=n/2147483647*2-1;let r=0;for(let o=0;o<e;o++)r+=t[o]*t[o];r=Math.sqrt(r);for(let o=0;o<e;o++)t[o]/=r;return t}function vt(u){let e=[],t=0,s=[],n="",r=!1,o="";for(let a=0;a<u.length;a++){let c=u[a];r?(n+=c,c===o&&u[a-1]!=="\\"&&(r=!1)):c==="'"||c==='"'?(r=!0,o=c,n+=c):c==="("?(t++,t===1&&(n="")):c===")"?(t--,t===0&&(s.push(n.trim()),e.push([...s]),s=[],n="")):c===","&&t===1?(s.push(n.trim()),n=""):t>0&&(n+=c)}return e}function tt(u){return u==null?"NULL":typeof u=="number"?u.toString():typeof u=="string"?`'${u.replace(/'/g,"''")}'`:Array.isArray(u)||u instanceof Float32Array?`'[${Array.from(u).join(",")}]'`:`'${String(u).replace(/'/g,"''")}'`}async function nt(u,e){let t=e.match(St);if(!t)return null;let s=t[1],n=u.tables.get(s);if(!n||!n.vectorIndexes||Object.keys(n.vectorIndexes).length===0)return null;let r;t[2]?r=t[2].split(",").map(m=>m.trim()):r=n.schema.filter(m=>!m.hidden).map(m=>m.name);let o=t[3],a=vt(o),c=[...r],i=[];for(let[m,y]of Object.entries(n.vectorIndexes))r.includes(m)&&(c.push(y.shadowColumn),i.push({sourceCol:m,shadowCol:y.shadowColumn,sourceIdx:r.indexOf(m),model:y.model,dim:y.dim}));if(i.length===0)return null;let l=[];for(let m of a){let y=[...m];for(let{sourceIdx:h,model:w,dim:g}of i){let p=m[h];if(p&&(p.startsWith("'")||p.startsWith('"'))&&(p=p.slice(1,-1)),p&&typeof p=="string"){let b=await ft(p,g,w);y.push(tt(b))}else y.push(tt(new Float32Array(g)))}l.push(y)}let f=l.map(m=>`(${m.join(", ")})`).join(", "),d=`INSERT INTO ${s} (${c.join(", ")}) VALUES ${f}`;return console.log(`[LanceQLWorker] Auto-encoded INSERT for ${i.length} vector index(es)`),d}var st=/(\w+)\s+NEAR\s+'([^']+)'/i,rt=/(\w+)\s+NEAR\s+'([^']+)'\s+LIMIT\s+(\d+)/i;async function ot(u,e){let t=e.match(st);if(!t)return null;let s=t[1],n=e.match(/FROM\s+(\w+)/i);if(!n)return null;let r=n[1],o=u.tables.get(r);if(!o)return null;let a=o.vectorIndexes?.[s];if(!a)return null;let c=t[2],{shadowColumn:i,model:l,dim:f}=a,d=await ft(c,f,l),m=`[${Array.from(d).join(",")}]`,y=e.match(rt),h;return y?h=e.replace(rt,`${i} NEAR '${m}' LIMIT ${y[3]}`):(h=e.replace(st,`${i} NEAR '${m}'`),e.toLowerCase().includes("limit")||(h+=" LIMIT 10")),console.log(`[LanceQLWorker] Rewrote NEAR clause: ${s} \u2192 ${i}`),h}function Et(u){let e;if(e=u.match(Ue.createIndex)){let t=e[3].toLowerCase();if(!Me[t])throw new Error(`Unknown embedding model: ${e[3]}. Supported: ${Object.keys(Me).join(", ")}`);return{type:"CREATE_VECTOR_INDEX",table:e[1],column:e[2],model:t,dim:Me[t].dim,ifNotExists:u.toLowerCase().includes("if not exists")}}return(e=u.match(Ue.dropIndex))?{type:"DROP_VECTOR_INDEX",table:e[1],column:e[2],ifExists:u.toLowerCase().includes("if exists")}:(e=u.match(Ue.showIndexes))?{type:"SHOW_VECTOR_INDEXES",table:e[1]||null}:null}async function at(u,e){if(!F&&(await se(),!F))throw new Error("WASM not loaded");let t=J(),s=t.getTableNames(e);for(let n of s){if(t.hasTable(n))continue;let o=u.tables.get(n);if(!o)continue;let a=u._columnarBuffer?.get(n),c=a?.__length||0,i=`${n}:${o.fragments?.length||0}:${c}:${o.deletionVector?.length||0}`,l=o.fragments.length>0,f=c>0;if(l){let d=[];for(let m of o.fragments){let y=await Ct(m);y&&d.push(y)}if(t.registerTableFromFiles(n,o.fragments,i),f){let m={};for(let y of o.schema){let h=a[y.name];h&&ArrayBuffer.isView(h)&&(m[y.name]=h.subarray(0,c))}t.appendTableMemory(n,m,c)}}else if(f){let d=await u.selectColumnar(n);if(d){let{columns:m,rowCount:y}=d;t.registerTable(n,m,y,i)}}}return t.execute(e)}var F=null,j=null,ee=new Map,Bt=1;async function ut(u){let e=await navigator.storage.getDirectory();e=await e.getDirectoryHandle("lanceql",{create:!0});for(let t of u)e=await e.getDirectoryHandle(t,{create:!0});return e}function Lt(){return{env:{opfs_open:(u,e)=>{try{let t=new Uint8Array(j.buffer,u,e),s=new TextDecoder().decode(t);for(let[n,r]of ee.entries())if(r._path===s)return n;return console.warn("[LanceQLWorker] WASM tried to open unregistered path:",s),0}catch(t){return console.error("[LanceQLWorker] Error:",t),0}},opfs_read:(u,e,t,s)=>{let n=ee.get(u);if(!n)return 0;try{let r=new Uint8Array(j.buffer,e,t);return n.read(r,{at:Number(s)})}catch{return 0}},opfs_size:u=>{let e=ee.get(u);if(!e)return BigInt(0);try{return BigInt(e.getSize())}catch{return BigInt(0)}},opfs_close:u=>{},__assert_fail:(u,e,t,s)=>{let r=new TextDecoder().decode(new Uint8Array(j.buffer,u).subarray(0,100));console.error(`[WASM ASSERT] ${r} at line ${t}`)},js_log:(u,e)=>{let s=new TextDecoder().decode(new Uint8Array(j.buffer,u,e));console.log(`[WASM LOG] ${s}`);for(let n of ke)n.postMessage({type:"log",message:s,marker:"__WASM_LOG_BRIDGE__"})}}}}async function Ct(u){try{let e=u.split("/").filter(a=>a),t=e.pop(),r=await(await(await ut(e)).getFileHandle(t)).createSyncAccessHandle(),o=Bt++;return r._path=u,ee.set(o,r),o}catch(e){return console.warn("[LanceQLWorker] Failed to register OPFS file:",u,e),0}}function Tn(u){let e=ee.get(u);if(e){try{e.close()}catch{}ee.delete(u)}}async function se(){if(F)return F;try{let u=new URL("./lanceql.wasm",import.meta.url);u.searchParams.set("v",Date.now().toString());let t=await(await fetch(u)).arrayBuffer(),s=Lt();return F=(await WebAssembly.instantiate(t,s)).instance.exports,j=F.memory,console.log("[LanceQLWorker] WASM loaded with OPFS support"),F}catch(u){return console.warn("[LanceQLWorker] WASM not available:",u.message),null}}function k(){return F}function V(){return j}var Oe=0,it=0,Ut=1024*1024;function Mt(u){if(!F)return 0;if(u<=it&&Oe!==0)return Oe;let e=Math.max(u,Ut),t=F.alloc(e);return t&&(Oe=t,it=e),t}async function An(u){let e=await se();if(!e)return 0;try{let t=u.split("/").filter(f=>f),s=t.pop(),o=await(await(await ut(t)).getFileHandle(s)).createSyncAccessHandle(),a=o.getSize(),c=Mt(a);if(!c)return o.close(),0;let i=new Uint8Array(j.buffer,c,a),l=o.read(i,{at:0});return o.close(),l!==a?0:e.openFile(c,a)}catch(t){return console.warn("[LanceQLWorker] Failed to load fragment:",u,t),0}}async function Ot(u,e){let t=e.split("/").filter(n=>n),s=u;for(let n=0;n<t.length-1;n++)s=await s.getDirectoryHandle(t[n],{create:!1});return await s.getFileHandle(t[t.length-1],{create:!1})}var Fe=null;async function Ft(u){let e=Re.get(u);if(e)return e;Fe||(Fe=await navigator.storage.getDirectory());let n=await(await(await Ot(Fe,u)).getFile()).arrayBuffer();return e=new Uint8Array(n),e&&Re.set(u,e,e.byteLength),e}async function In(u,e,t){if(!await Ft(u))return null;let n=F;switch(t){case"sum":return n.opfsSumFloat64Column(e);case"min":return n.opfsMinFloat64Column(e);case"max":return n.opfsMaxFloat64Column(e);case"avg":return n.opfsAvgFloat64Column(e);case"count":return Number(n.opfsCountRows());default:return null}}se();var Re=new Y,De=new Map,$e=new Map,ge=null,ke=new Set,Z=null,K=0,Dt=1024,we=new Map,ct=1;async function H(u=null){return ge||(ge=new le),await ge.open(u),ge}async function M(u,e={},t=null){let s=t?.keyId||"none",n=`${u}:${s}:${JSON.stringify(e)}`;if(!De.has(n)){let r=new ie(u,e);await r.open(t),De.set(n,r)}return De.get(n)}async function B(u){if(!$e.has(u)){let e=new X(u,Re);await e.open(),$e.set(u,e)}return $e.get(u)}function $t(u,e,t){if(t&&t._format==="wasm_binary"){u.postMessage({id:e,result:{_format:"wasm_binary",buffer:t.buffer,columns:t.columns,rowCount:t.rowCount,schema:t.schema}},[t.buffer]);return}if(t&&t._format==="columnar"&&t.data){let s=t.columns,n=t.rowCount;if(n<1e5){let m=[],y={},h=new Set;for(let w of s){let g=t.data[w];if(ArrayBuffer.isView(g)){let p=g.byteOffset!==0||g.byteLength<g.buffer.byteLength,b=h.has(g.buffer);if(p||b){let _=new g.constructor(g);y[w]=_,m.push(_.buffer)}else y[w]=g,m.push(g.buffer),h.add(g.buffer)}else g&&g._arrowString?(y[w]=g,g.offsets&&g.offsets.buffer&&!h.has(g.offsets.buffer)&&(m.push(g.offsets.buffer),h.add(g.offsets.buffer)),g.bytes&&g.bytes.buffer&&!h.has(g.bytes.buffer)&&(m.push(g.bytes.buffer),h.add(g.bytes.buffer))):y[w]=g}u.postMessage({id:e,result:{_format:"columnar",columns:s,rowCount:n,data:y}},m);return}let r=[],o=[],a=0;for(let m of s){let y=t.data[m];ArrayBuffer.isView(y)?(r.push({name:m,arr:y}),a+=y.byteLength):Array.isArray(y)&&o.push({name:m,arr:y})}let c=a>0?new ArrayBuffer(a):null,i={},l=0;if(c){let m=new Uint8Array(c);for(let{name:y,arr:h}of r){let w=new Uint8Array(h.buffer,h.byteOffset,h.byteLength);m.set(w,l),i[y]={offset:l,length:h.length,type:h.constructor.name},l+=h.byteLength}}let f={};for(let{name:m,arr:y}of o)f[m]=y;let d=[];c&&d.push(c),u.postMessage({id:e,result:{_format:"packed",columns:s,rowCount:n,packedBuffer:c,colOffsets:i,stringData:f}},d);return}if(Z&&t!==void 0){let s=JSON.stringify(t);if(s.length>Dt){let n=R.encode(s);if(K+n.length<=Z.byteLength){new Uint8Array(Z,K,n.length).set(n),u.postMessage({id:e,sharedOffset:K,sharedLength:n.length}),K+=n.length,K>Z.byteLength/2&&(K=0);return}}}u.postMessage({id:e,result:t})}async function lt(u,e){if(e.type==="initSharedBuffer"){Z=e.buffer,K=0,console.log("[LanceQLWorker] SharedArrayBuffer initialized:",Z.byteLength,"bytes");return}let{id:t,method:s,args:n}=e;try{let r;if(s==="ping")r="pong";else if(s==="open")await M(n.name,n.options,n.encryption),r=!0;else if(s==="get")r=await(await M(n.name)).get(n.key);else if(s==="set")await(await M(n.name)).set(n.key,n.value),r=!0;else if(s==="delete")await(await M(n.name)).delete(n.key),r=!0;else if(s==="keys")r=await(await M(n.name)).keys();else if(s==="clear")await(await M(n.name)).clear(),r=!0;else if(s==="filter")r=await(await M(n.name)).filter(n.key,n.query);else if(s==="find")r=await(await M(n.name)).find(n.key,n.query);else if(s==="search")r=await(await M(n.name)).search(n.key,n.text,n.limit);else if(s==="count")r=await(await M(n.name)).count(n.key,n.query);else if(s==="enableSemanticSearch")r=await(await M(n.name)).enableSemanticSearch(n.options);else if(s==="disableSemanticSearch")(await M(n.name)).disableSemanticSearch(),r=!0;else if(s==="hasSemanticSearch")r=(await M(n.name)).hasSemanticSearch();else if(s==="db:open")console.log(`[LanceQLWorker] db:open ${n.name}`),await B(n.name),r=!0;else if(s==="db:createTable")console.log(`[LanceQLWorker] db:createTable ${n.tableName}`),r=await(await B(n.db)).createTable(n.tableName,n.columns,n.ifNotExists),console.log(`[LanceQLWorker] db:createTable ${n.tableName} done`);else if(s==="db:dropTable"){console.log(`[LanceQLWorker] db:dropTable ${n.tableName}`),r=await(await B(n.db)).dropTable(n.tableName,n.ifExists);let a=R.encode(n.tableName);J().clearTable(a,a.length)}else if(s==="db:insert")console.log(`[LanceQLWorker] db:insert into ${n.tableName}, rows: ${n.rows?.length}`),r=await(await B(n.db)).insert(n.tableName,n.rows),console.log("[LanceQLWorker] db:insert done");else if(s==="db:delete"){let o=await B(n.db),a=n.where?c=>evalWhere(n.where,c):()=>!0;r=await o.delete(n.tableName,a)}else if(s==="db:update"){let o=await B(n.db),a=n.where?c=>evalWhere(n.where,c):()=>!0;r=await o.update(n.tableName,n.updates,a)}else if(s==="db:select"){let o=await B(n.db),a={...n.options};n.where&&(a.where=c=>evalWhere(n.where,c)),r=await o.select(n.tableName,a)}else if(s==="db:exec"){let o=await B(n.db),a=et(n.sql);if(a?.type==="SHOW_VERSIONS"){let c=await o.listVersions(a.table);r={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:c.length,data:{version:new Float64Array(c.map(i=>i.version)),timestamp:c.map(i=>new Date(i.timestamp).toISOString()),operation:c.map(i=>i.operation),rowCount:new Float64Array(c.map(i=>i.rowCount))}}}else if(a?.type==="RESTORE_TABLE"){let c=await o.restoreToVersion(a.table,a.version);r={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([c.newVersion])}}}else if(a?.type==="SELECT_VERSION"){let c=await o.selectAtVersion(a.table,a.version,{});if(c.length>0){let i=Object.keys(c[0]),l={};for(let f of i)l[f]=c.map(d=>d[f]);r={_format:"columnar",columns:i,rowCount:c.length,data:l}}else r={_format:"columnar",columns:[],rowCount:0,data:{}}}else{let c=n.sql,i=await nt(o,n.sql);i&&(c=i);let l=await ot(o,c);l&&(c=l),r=await at(o,c),await Ze(o,n.sql)}if(r&&r._format==="columnar"&&r.rowCount>=1e5){let c=ct++;we.set(c,r),r={_format:"cursor",cursorId:c,columns:r.columns,rowCount:r.rowCount}}}else if(s==="cursor:fetch"){let o=we.get(n.cursorId);if(!o)throw new Error("Cursor not found");r=o,we.delete(n.cursorId)}else if(s==="db:flush")console.log(`[LanceQLWorker] db:flush ${n.db}`),await(await B(n.db)).flush(),console.log(`[LanceQLWorker] db:flush ${n.db} done`),r=!0;else if(s==="db:compact")r=await(await B(n.db)).compact();else if(s==="db:listTables")r=(await B(n.db)).listTables();else if(s==="db:getTable")r=(await B(n.db)).getTable(n.tableName);else if(s==="db:scanStart")r=await(await B(n.db)).scanStart(n.tableName,n.options);else if(s==="db:scanNext")r=(await B(n.db)).scanNext(n.streamId);else if(s==="db:listVersions")r=await(await B(n.db)).listVersions(n.tableName);else if(s==="db:selectAtVersion"){let o=await B(n.db),a={...n.options};n.where&&(a.where=c=>evalWhere(n.where,c)),r=await o.selectAtVersion(n.tableName,n.version,a)}else if(s==="db:restoreTable")r=await(await B(n.db)).restoreToVersion(n.tableName,n.version);else if(s==="vault:open")await H(n.encryption),r=!0;else if(s==="vault:get")r=await(await H()).get(n.key);else if(s==="vault:set")await(await H()).set(n.key,n.value),r=!0;else if(s==="vault:delete")await(await H()).delete(n.key),r=!0;else if(s==="vault:keys")r=await(await H()).keys();else if(s==="vault:has")r=await(await H()).has(n.key);else if(s==="vault:exec"){let a=(await H())._db,c=et(n.sql);if(c?.type==="SHOW_VERSIONS"){let i=await a.listVersions(c.table);r={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:i.length,data:{version:new Float64Array(i.map(l=>l.version)),timestamp:i.map(l=>new Date(l.timestamp).toISOString()),operation:i.map(l=>l.operation),rowCount:new Float64Array(i.map(l=>l.rowCount))}}}else if(c?.type==="RESTORE_TABLE"){let i=await a.restoreToVersion(c.table,c.version);r={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([i.newVersion])}}}else if(c?.type==="SELECT_VERSION"){let i=await a.selectAtVersion(c.table,c.version,{});if(i.length>0){let l=Object.keys(i[0]),f={};for(let d of l)f[d]=i.map(m=>m[d]);r={_format:"columnar",columns:l,rowCount:i.length,data:f}}else r={_format:"columnar",columns:[],rowCount:0,data:{}}}else{let i=Et(n.sql);if(i?.type==="CREATE_VECTOR_INDEX")await a.createVectorIndex(i.table,i.column,i.model,{dim:i.dim,ifNotExists:i.ifNotExists}),r={_format:"columnar",columns:["status","table","column","model","shadowColumn"],rowCount:1,data:{status:["created"],table:[i.table],column:[i.column],model:[i.model],shadowColumn:[`__vec_${i.column}_${i.model}`]}};else if(i?.type==="DROP_VECTOR_INDEX")await a.dropVectorIndex(i.table,i.column,{ifExists:i.ifExists}),r={_format:"columnar",columns:["status"],rowCount:1,data:{status:["dropped"]}};else if(i?.type==="SHOW_VECTOR_INDEXES"){let l=a.getVectorIndexes(i.table);r={_format:"columnar",columns:["table","column","model","shadowColumn","dim"],rowCount:l.length,data:{table:l.map(f=>f.table),column:l.map(f=>f.column),model:l.map(f=>f.model),shadowColumn:l.map(f=>f.shadowColumn),dim:new Float64Array(l.map(f=>f.dim))}}}else{let l=n.sql,f=await nt(a,n.sql);f&&(l=f);let d=await ot(a,l);d&&(l=d),r=await at(a,l),await Ze(a,n.sql)}}if(r&&r._format==="columnar"&&r.rowCount>=1e5){let i=ct++;we.set(i,r),r={_format:"cursor",cursorId:i,columns:r.columns,rowCount:r.rowCount}}}else throw new Error(`Unknown method: ${s}`);$t(u,t,r)}catch(r){u.postMessage({id:t,error:r.stack||r.message})}}var Rt=typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope;Rt?self.onconnect=u=>{let e=u.ports[0];ke.add(e),e.onmessage=t=>{lt(e,t.data)},e.onmessageerror=t=>{console.error("[LanceQLWorker] Message error:",t)},se().then(()=>{e.postMessage({type:"ready"})}).catch(t=>{console.error("[LanceQLWorker] Failed to load WASM:",t),e.postMessage({type:"ready",error:"WASM load failed"})}),e.start(),console.log("[LanceQLWorker] New connection, total ports:",ke.size)}:(self.onmessage=u=>{lt(self,u.data)},se().then(()=>{self.postMessage({type:"ready"})}).catch(u=>{console.error("[LanceQLWorker] Failed to load WASM:",u),self.postMessage({type:"ready",error:"WASM load failed"})}));console.log("[LanceQLWorker] Initialized");export{Tn as closeOPFSFile,k as getWasm,V as getWasmMemory,An as loadFragmentToWasm,Ct as registerOPFSFile,In as wasmAggregate};
//# sourceMappingURL=lanceql-worker.js.map
