var Y=new Map;async function fe(u){return crypto.subtle.importKey("raw",new Uint8Array(u),{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function ue(u,t){let n=crypto.getRandomValues(new Uint8Array(12)),e=new TextEncoder().encode(JSON.stringify(u)),s=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},t,e),l=new Uint8Array(12+s.byteLength);return l.set(n,0),l.set(new Uint8Array(s),12),l}async function he(u,t){let n=u.slice(0,12),r=u.slice(12),e=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},t,r),s=new TextDecoder;return JSON.parse(s.decode(e))}var G=null,ie=null,be=new Map;function rt(u){G=u}function st(u){ie=u}var de=class{constructor(t,n={}){this.name=t,this.options=n,this._root=null,this._ready=!1,this._embedder=null,this._encryptionKeyId=null}async open(t=null){if(this._ready)return this;if(t){let{keyId:n,keyBytes:r}=t;if(!Y.has(n)){let e=await fe(r);Y.set(n,e)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle(`lanceql-${this.name}`,{create:!0}),this._ready=!0}catch(n){throw console.error("[WorkerStore] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?Y.get(this._encryptionKeyId):null}async get(t){await this._ensureOpen();try{let n=this._getCryptoKey(),r=n?".enc":".json",s=await(await this._root.getFileHandle(`${t}${r}`)).getFile();if(n){let l=await s.arrayBuffer();return he(new Uint8Array(l),n)}else{let l=await s.text();return JSON.parse(l)}}catch(n){if(n.name==="NotFoundError")return;throw n}}async set(t,n){await this._ensureOpen();let r=this._getCryptoKey(),e=r?".enc":".json",l=await(await this._root.getFileHandle(`${t}${e}`,{create:!0})).createWritable();if(r){let o=await ue(n,r);await l.write(o)}else await l.write(JSON.stringify(n));await l.close()}async delete(t){await this._ensureOpen();let r=this._getCryptoKey()?".enc":".json";try{await this._root.removeEntry(`${t}${r}`)}catch(e){if(e.name!=="NotFoundError")throw e}}async keys(){await this._ensureOpen();let n=this._getCryptoKey()?".enc":".json",r=[];for await(let[e]of this._root.entries())e.endsWith(n)&&r.push(e.slice(0,-n.length));return r}async clear(){await this._ensureOpen();let t=[];for await(let[n]of this._root.entries())t.push(n);for(let n of t)await this._root.removeEntry(n)}async filter(t,n){let r=await this.get(t);if(!Array.isArray(r))throw new Error(`Key '${t}' is not a collection`);return r.filter(e=>this._matchQuery(e,n))}async find(t,n){let r=await this.get(t);if(!Array.isArray(r))throw new Error(`Key '${t}' is not a collection`);return r.find(e=>this._matchQuery(e,n))}async search(t,n,r=10){let e=await this.get(t);if(!Array.isArray(e))throw new Error(`Key '${t}' is not a collection`);if(e.length===0)return[];if(this._embedder)return this._semanticSearch(e,t,n,r);let s=n.toLowerCase();return e.map(o=>{let a=this._extractText(o).toLowerCase(),i=s.split(/\s+/),c=i.filter(f=>a.includes(f)).length;return{item:o,score:c/i.length}}).filter(o=>o.score>0).sort((o,a)=>a.score-o.score).slice(0,r)}async _semanticSearch(t,n,r,e){let s=await this._embedder.embed(r),l=[],o=[],a=[];for(let i=0;i<t.length;i++){let c=t[i],f=this._extractText(c),h=`${this.name}:${n}:${f}`;if(be.has(h)){let p=be.get(h),m=this._cosineSimilarity(s,p);l.push({item:c,score:m})}else o.push(f),a.push(i)}if(o.length>0){let i;o.length>1&&this._embedder.embedBatch?i=await this._embedder.embedBatch(o):i=await Promise.all(o.map(c=>this._embedder.embed(c)));for(let c=0;c<i.length;c++){let f=a[c],h=t[f],p=o[c],m=i[c],d=`${this.name}:${n}:${p}`;be.set(d,m);let w=this._cosineSimilarity(s,m);l.push({item:h,score:w})}}return l.sort((i,c)=>c.score-i.score).slice(0,e)}async enableSemanticSearch(t={}){let{model:n="minilm",onProgress:r}=t;if(G||(ie||(ie=this._initGPUTransformer(),st(ie)),G=await ie,rt(G)),!G)return null;let e=await G.loadModel(n,r);return this._embedder={model:n,dimensions:e.hiddenSize,embed:async s=>G.encodeText(s,n),embedBatch:async s=>G.encodeTextBatch(s,n)},{model:n,dimensions:e.hiddenSize,type:e.modelType||"text"}}async _initGPUTransformer(){try{let t=await import("./webgpu/index.js");if(!t.isWebGPUAvailable())return console.log("[WorkerStore] WebGPU not available"),null;let n=t.getGPUTransformer();return await n.init()?(console.log("[WorkerStore] WebGPU initialized"),n):(console.log("[WorkerStore] WebGPU init failed"),null)}catch(t){return console.error("[WorkerStore] WebGPU init error:",t),null}}disableSemanticSearch(){this._embedder&&G&&(G.unloadModel(this._embedder.model),this._embedder=null)}hasSemanticSearch(){return this._embedder!==null}async count(t,n=null){let r=await this.get(t);if(!Array.isArray(r))throw new Error(`Key '${t}' is not a collection`);return n?r.filter(e=>this._matchQuery(e,n)).length:r.length}async _ensureOpen(){this._ready||await this.open()}_matchQuery(t,n){for(let[r,e]of Object.entries(n)){let s=t[r];if(typeof e=="object"&&e!==null)for(let[l,o]of Object.entries(e))switch(l){case"$eq":if(s!==o)return!1;break;case"$ne":if(s===o)return!1;break;case"$lt":if(!(s<o))return!1;break;case"$lte":if(!(s<=o))return!1;break;case"$gt":if(!(s>o))return!1;break;case"$gte":if(!(s>=o))return!1;break;case"$in":if(!Array.isArray(o)||!o.includes(s))return!1;break;case"$nin":if(Array.isArray(o)&&o.includes(s))return!1;break;case"$contains":if(typeof s!="string"||!s.includes(o))return!1;break;case"$regex":if(typeof s!="string"||!new RegExp(o).test(s))return!1;break}else if(s!==e)return!1}return!0}_extractText(t){if(typeof t=="string")return t;let n=[];for(let[r,e]of Object.entries(t))typeof e=="string"&&n.push(e);return n.join(" ")}_cosineSimilarity(t,n){let r=0,e=0,s=0;for(let l=0;l<t.length;l++)r+=t[l]*n[l],e+=t[l]*t[l],s+=n[l]*n[l];return r/(Math.sqrt(e)*Math.sqrt(s))}};var _e=class{constructor(t="lanceql"){this.rootDir=t,this.root=null}async getRoot(){if(this.root)return this.root;if(typeof navigator>"u"||!navigator.storage?.getDirectory)throw new Error("OPFS not available");let t=await navigator.storage.getDirectory();return this.root=await t.getDirectoryHandle(this.rootDir,{create:!0}),this.root}async open(){return await this.getRoot(),this}async getDir(t){let n=await this.getRoot(),r=t.split("/").filter(s=>s),e=n;for(let s of r)e=await e.getDirectoryHandle(s,{create:!0});return e}async save(t,n){let r=t.split("/"),e=r.pop(),s=r.join("/"),o=await(s?await this.getDir(s):await this.getRoot()).getFileHandle(e,{create:!0});if(o.createSyncAccessHandle)try{let i=await o.createSyncAccessHandle();return i.truncate(0),i.write(n,{at:0}),i.flush(),i.close(),{path:t,size:n.byteLength}}catch{}let a=await o.createWritable();return await a.write(n),await a.close(),{path:t,size:n.byteLength}}async load(t){try{let n=t.split("/"),r=n.pop(),e=n.join("/"),a=await(await(await(e?await this.getDir(e):await this.getRoot()).getFileHandle(r)).getFile()).arrayBuffer();return new Uint8Array(a)}catch(n){if(n.name==="NotFoundError")return null;throw n}}async delete(t){try{let n=t.split("/"),r=n.pop(),e=n.join("/");return await(e?await this.getDir(e):await this.getRoot()).removeEntry(r),!0}catch(n){if(n.name==="NotFoundError")return!1;throw n}}async list(t=""){try{let n=t?await this.getDir(t):await this.getRoot(),r=[];for await(let[e,s]of n.entries())r.push({name:e,type:s.kind});return r}catch{return[]}}async exists(t){try{let n=t.split("/"),r=n.pop(),e=n.join("/");return await(e?await this.getDir(e):await this.getRoot()).getFileHandle(r),!0}catch{return!1}}async deleteDir(t){try{let n=t.split("/"),r=n.pop(),e=n.join("/");return await(e?await this.getDir(e):await this.getRoot()).removeEntry(r,{recursive:!0}),!0}catch{return!1}}},N=new _e;var z=new TextEncoder,X=new TextDecoder,Me={INT64:"int64",INT32:"int32",FLOAT64:"float64",FLOAT32:"float32",STRING:"string",BOOL:"bool",VECTOR:"vector"},Pe=1,He=2,je=3,Ke=4,Ae=5,Se=6;function De(u){switch(u){case"int32":case"integer":return Int32Array;case"int64":return BigInt64Array;case"float32":case"real":return Float32Array;case"float64":case"double":return Float64Array;default:return null}}function ot(u){switch(u){case"int32":case"integer":return Pe;case"int64":return He;case"float32":case"real":return je;case"float64":case"double":return Ke;case"string":case"text":return Ae;case"bool":case"boolean":return Se;default:return Ae}}var we=class{constructor(t){this.schema=t,this.columns=new Map,this.rowCount=0,this._useBinary=!0}addRows(t){if(t.length!==0){if(this.rowCount===0)for(let n of this.schema){let r=De(n.dataType);r?this.columns.set(n.name,{type:"typed",dataType:n.dataType,data:new r(Math.max(t.length,1024)),length:0}):this.columns.set(n.name,{type:"array",dataType:n.dataType,data:[],length:0})}for(let n of this.schema){let r=this.columns.get(n.name);if(r.type==="typed"){let e=r.length+t.length;if(e>r.data.length){let s=Math.max(e,r.data.length*2),l=new r.data.constructor(s);l.set(r.data),r.data=l}for(let s=0;s<t.length;s++){let l=t[s][n.name];r.data[r.length+s]=l??0}r.length+=t.length}else{for(let e=0;e<t.length;e++)r.data.push(t[e][n.name]??null);r.length+=t.length}}this.rowCount+=t.length}}buildBinary(){let t=[],n=16,r=[];for(let a of this.schema){let i=this.columns.get(a.name),c=z.encode(a.name),f=ot(a.dataType),h;if(i.type==="typed"){let d=i.data.subarray(0,i.length);h=new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}else h=z.encode(JSON.stringify(i.data));r.push({nameBytes:c,typeCode:f,dataBytes:h,dataType:a.dataType});let m=(8-(n+4+c.length+1+4)%8)%8;n+=4+c.length+1+m+4+h.length}let e=new ArrayBuffer(n),s=new DataView(e),l=new Uint8Array(e),o=0;s.setUint32(o,1279348291,!1),o+=4,s.setUint32(o,2,!1),o+=4,s.setUint32(o,this.schema.length,!1),o+=4,s.setUint32(o,this.rowCount,!1),o+=4;for(let a of r){s.setUint32(o,a.nameBytes.length,!1),o+=4,l.set(a.nameBytes,o),o+=a.nameBytes.length,s.setUint8(o,a.typeCode),o+=1;let i=(8-(o+4)%8)%8;for(let c=0;c<i;c++)s.setUint8(o+c,0);o+=i,s.setUint32(o,a.dataBytes.length,!1),o+=4,l.set(a.dataBytes,o),o+=a.dataBytes.length}return new Uint8Array(e)}setColumnarData(t){let n=Object.keys(t)[0];this.rowCount=t[n]?.length||0;for(let r of this.schema){let e=t[r.name];if(!e)continue;let s=De(r.dataType);if(s&&ArrayBuffer.isView(e))this.columns.set(r.name,{type:"typed",dataType:r.dataType,data:e,length:e.length});else if(s){let l=new s(e.length);for(let o=0;o<e.length;o++)l[o]=e[o]??0;this.columns.set(r.name,{type:"typed",dataType:r.dataType,data:l,length:e.length})}else this.columns.set(r.name,{type:"array",dataType:r.dataType,data:Array.isArray(e)?e:Array.from(e),length:e.length})}}build(){if(this._useBinary&&this.rowCount>0)try{return this.buildBinary()}catch(n){console.warn("[LanceFileWriter] Binary build failed, falling back to JSON:",n)}let t={format:"json",schema:this.schema,columns:{},rowCount:this.rowCount};for(let[n,r]of this.columns)r.type==="typed"?t.columns[n]=Array.from(r.data.subarray(0,r.length)):t.columns[n]=r.data;return z.encode(JSON.stringify(t))}};function le(u){let t=new DataView(u.buffer||u),n=new Uint8Array(u.buffer||u),r=0;if(t.getUint32(r,!1)!==1279348291)return null;r+=4;let s=t.getUint32(r,!1);r+=4;let l=t.getUint32(r,!1);r+=4;let o=t.getUint32(r,!1);r+=4;let a=[],i={};for(let c=0;c<l;c++){let f=t.getUint32(r,!1);r+=4;let h=X.decode(n.subarray(r,r+f));r+=f;let p=t.getUint8(r);r+=1;let m=(8-(r+4)%8)%8;r+=m;let d=t.getUint32(r,!1);r+=4;let w=n.subarray(r,r+d);r+=d;let g,A;try{switch(p){case Pe:A="int32",w.byteOffset%4!==0?g=new Int32Array(w.slice().buffer):g=new Int32Array(w.buffer,w.byteOffset,w.byteLength/4);break;case je:A="float32",w.byteOffset%4!==0?g=new Float32Array(w.slice().buffer):g=new Float32Array(w.buffer,w.byteOffset,w.byteLength/4);break;case Ke:A="float64",w.byteOffset%8!==0?g=new Float64Array(w.slice().buffer):g=new Float64Array(w.buffer,w.byteOffset,w.byteLength/8);break;case He:A="int64",w.byteOffset%8!==0?g=new BigInt64Array(w.slice().buffer):g=new BigInt64Array(w.buffer,w.byteOffset,w.byteLength/8);break;case Ae:case Se:default:A=p===Se?"bool":"string",g=JSON.parse(X.decode(w));break}}catch(y){throw console.error(`[LanceQLWorker] Error parsing column '${h}' (type ${p}, len ${d}):`,y),y}a.push({name:h,dataType:A}),i[h]=g}return{schema:a,columns:i,rowCount:o,format:"binary"}}var re=class{constructor(t=512*1024*1024){this.maxBytes=t,this.currentBytes=0,this.cache=new Map,this.head=null,this.tail=null}get(t){let n=this.cache.get(t);if(n)return this._moveToHead(n),n.value}set(t,n,r=0){let e=this.cache.get(t);if(e)this.currentBytes-=e.size,this.currentBytes+=r,e.value=n,e.size=r,this._moveToHead(e);else{let s={key:t,value:n,size:r,prev:null,next:null};this.cache.set(t,s),this._addToHead(s),this.currentBytes+=r}this._evictIfNeeded()}has(t){return this.cache.has(t)}delete(t){let n=this.cache.get(t);n&&(this._removeNode(n),this.cache.delete(t),this.currentBytes-=n.size)}clear(){this.cache.clear(),this.head=null,this.tail=null,this.currentBytes=0}_moveToHead(t){t!==this.head&&(this._removeNode(t),this._addToHead(t))}_addToHead(t){t.next=this.head,t.prev=null,this.head&&(this.head.prev=t),this.head=t,this.tail||(this.tail=t)}_removeNode(t){t.prev?t.prev.next=t.next:this.head=t.next,t.next?t.next.prev=t.prev:this.tail=t.prev}_evictIfNeeded(){for(;this.currentBytes>this.maxBytes&&this.tail;){let t=this.tail;this._removeNode(t),this.cache.delete(t.key),this.currentBytes-=t.size}}static estimateSize(t){return t?t.byteLength?t.byteLength:Array.isArray(t)?t.length*100:t.buffer&&t.buffer.byteLength?t.buffer.byteLength:1e3:0}};var Te=new Map,at=1,se=class{constructor(t,n){this.name=t,this.tables=new Map,this.version=0,this.manifestKey=`${t}/__manifest__`,this.bufferPool=n||new re,this._writeBuffer=new Map,this._flushTimer=null,this._flushInterval=2e3,this._flushThreshold=1e4,this._columnarBuffer=new Map,this._flushing=!1,this._readCache=new Map,this._columnarCache=new Map}async open(){let t=await N.load(this.manifestKey);if(t){let n=JSON.parse(X.decode(t));this.version=n.version||0,this.tables=new Map(Object.entries(n.tables||{}));for(let[r,e]of this.tables)await this._getLatestVersion(r)===0&&e.fragments?.length>0&&await this._createVersion(r,"MIGRATE")}return this}async _saveManifest(){this.version++;let t={version:this.version,timestamp:Date.now(),tables:Object.fromEntries(this.tables)},n=z.encode(JSON.stringify(t));await N.save(this.manifestKey,n)}async _getLatestVersion(t){let n=`${this.name}/${t}/_latest`;try{let r=await N.load(n);return r?parseInt(X.decode(r),10):0}catch{return 0}}async _setLatestVersion(t,n){let r=`${this.name}/${t}/_latest`;await N.save(r,z.encode(String(n)))}async _loadTableVersion(t,n){let r=`${this.name}/${t}/_versions/${n}.manifest`,e=await N.load(r);if(!e)throw new Error(`Version ${n} not found for table '${t}'`);return JSON.parse(X.decode(e))}async _saveTableVersion(t,n){let r=`${this.name}/${t}/_versions/${n.version}.manifest`;await N.save(r,z.encode(JSON.stringify(n)))}async _createVersion(t,n){let r=this.tables.get(t);if(!r)return 0;let e=await this._getLatestVersion(t),s=e+1,l={version:s,timestamp:Date.now(),parentVersion:e,operation:n,schema:r.schema,fragments:[...r.fragments],deletionVector:[...r.deletionVector],rowCount:r.rowCount,nextRowId:r.nextRowId};return await this._saveTableVersion(t,l),await this._setLatestVersion(t,s),s}async listVersions(t){let n=await this._getLatestVersion(t),r=[];for(let e=1;e<=n;e++)try{let s=await this._loadTableVersion(t,e);r.push({version:s.version,timestamp:s.timestamp,operation:s.operation,rowCount:s.rowCount})}catch{}return r}async selectAtVersion(t,n,r={}){let e=await this._loadTableVersion(t,n),s=new Set(e.deletionVector),l=this.tables.get(t),o=[];for(let c of e.fragments){let f=await N.load(c);if(f){let h=this._parseFragment(f,e.schema);for(let p of h)s.has(p.__rowId)||o.push(p)}}let a=o;if(r.where&&(a=a.filter(r.where)),r.orderBy){let{column:c,desc:f}=r.orderBy;a.sort((h,p)=>{let m=h[c]<p[c]?-1:h[c]>p[c]?1:0;return f?-m:m})}r.offset&&(a=a.slice(r.offset)),r.limit&&(a=a.slice(0,r.limit));let i=r.columns&&r.columns.length>0&&r.columns[0]!=="*"?r.columns:null;return a.map(c=>{if(i){let f={};for(let h of i)f[h]=c[h];return f}else{let{__rowId:f,...h}=c;return h}})}async restoreToVersion(t,n){let r=await this._loadTableVersion(t,n),e=await this._getLatestVersion(t),s=e+1,l={...r,version:s,timestamp:Date.now(),parentVersion:e,operation:`RESTORE_FROM_${n}`};await this._saveTableVersion(t,l),await this._setLatestVersion(t,s);let o=this.tables.get(t);return o&&(o.fragments=[...r.fragments],o.deletionVector=[...r.deletionVector],o.rowCount=r.rowCount,o.nextRowId=r.nextRowId,this._columnarBuffer.delete(t),this._writeBuffer.delete(t),await this._saveManifest()),{restored:!0,newVersion:s}}async createTable(t,n,r=!1){if(this.tables.has(t)){if(r)return{success:!0,existed:!0};throw new Error(`Table '${t}' already exists`)}let e=n.map(l=>({name:l.name,type:Me[(l.dataType||l.type)?.toUpperCase()]||l.dataType||l.type||"string",primaryKey:l.primaryKey||!1,vectorDim:l.vectorDim||null})),s={name:t,schema:e,fragments:[],deletionVector:[],rowCount:0,nextRowId:0,version:0,createdAt:Date.now()};return this.tables.set(t,s),await this._saveManifest(),await this._createVersion(t,"CREATE"),{success:!0,table:t}}async dropTable(t,n=!1){if(!this.tables.has(t)){if(n)return this._writeBuffer.delete(t),{success:!0,existed:!1};throw new Error(`Table '${t}' does not exist`)}let r=this.tables.get(t);this._writeBuffer.delete(t);for(let e of r.fragments)this._readCache.delete(e),await N.delete(e);return this.tables.delete(t),await this._saveManifest(),{success:!0,table:t}}async insert(t,n){if(!this.tables.has(t))throw new Error(`Table '${t}' does not exist`);let r=this.tables.get(t),e=n.length;if(!this._columnarBuffer.has(t)){let a=Math.max(1024,e*2),i={__rowId:new Float64Array(a),__length:0,__capacity:a,__schema:r.schema};for(let c of r.schema){let f=(c.dataType||c.type||"").toLowerCase();f==="text"||f==="string"||f==="varchar"?i[c.name]=new Array(a):f==="int64"||f==="bigint"?i[c.name]=new BigInt64Array(a):i[c.name]=new Float64Array(a)}this._columnarBuffer.set(t,i)}let s=this._columnarBuffer.get(t),l=s.__length,o=s.__capacity;if(l+e>o){let a=Math.max(o*2,l+e),i=new Float64Array(a);i.set(s.__rowId.subarray(0,l)),s.__rowId=i;for(let c of r.schema){let f=s[c.name];if(f instanceof Float64Array){let h=new Float64Array(a);h.set(f.subarray(0,l)),s[c.name]=h}else if(f instanceof BigInt64Array){let h=new BigInt64Array(a);h.set(f.subarray(0,l)),s[c.name]=h}else s[c.name].length=a}s.__capacity=a}for(let a=0;a<e;a++){let i=n[a];s.__rowId[l+a]=r.nextRowId++;for(let c of r.schema){let f=i[c.name];s[c.name]instanceof Float64Array?s[c.name][l+a]=f!=null?Number(f):NaN:s[c.name]instanceof BigInt64Array?s[c.name][l+a]=f!=null?BigInt(f):0n:s[c.name][l+a]=f??null}}return s.__length=l+e,r.rowCount+=e,r.version=(r.version||0)+1,this._scheduleFlush(),s.__length>=this._flushThreshold&&await this._flushTable(t),{success:!0,inserted:e}}_scheduleFlush(){this._flushTimer||(this._flushTimer=setTimeout(()=>{this._flushTimer=null,this.flush().catch(t=>console.warn("[WorkerDatabase] Flush error:",t))},this._flushInterval))}async flush(){if(!this._flushing){this._flushing=!0;try{let t=[...this._columnarBuffer.keys()];for(let n of t)await this._flushTable(n)}finally{this._flushing=!1}}}async _flushTable(t){let n=this._columnarBuffer.get(t),r=n?.__length||0;if(!n||r===0)return;let e=this.tables.get(t);if(!e)return;let s=[{name:"__rowId",type:"int64",dataType:"float64",primaryKey:!0},...e.schema.filter(c=>c.name!=="__rowId").map(c=>{let f=(c.dataType||c.type||"").toLowerCase();return f==="int64"||f==="bigint"?{...c,dataType:"int64"}:{...c,dataType:f==="float64"||f==="float32"||f==="int32"||f==="integer"||f==="real"||f==="double"?"float64":c.dataType||c.type||"float64"}})],l={};for(let c of s){let f=n[c.name];f&&(f instanceof Float64Array||f instanceof BigInt64Array?l[c.name]=f.subarray(0,r):l[c.name]=f.slice(0,r))}n.__length=0;let o=new we(s);o.setColumnarData(l);let a=o.build(),i=`${this.name}/${t}/frag_${Date.now()}_${Math.random().toString(36).slice(2)}.lance`;await N.save(i,a),e.fragments.push(i),await this._saveManifest(),await this._createVersion(t,"INSERT")}async delete(t,n){if(!this.tables.has(t))throw new Error(`Table '${t}' does not exist`);let r=this.tables.get(t),e=0,s=this._columnarBuffer.get(t),l=s?.__length||0;if(s&&l>0){let o=r.schema.map(a=>a.name);for(let a=0;a<l;a++){let i={__rowId:s.__rowId[a]};for(let c of o){let f=s[c][a];i[c]=Number.isNaN(f)?null:f}n(i)&&(r.deletionVector.includes(s.__rowId[a])||(r.deletionVector.push(s.__rowId[a]),e++))}}for(let o of r.fragments){let a=await N.load(o);if(a){let i=this._parseFragment(a,r.schema);for(let c of i)!r.deletionVector.includes(c.__rowId)&&n(c)&&(r.deletionVector.push(c.__rowId),e++)}}return r.rowCount-=e,r.version=(r.version||0)+1,await this._saveManifest(),e>0&&await this._createVersion(t,"DELETE"),{success:!0,deleted:e}}async update(t,n,r){if(!this.tables.has(t))throw new Error(`Table '${t}' does not exist`);let e=this.tables.get(t),s=0,l=this._writeBuffer.get(t);if(l&&l.length>0)for(let a of l)r(a)&&(Object.assign(a,n),s++);let o=[];for(let a of e.fragments){let i=await N.load(a);if(i){let c=this._parseFragment(i,e.schema);for(let f of c)if(!e.deletionVector.includes(f.__rowId)&&r(f)){e.deletionVector.push(f.__rowId),e.rowCount--;let h={...f,...n};delete h.__rowId,o.push(h),s++}}}return o.length>0?await this.insert(t,o):await this._saveManifest(),s>0&&o.length===0&&await this._createVersion(t,"UPDATE"),{success:!0,updated:s}}async updateWithExpr(t,n,r,e){if(!this.tables.has(t))throw new Error(`Table '${t}' does not exist`);let s=this.tables.get(t),l=0,o=this._columnarBuffer.get(t),a=o?.__length||0;if(o&&a>0){let c=s.schema.map(f=>f.name);for(let f=0;f<a;f++){let h={__rowId:o.__rowId[f]};for(let p of c){let m=o[p][f];h[p]=Number.isNaN(m)?null:m}if(r(h)){for(let[p,m]of Object.entries(n)){let d=e(m,h);o[p]!==void 0&&(o[p][f]=d??(o[p]instanceof Float64Array?NaN:null))}s.version=(s.version||0)+1,l++}}}let i=[];for(let c of s.fragments){let f=await N.load(c);if(f){let h=this._parseFragment(f,s.schema);for(let p of h)if(!s.deletionVector.includes(p.__rowId)&&r(p)){s.deletionVector.push(p.__rowId),s.rowCount--;let m={...p};for(let[d,w]of Object.entries(n))m[d]=e(w,p);delete m.__rowId,i.push(m),l++}}}return i.length>0?await this.insert(t,i):await this._saveManifest(),l>0&&i.length===0&&await this._createVersion(t,"UPDATE"),{success:!0,updated:l}}async select(t,n={}){if(!this.tables.has(t))throw new Error(`Table '${t}' does not exist`);let r=await this._readAllRows(t);if(n.where&&(r=r.filter(n.where)),n.orderBy){let{column:l,desc:o}=n.orderBy;r.sort((a,i)=>{let c=a[l]<i[l]?-1:a[l]>i[l]?1:0;return o?-c:c})}n.offset&&(r=r.slice(n.offset)),n.limit&&(r=r.slice(0,n.limit));let e=n.columns&&n.columns.length>0&&n.columns[0]!=="*"?n.columns:null,s=new Array(r.length);for(let l=0;l<r.length;l++){let o=r[l];if(e){let a={};for(let i of e)a[i]=o[i];s[l]=a}else{let{__rowId:a,...i}=o;s[l]=i}}return s}async _readAllRows(t){let n=this.tables.get(t),r=this._columnarBuffer.get(t),s=n.deletionVector.length>0?new Set(n.deletionVector):null,l=[];for(let a of n.fragments){let i=this.bufferPool.get(a),c=null;if(!i){let f=await N.load(a);f&&(i=le(f),i?this.bufferPool.set(a,i,f.byteLength):c=this._parseFragment(f,n.schema))}if(i&&!c&&(c=this._hydrateRowsFromBinary(i,n.schema)),c=c||[],!s)l.push(...c);else for(let f of c)s.has(f.__rowId)||l.push(f)}let o=r?.__length||0;if(r&&o>0){let a=n.schema.map(i=>i.name);for(let i=0;i<o;i++){if(s&&s.has(r.__rowId[i]))continue;let c={__rowId:r.__rowId[i]};for(let f of a){let h=r[f][i];c[f]=Number.isNaN(h)?null:h}l.push(c)}}return l}_hydrateRowsFromBinary(t,n){let{columns:r,rowCount:e}=t,s=n.map(o=>o.name),l=new Array(e);for(let o=0;o<e;o++){let a={__rowId:r.__rowId[o]};for(let i of s)r[i]&&(a[i]=r[i][o]);l[o]=a}return l}_parseFragment(t,n){try{let r=le(t);if(r)return this._parseBinaryColumnar(r);let e=X.decode(t),s=JSON.parse(e);return s.format==="json"&&s.columns?this._parseJsonColumnar(s):Array.isArray(s)?s:[s]}catch(r){return console.warn("[WorkerDatabase] Failed to parse fragment:",r),[]}}async selectColumnar(t){let n=this.tables.get(t);if(!n)return null;let r=this._columnarBuffer.get(t)?.__length||0,e=`${n.fragments.length}:${r}:${n.deletionVector.length}:${n.version||0}`,s=this._columnarCache.get(t);if(s&&s.version===e){let d={};for(let[w,g]of Object.entries(s.data.columns))ArrayBuffer.isView(g)?d[w]=new g.constructor(g.buffer,g.byteOffset,g.length):d[w]=g;return{schema:n.schema,columns:d,rowCount:s.data.rowCount}}let o=n.deletionVector.length>0?new Set(n.deletionVector):null,a={},i=n.schema.map(d=>d.name);for(let d of i)a[d]=[];a.__rowId=[];for(let d of n.fragments){let w=this.bufferPool.get(d);if(!w){let y=await N.load(d);if(!y)continue;w=le(y),w&&this.bufferPool.set(d,w,y.byteLength)}if(!w)continue;let{columns:g,rowCount:A}=w;if(o){let y=g.__rowId,b=[];for(let F=0;F<A;F++)o.has(y[F])||b.push(F);for(let F of i)if(g[F]){let S=g[F],_=new S.constructor(b.length);for(let T=0;T<b.length;T++)_[T]=S[b[T]];a[F].push(_)}}else{for(let y of i)g[y]&&a[y].push(g[y]);g.__rowId&&a.__rowId.push(g.__rowId)}}let c=this._columnarBuffer.get(t),f=c?.__length||0;if(c&&f>0)if(o){let d=[];for(let A=0;A<f;A++)o.has(c.__rowId[A])||d.push(A);let w=d.length;for(let A of n.schema){let y=c[A.name];if(y)if(y instanceof Float64Array){let b=new Float64Array(w);for(let F=0;F<w;F++)b[F]=y[d[F]];a[A.name].push(b)}else a[A.name].push(d.map(b=>y[b]))}let g=new Float64Array(w);for(let A=0;A<w;A++)g[A]=c.__rowId[d[A]];a.__rowId.push(g)}else{for(let w of n.schema){let g=c[w.name];if(g)if(g instanceof Float64Array){let A=new Float64Array(f);A.set(g.subarray(0,f)),a[w.name].push(A)}else a[w.name].push(g.slice(0,f))}let d=new Float64Array(f);d.set(c.__rowId.subarray(0,f)),a.__rowId.push(d)}let h={},p=0;for(let d of[...i,"__rowId"]){let w=a[d];if(w.length===0)h[d]=new Float64Array(0);else if(w.length===1)h[d]=w[0],p===0&&(p=w[0].length);else{let g=w.reduce((F,S)=>F+S.length,0);p===0&&(p=g);let A=w[0],y=ArrayBuffer.isView(A)?new A.constructor(g):new Array(g),b=0;for(let F of w){if(ArrayBuffer.isView(y))y.set(F,b);else for(let S=0;S<F.length;S++)y[b+S]=F[S];b+=F.length}h[d]=y}}let m={schema:n.schema,columns:h,rowCount:p};return this._columnarCache.set(t,{version:e,data:m}),m}async _readColumn(t,n){let r=this.tables.get(t);if(!r)return null;let e=this._writeBuffer.get(t),s=[];for(let i of r.fragments){let c=await N.load(i);if(!c)continue;let f=le(c);if(f&&f.columns[n]){let h=f.columns[n];h.length>0&&s.push(h)}}if(e&&e.length>0){let i=new Float64Array(e.length);for(let c=0;c<e.length;c++){let f=e[c][n];i[c]=typeof f=="number"?f:0}s.push(i)}if(s.length===0)return new Float64Array(0);if(s.length===1)return s[0];let l=s.reduce((i,c)=>i+c.length,0),o=new Float64Array(l),a=0;for(let i of s)o.set(i,a),a+=i.length;return o}_parseBinaryColumnar(t){let{schema:n,columns:r,rowCount:e}=t,s=new Array(e),l=n.map(i=>i.name),o=l.map(i=>r[i]),a=l.length;for(let i=0;i<e;i++){let c={};for(let f=0;f<a;f++)c[l[f]]=o[f][i]??null;s[i]=c}return s}_parseJsonColumnar(t){let{schema:n,columns:r,rowCount:e}=t,s=new Array(e),l=n.map(i=>i.name),o=l.map(i=>r[i]||[]),a=l.length;for(let i=0;i<e;i++){let c={};for(let f=0;f<a;f++)c[l[f]]=o[f][i]??null;s[i]=c}return s}getTable(t){return this.tables.get(t)}listTables(){return Array.from(this.tables.keys())}getFragmentPaths(t){let n=this.tables.get(t);return n?n.fragments:[]}getColumnIndex(t,n){let r=this.tables.get(t);if(!r)return-1;let e=r.schema.findIndex(s=>s.name===n);return e>=0?e+1:-1}hasBufferedData(t){let n=this._columnarBuffer.get(t);return n&&(n.__length||0)>0}async compact(){for(let[t,n]of this.tables){let r=await this._readAllRows(t);for(let e of n.fragments)await N.delete(e);if(n.fragments=[],n.deletionVector=[],n.rowCount=0,n.nextRowId=0,r.length>0){let e=r.map(({__rowId:s,...l})=>l);await this.insert(t,e)}}return{success:!0,compacted:this.tables.size}}async scanStart(t,n={}){if(!this.tables.has(t))throw new Error(`Table '${t}' does not exist`);let r=at++,e=this.tables.get(t),s=new Set(e.deletionVector),l=[];for(let a of e.fragments){let i=await N.load(a);if(i){let c=this._parseFragment(i,e.schema);for(let f of c)s.has(f.__rowId)||l.push(f)}}let o=this._writeBuffer.get(t);if(o)for(let a of o)s.has(a.__rowId)||l.push(a);return Te.set(r,{rows:l,index:0,batchSize:n.batchSize||1e4,columns:n.columns}),r}scanNext(t){let n=Te.get(t);if(!n)return{batch:[],done:!0};let r=[],e=Math.min(n.index+n.batchSize,n.rows.length);for(let l=n.index;l<e;l++){let o=n.rows[l],a;if(n.columns&&n.columns.length>0&&n.columns[0]!=="*"){a={};for(let i of n.columns)a[i]=o[i]}else{let{__rowId:i,...c}=o;a=c}r.push(a)}n.index=e;let s=n.index>=n.rows.length;return s&&Te.delete(t),{batch:r,done:s}}};var ge=class{constructor(){this._root=null,this._ready=!1,this._kv={},this._encryptionKeyId=null,this._db=null}async open(t=null){if(this._ready)return this;if(t){let{keyId:n,keyBytes:r}=t;if(!Y.has(n)){let e=await fe(r);Y.set(n,e)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle("vault",{create:!0}),await this._loadKV(),this._db=new se("vault"),await this._db.open(),this._ready=!0}catch(n){throw console.error("[WorkerVault] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?Y.get(this._encryptionKeyId):null}async _loadKV(){try{let t=this._getCryptoKey(),n=t?"_vault.json.enc":"_vault.json",e=await(await this._root.getFileHandle(n)).getFile();if(t){let s=await e.arrayBuffer();this._kv=await he(new Uint8Array(s),t)}else{let s=await e.text();this._kv=JSON.parse(s)}}catch(t){if(t.name==="NotFoundError")this._kv={};else throw t}}async _saveKV(){let t=this._getCryptoKey(),n=t?"_vault.json.enc":"_vault.json",e=await(await this._root.getFileHandle(n,{create:!0})).createWritable();if(t){let s=await ue(this._kv,t);await e.write(s)}else await e.write(JSON.stringify(this._kv));await e.close()}async get(t){return this._kv[t]}async set(t,n){this._kv[t]=n,await this._saveKV()}async delete(t){delete this._kv[t],await this._saveKV()}async keys(){return Object.keys(this._kv)}async has(t){return t in this._kv}};var it=1;var Ge={INT64:0,FLOAT64:1,INT32:2,FLOAT32:3,STRING:4,LIST:5},$e=class{constructor(){this._registered=new Map}getLastError(){let t=Q();if(!t)return"WASM not loaded";let n=J(),r=t.alloc(4096);console.log(`[WASM LOG] getLastError alloc ptr: ${r}`);let e=t.getLastError(r,4096);if(console.log(`[WASM LOG] getLastError len: ${e}`),e===0)return"Unknown Error";let s=new Uint8Array(n.buffer,r,e),l=new TextDecoder().decode(s);return console.log(`[WASM LOG] getLastError msg: ${l}`),l}getTableNames(t){let n=Q();if(!n)throw new Error("WASM not loaded");let r=J(),e=new TextEncoder().encode(t),s=n.alloc(e.length);new Uint8Array(r.buffer,s,e.length).set(e);let l=n.getTableNames(s,e.length);if(l===0)return[];let o=new Uint8Array(r.buffer,l),a=0;for(;o[a]!==0&&a<1024;)a++;let i=new TextDecoder().decode(o.subarray(0,a));return i?i.split(",").filter(c=>c):[]}hasTable(t){let n=Q();if(!n)return!1;let r=J(),e=new TextEncoder().encode(t),s=n.alloc(e.length);return new Uint8Array(r.buffer,s,e.length).set(e),n.hasTable(s,e.length)===1}registerTable(t,n,r,e=""){let s=Q();if(!s)throw new Error("WASM not loaded");let l=this._registered.get(t);if(l&&l.version===e)return;if(l){let f=new TextEncoder().encode(t);s.clearTable(f,f.length)}let o=J();if(!o||!o.buffer)throw new Error("WASM memory not available");let a=new TextEncoder().encode(t),i=s.alloc(a.length);if(i<0||i>=o.buffer.byteLength)throw new Error(`Invalid alloc result: ${i} for ${a.length} bytes`);new Uint8Array(o.buffer,i,a.length).set(a);let c=new Set;for(let[f,h]of Object.entries(n)){if(f.startsWith("__")||Array.isArray(h)&&h.length===0)continue;let p=new TextEncoder().encode(f),m=s.alloc(p.length);if(m<0||m>=o.buffer.byteLength)throw new Error(`Invalid colName alloc: ${m}`);if(new Uint8Array(o.buffer,m,p.length).set(p),h instanceof Float64Array){let d=s.allocFloat64Buffer(h.length);if(d===0||d<0||d>=o.buffer.byteLength)throw new Error(`Invalid Float64 alloc: ${d} for ${h.length} elements`);new Float64Array(o.buffer,d,h.length).set(h),s.registerTableFloat64(i,a.length,m,p.length,d,h.length),c.add(f)}else if(h instanceof BigInt64Array){let d=s.allocInt64Buffer(h.length);new BigInt64Array(o.buffer,d,h.length).set(h),s.registerTableInt64(i,a.length,m,p.length,d,h.length),c.add(f)}else if(h instanceof Int32Array){let d=new Float64Array(h.length);for(let g=0;g<h.length;g++)d[g]=h[g];let w=s.allocFloat64Buffer(d.length);new Float64Array(o.buffer,w,d.length).set(d),s.registerTableFloat64(i,a.length,m,p.length,w,d.length),c.add(f)}else if(h instanceof Float32Array){let d=`__${f}_dim`,w=n[d]||0,g=w>0?Math.floor(h.length/w):h.length,A=s.allocFloat32Buffer?s.allocFloat32Buffer(h.length):null;A?(new Float32Array(o.buffer,A,h.length).set(h),s.registerTableFloat32Vector?(s.registerTableFloat32Vector(i,a.length,m,p.length,A,g,w),console.log(`[Bridge] Registered vector column ${f}: ${g} rows, dim=${w}`)):console.warn(`[Bridge] No registerTableFloat32Vector, skipping ${f}`),c.add(f)):console.warn(`[Bridge] Failed to alloc Float32 buffer for ${f}`)}else if(Array.isArray(h)){let d=new Uint32Array(h.length),w=new Uint32Array(h.length),g=new TextEncoder,A=[],y=0;for(let $=0;$<h.length;$++){let C=String(h[$]||""),E=g.encode(C);A.push(E),w[$]=E.length,d[$]=y,y+=E.length}let b=new Uint8Array(y),F=0;for(let $=0;$<A.length;$++)b.set(A[$],F),F+=A[$].length;let S=s.alloc(d.byteLength);if(S<0||S>=o.buffer.byteLength)throw new Error(`Invalid offsetsPtr alloc: ${S}`);new Uint32Array(o.buffer,S,d.length).set(d);let _=s.alloc(w.byteLength);if(_<0||_>=o.buffer.byteLength)throw new Error(`Invalid lengthsPtr alloc: ${_}`);new Uint32Array(o.buffer,_,w.length).set(w);let T=s.alloc(b.length||1);if(T<0||T>=o.buffer.byteLength)throw new Error(`Invalid dataPtr alloc: ${T}`);new Uint8Array(o.buffer,T,b.length).set(b),s.registerTableString(i,a.length,m,p.length,S,_,T,y,h.length),c.add(f)}}this._registered.set(t,{version:e,columns:c,rowCount:r})}registerTableFromFiles(t,n,r=""){let e=Q();if(!e)throw new Error("WASM not loaded");let s=this._registered.get(t);if(s&&s.version===r)return;if(s){let i=new TextEncoder().encode(t);e.clearTable(i,i.length)}let l=new TextEncoder,o=l.encode(t),a=e.alloc(o.length);new Uint8Array(J().buffer,a,o.length).set(o);for(let i of n){let c=l.encode(i),f=e.alloc(c.length);new Uint8Array(J().buffer,f,c.length).set(c);let h=e.registerTableFromOPFS(a,o.length,f,c.length);h!==0&&console.warn(`Failed to register fragment ${i} for table ${t}: error ${h}`)}this._registered.set(t,{version:r,type:"files"})}appendTableMemory(t,n,r){let e=Q();if(!e)throw new Error("WASM not loaded");let s=J(),l=new TextEncoder().encode(t),o=e.alloc(l.length);new Uint8Array(s.buffer,o,l.length).set(l);for(let[a,i]of Object.entries(n)){if(a.startsWith("__"))continue;let c=new TextEncoder().encode(a),f=e.alloc(c.length);if(new Uint8Array(s.buffer,f,c.length).set(c),i instanceof Float64Array){let h=e.allocFloat64Buffer(i.length);new Float64Array(s.buffer,h,i.length).set(i),e.appendTableMemory(o,l.length,f,c.length,h,4,r)}else if(i instanceof BigInt64Array){let h=e.allocInt64Buffer(i.length);new BigInt64Array(s.buffer,h,i.length).set(i),e.appendTableMemory(o,l.length,f,c.length,h,2,r)}else if(i instanceof Int32Array){let h=e.alloc(i.byteLength);new Int32Array(s.buffer,h,i.length).set(i),e.appendTableMemory(o,l.length,f,c.length,h,1,r)}else if(i instanceof Float32Array){let h=e.alloc(i.byteLength);new Float32Array(s.buffer,h,i.length).set(i),e.appendTableMemory(o,l.length,f,c.length,h,3,r)}}}execute(t){let n=Q();if(!n)throw new Error("WASM not loaded");let r=J();if(n.setCurrentTimestamp)try{n.setCurrentTimestamp(BigInt(Date.now()))}catch(h){console.warn("setCurrentTimestamp failed:",h)}let e=n.getSqlInputBuffer(),s=n.getSqlInputBufferSize(),l=new TextEncoder().encode(t);if(l.length>s)throw new Error(`SQL too long: ${l.length} > ${s}`);new Uint8Array(r.buffer,e,l.length).set(l),n.setSqlInputLength(l.length);let o=n.executeSql();if(o===0){let h=this.getLastError();throw console.log(`[WASM LOG] execute throwing: "${h}"`),new Error(h)}let a=n.getResultSize(),i=this.getLastError();i&&i.length>0&&console.log(`[WASM DEBUG CAPTURED] ${i}`),i.length>0&&i.startsWith("DEBUG:");let c=n.memory.buffer,f=this._parseResult(r.buffer,o,a);return n.resetResult(),f}_parseResult(t,n,r){let e=new DataView(t,n,r),s=new TextDecoder;if(r>=40){let l=r-40,o=[e.getUint8(l+36),e.getUint8(l+37),e.getUint8(l+38),e.getUint8(l+39)];if(String.fromCharCode(...o)==="LANC")return this._parseLanceResult(t,n,r,l,e,s)}if(r>=36&&e.getUint32(0,!0)===it)return this._parseLegacyResult(t,n,r);throw new Error(`Invalid result format (Size: ${r}). Not a Lance file.`)}_parseLanceResult(t,n,r,e,s,l){let o=Number(s.getBigUint64(e+8,!0)),a=s.getUint32(e+28,!0),i=[],c={},f=0;for(let h=0;h<a;h++){let p=o+h*8,d=Number(s.getBigUint64(p,!0));s.getUint8(d++);let[w,g]=this._readVarint(s,d);d+=g;let A=new Uint8Array(t,n+d,w),y=l.decode(A);d+=w,i.push(y),s.getUint8(d++);let[b,F]=this._readVarint(s,d);d+=F;let S=new Uint8Array(t,n+d,b),_=l.decode(S);d+=b,s.getUint8(d++);let[T,$]=this._readVarint(s,d);d+=$,s.getUint8(d++);let C=Number(s.getBigUint64(d,!0));d+=8,s.getUint8(d++);let[E,x]=this._readVarint(s,d);d+=x,f=E,s.getUint8(d++);let[B,H]=this._readVarint(s,d);d+=H;let D=n+C;if(_==="float64"||_==="int64"||_==="int32"||_==="float32")if(_==="float64"){let v=new Float64Array(t,D,E).slice(),W=!1;for(let I=0;I<E;I++)if(Number.isNaN(v[I])){W=!0;break}if(W){console.log(`[WASM LOG] Column ${y} has NaNs, converting to nulls`);let I=new Array(E);for(let k=0;k<E;k++){let O=v[k];I[k]=Number.isNaN(O)?null:O}c[y]=I}else c[y]=v}else if(_==="int64"){let v=new BigInt64Array(t,D,E),W=new Array(E),I=-9223372036854775808n;for(let k=0;k<E;k++){let O=v[k];W[k]=O===I?null:Number(O)}c[y]=W}else if(_==="int32"){let v=new Int32Array(t,D,E),W=new Array(E);for(let I=0;I<E;I++){let k=v[I];k===-2147483648?W[I]=null:W[I]=k}c[y]=W}else{let v=new Float32Array(t,D,E),W=new Array(E);for(let I=0;I<E;I++){let k=v[I];W[I]=isNaN(k)?null:k}c[y]=W}else if(_==="string"||_==="list"){let v=_==="list",W=(E+1)*4,I=B-W,k=new Uint8Array(t,D,I).slice(),O=new Uint32Array(t,D+I,E+1).slice();c[y]={_arrowString:!0,offsets:O,bytes:k,isList:_==="list",nullable:T===1}}}return{_format:"columnar",columns:i,rowCount:f,data:c}}_readVarint(t,n){let r=0,e=0,s=0;for(;;){let l=t.getUint8(n+s);if(s++,r|=(l&127)<<e,(l&128)===0)break;e+=7}return[r,s]}_parseLegacyResult(t,n,r){let e=new DataView(t,n,r),s=new TextDecoder,l=e.getUint32(4,!0),o=Number(e.getBigUint64(8,!0)),a=e.getUint32(24,!0),i=e.getUint32(32,!0),c=[],f={};for(let h=0;h<l;h++){let p=36+h*16,m=e.getUint32(p,!0),d=e.getUint32(p+4,!0),w=e.getUint32(p+8,!0),g=e.getUint32(p+12,!0),A=new Uint8Array(t,n+i+d,w),y=s.decode(A);c.push(y);let b=Object.keys(Ge).find(S=>Ge[S]===m).toLowerCase(),F=n+a+g;if(b==="float64"||b==="int64"||b==="int32"||b==="float32")b==="float64"?f[y]=new Float64Array(t,F,o).slice():b==="int64"?f[y]=new Float64Array(t,F,o).slice():b==="int32"?f[y]=new Int32Array(t,F,o).slice():b==="float32"&&(f[y]=new Float32Array(t,F,o).slice());else if(b==="string"||b==="list"){let S=new Uint32Array(o+1),_=0;S[0]=0;let T=F,$=0;for(let x=0;x<o;x++){let B=e.getUint32(T+x*8+4,!0);$+=B,S[x+1]=$}let C=F+o*8,E=new Uint8Array(t,C,$).slice();f[y]={_arrowString:!0,offsets:S,bytes:E,isList:b==="list"}}}return{_format:"columnar",columns:c,rowCount:o,data:f}}clear(){let t=Q();t&&t.clearTables(),this._registered.clear()}},Fe=null;function Le(){return Fe||(Fe=new $e),Fe}var Ee={showVersions:/^\s*SHOW\s+VERSIONS\s+FOR\s+(\w+)\s*$/i,restoreTable:/^\s*RESTORE\s+(\w+)\s+TO\s+VERSION\s+(\d+)\s*$/i,versionAsOf:/FROM\s+(\w+)\s+VERSION\s+AS\s+OF\s+(\d+)/i};function ze(u){let t;return(t=u.match(Ee.showVersions))?{type:"SHOW_VERSIONS",table:t[1]}:(t=u.match(Ee.restoreTable))?{type:"RESTORE_TABLE",table:t[1],version:parseInt(t[2],10)}:(t=u.match(Ee.versionAsOf))?{type:"SELECT_VERSION",table:t[1],version:parseInt(t[2],10),sql:u}:null}function lt(u){let t=/^(SELECT|FROM|WHERE|JOIN|LEFT|RIGHT|INNER|OUTER|ON|AND|OR|NOT|IN|LIKE|BETWEEN|GROUP|ORDER|BY|HAVING|LIMIT|OFFSET|UNION|EXCEPT|INTERSECT|AS|NULL|TRUE|FALSE|IS|CASE|WHEN|THEN|ELSE|END|DISTINCT|ALL|ASC|DESC|CREATE|DROP|INSERT|UPDATE|DELETE|INTO|VALUES|TABLE|INDEX|VIEW|SET|WITH|RECURSIVE)$/i,n=/read_lance\s*\(\s*'([^']+)'\s*\)(?:\s+AS\s+(\w+)|\s+(\w+))?/gi,r=[],e;for(;(e=n.exec(u))!==null;){let s=e[2],l=e[3];l&&t.test(l)&&(l=null);let o=s||l||`_tbl${r.length}`,a=e[0];e[3]&&t.test(e[3])&&(a=`read_lance('${e[1]}')`),console.log(`[Worker] extractReadLanceUrls: found "${a}" -> alias "${o}"`),r.push({fullMatch:a,url:e[1],alias:o})}return console.log(`[Worker] extractReadLanceUrls: found ${r.length} URLs`),r}function ct(u,t){let n=u;for(let{fullMatch:r,alias:e}of t)console.log(`[Worker] rewriteSqlWithAliases: replacing "${r}" with "${e}"`),n=n.replace(r,e);return console.log(`[Worker] rewriteSqlWithAliases: result = "${n}"`),n}async function ft(u,t=1e4){try{console.log(`[Worker] Fetching remote Lance: ${u}`);let n=`${u}/.meta.json`,r=null,e=[],s=[];try{let i=await fetch(n);if(i.ok){let c=await i.json();r=c.schema,e=c.fragments||[],s=r.map(f=>{let h=f.type;if(h.startsWith("vector[")){let p=h.match(/vector\[(\d+)\]/);return{type:"vector",dim:p?parseInt(p[1],10):0}}return h==="float64"||h==="double"?"float64":h==="float32"?"float32":h.includes("int64")?"int64":h.includes("int")?"int32":h==="string"?"string":"unknown"}),console.log(`[Worker] Loaded sidecar: ${r.length} columns, ${e.length} fragments`)}}catch(i){console.log(`[Worker] No sidecar available: ${i.message}`)}if(!r){let i=0,c=[1,5,10,20,50,100];for(let m of c)try{(await fetch(`${u}/_versions/${m}.manifest`,{method:"HEAD"})).ok&&(i=m)}catch{}if(i>0)for(let m=i+1;m<=i+50;m++)try{if((await fetch(`${u}/_versions/${m}.manifest`,{method:"HEAD"})).ok)i=m;else break}catch{break}if(i===0)return console.error(`[Worker] No manifest found for ${u}`),null;let f=await fetch(`${u}/_versions/${i}.manifest`);if(!f.ok)return null;let h=new Uint8Array(await f.arrayBuffer()),p=ut(h);r=p.schema,e=p.fragments,s=r.map(m=>m.type||"unknown")}if(!r||r.length===0)return console.error(`[Worker] No schema found for ${u}`),null;if(e.length===0)return console.error(`[Worker] No fragments found for ${u}`),null;let l=e[0].data_files?.[0]||`${e[0].id}.lance`,o=`${u}/data/${l}`;return await wt(o,r,s,t)}catch(n){return console.error("[Worker] Failed to fetch remote Lance:",n),null}}function ut(u){let t=new DataView(u.buffer,u.byteOffset),n=[],r=[],e=t.getUint32(0,!0),s=4+e,l;if(s+4<u.length){let c=t.getUint32(s,!0);c>0&&s+4+c<=u.length?l=u.slice(s+4,s+4+c):l=u.slice(4,4+e)}else l=u.slice(4,4+e);let o=0,a=()=>{let c=0,f=0;for(;o<l.length;){let h=l[o++];if(c|=(h&127)<<f,(h&128)===0)break;f+=7}return c},i=c=>{c===0?a():c===2?o+=a():c===5?o+=4:c===1&&(o+=8)};for(;o<l.length;){let c=a(),f=c>>3,h=c&7;if(f===1&&h===2){let p=a(),m=o+p,d=null,w=null,g=null;for(;o<m;){let A=a(),y=A>>3,b=A&7;if(b===0){let F=a();y===3&&(w=F)}else if(b===2){let F=a(),S=l.slice(o,o+F);o+=F,y===2?d=new TextDecoder().decode(S):y===5&&(g=new TextDecoder().decode(S))}else i(b)}d&&n.push({name:d,id:w,type:g})}else if(f===2&&h===2){let p=a(),m=o+p,d=null,w=null,g=0;for(;o<m;){let A=a(),y=A>>3,b=A&7;if(b===0){let F=a();y===1?d=F:y===4&&(g=F)}else if(b===2){let F=a(),S=l.slice(o,o+F);if(o+=F,y===2){let _=0;for(;_<S.length;){let T=S[_++],$=T>>3,C=T&7;if(C===2){let E=0,x=0;for(;_<S.length;){let B=S[_++];if(E|=(B&127)<<x,(B&128)===0)break;x+=7}$===1&&(w=new TextDecoder().decode(S.slice(_,_+E))),_+=E}else if(C===0)for(;_<S.length&&(S[_++]&128)!==0;);else C===5?_+=4:C===1&&(_+=8)}}}else i(b)}w&&r.push({id:d,data_files:[w],num_rows:g})}else i(h)}return{schema:n,fragments:r}}async function q(u,t,n){let r=await fetch(u,{headers:{Range:`bytes=${t}-${n}`}});if(!r.ok&&r.status!==206)throw new Error(`Range request failed: HTTP ${r.status}`);return new Uint8Array(await r.arrayBuffer())}function j(u,t){let n=0,r=0,e=0;for(;t+e<u.length;){let s=u[t+e];if(e++,n|=(s&127)<<r,(s&128)===0)break;r+=7}return{value:n,bytesRead:e}}function ht(u){let t=[],n=[],r=0,e=0;for(;e<u.length;){let{value:s,bytesRead:l}=j(u,e);e+=l;let o=s>>3,a=s&7;if(o===2&&a===2){let{value:i,bytesRead:c}=j(u,e);e+=c;let f=e+i;for(;e<f;){let{value:h,bytesRead:p}=j(u,e);e+=p;let m=h>>3,d=h&7;if(m===1&&d===2){let{value:w,bytesRead:g}=j(u,e);e+=g;let A=e+w;for(;e<A;){let{value:y,bytesRead:b}=j(u,e);e+=b,t.push(y)}}else if(m===2&&d===2){let{value:w,bytesRead:g}=j(u,e);e+=g;let A=e+w;for(;e<A;){let{value:y,bytesRead:b}=j(u,e);e+=b,n.push(y)}}else if(m===3&&d===0){let{value:w,bytesRead:g}=j(u,e);e+=g,r=w}else if(d===0){let{bytesRead:w}=j(u,e);e+=w}else if(d===2){let{value:w,bytesRead:g}=j(u,e);e+=g+w}else d===5?e+=4:d===1&&(e+=8)}break}else if(a===0){let{bytesRead:i}=j(u,e);e+=i}else if(a===2){let{value:i,bytesRead:c}=j(u,e);e+=c+i}else a===5?e+=4:a===1&&(e+=8)}return{bufferOffsets:t,bufferSizes:n,length:r}}async function dt(u,t,n,r,e){let l=await q(u,e-40,e-1),o=new DataView(l.buffer),a=String.fromCharCode(l[36],l[37],l[38],l[39]);if(a!=="LANC")throw new Error(`Invalid Lance magic: ${a}`);let i=Number(o.getBigUint64(0,!0)),c=Number(o.getBigUint64(8,!0)),f=o.getUint32(28,!0);console.log(`[Worker] Range: footer parsed - ${f} columns, metaStart=${i}, offsetsStart=${c}`);let h=f*16,p=await q(u,c,c+h-1),m=new DataView(p.buffer),d=[];for(let _=0;_<f;_++){let T=Number(m.getBigUint64(_*16,!0)),$=Number(m.getBigUint64(_*16+8,!0));d.push({pos:T,len:$})}let w=d[0]?.pos||i,g=c-1,A=await q(u,w,g),y={},b=[],F=0;for(let _=0;_<t.length&&_<f;_++){let T=t[_].name,$=n[_];b.push(T);let C=d[_].pos-w,E=d[_].len,x=A.slice(C,C+E),{bufferOffsets:B,bufferSizes:H,length:D}=ht(x);_===0&&(F=D);let v=Math.min(D,r),W=typeof $=="object"?`${$.type}[${$.dim}]`:$;console.log(`[Worker] Range: column ${_} (${T}): type=${W}, rows=${D}, buffers=${B.length}`);try{if($==="string"&&B.length>=2){let I=B[0],k=H[0],O=B[1],K=H[1],M=Math.floor(k/D),R=v*M,Xe=await q(u,I,I+R-1),We=new DataView(Xe.buffer),ce=[];for(let ne=0;ne<v;ne++)M===4?ce.push(We.getInt32(ne*4,!0)):ce.push(Number(We.getBigInt64(ne*8,!0)));let et=ce[v-1]||0,Re=Math.min(et,K);if(Re>0){let ne=await q(u,O,O+Re-1),tt=new TextDecoder("utf-8"),Ne=[],Ue=0;for(let pe=0;pe<v;pe++){let Ve=ce[pe],nt=ne.slice(Ue,Ve);Ne.push(tt.decode(nt)),Ue=Ve}y[T]=Ne}else y[T]=Array(v).fill("")}else if(($==="float64"||$==="double")&&B.length>=1){let I=B[0],k=v*8,O=await q(u,I,I+k-1);y[T]=new Float64Array(O.buffer).slice(0,v)}else if($==="int64"&&B.length>=1){let I=B[0],k=v*8,O=await q(u,I,I+k-1),K=new BigInt64Array(O.buffer),M=new Float64Array(v);for(let R=0;R<v;R++)M[R]=Number(K[R]);y[T]=M}else if($==="int32"&&B.length>=1){let I=B[0],k=v*4,O=await q(u,I,I+k-1),K=new Int32Array(O.buffer),M=new Float64Array(v);for(let R=0;R<v;R++)M[R]=K[R];y[T]=M}else if($==="float32"&&B.length>=1){let I=B[0],k=v*4,O=await q(u,I,I+k-1),K=new Float32Array(O.buffer),M=new Float64Array(v);for(let R=0;R<v;R++)M[R]=K[R];y[T]=M}else if(typeof $=="object"&&$.type==="vector"&&$.dim>0&&B.length>=1){let I=$.dim,k=B[0],O=v*I,K=O*4;console.log(`[Worker] Range: Reading vector ${T}: dim=${I}, rows=${v}, bytes=${K}`);let M=await q(u,k,k+K-1),R=new Float32Array(M.buffer,0,O);y[T]=R.slice(),y[`__${T}_dim`]=I}else $==="vector"||typeof $=="string"&&($.includes("list")||$.includes("vector"))?y[T]=new Float32Array(0):y[T]=new Float64Array(v).fill(0)}catch(I){console.warn(`[Worker] Range: Failed to read column ${T}: ${I.message}`),$==="string"?y[T]=Array(v).fill(""):y[T]=new Float64Array(v).fill(0)}}let S=Math.min(F,r);return console.log(`[Worker] Range: Read ${S} rows from ${b.length} columns via HTTP Range requests`),{columns:y,rowCount:S,columnNames:b}}async function wt(u,t,n,r){if(console.log(`[Worker] Fetching fragment: ${u}`),!L&&(await te(),!L))throw new Error("WASM not loaded");let e=await fetch(u,{method:"HEAD"});if(!e.ok)throw new Error(`Failed to check fragment size: HTTP ${e.status}`);let s=parseInt(e.headers.get("Content-Length")||"0",10),l=100*1024*1024;if(s>l)return console.log(`[Worker] Large fragment (${(s/1024/1024).toFixed(1)}MB) - using HTTP Range requests`),await dt(u,t,n,r,s);let o=await fetch(u);if(!o.ok)throw new Error(`Failed to fetch fragment: HTTP ${o.status}`);let a=new Uint8Array(await o.arrayBuffer());if(console.log(`[Worker] Fetched fragment: ${a.length} bytes`),a.length<40)throw new Error("Fragment too small");let i=String.fromCharCode(a[a.length-4],a[a.length-3],a[a.length-2],a[a.length-1]);if(i!=="LANC")throw new Error(`Invalid Lance magic: ${i}`);let c=L.alloc(a.length);if(!c||c<0)throw new Error("Failed to allocate WASM memory for fragment");new Uint8Array(U.buffer,c,a.length).set(a);let f=L.openFile(c,a.length);if(f!==0)throw new Error(`WASM openFile failed: ${f}`);let h=L.getNumColumns(),p=Number(L.getRowCount(0)),m=Math.min(p,r);console.log(`[Worker] Fragment has ${h} columns, ${p} rows, reading ${m}`);let d={},w=[];for(let g=0;g<t.length&&g<h;g++){let A=t[g].name,y=n[g];w.push(A);try{if(y==="float64"||y==="double"){let b=L.allocFloat64Buffer(m);if(b){let F=L.readFloat64Column(g,b,m);d[A]=new Float64Array(U.buffer,b,F).slice()}else d[A]=new Float64Array(m).fill(0)}else if(y==="int64"){let b=L.allocInt64Buffer(m);if(b){let F=L.readInt64Column(g,b,m),S=new BigInt64Array(U.buffer,b,F),_=new Float64Array(F);for(let T=0;T<F;T++)_[T]=Number(S[T]);d[A]=_}else d[A]=new Float64Array(m).fill(0)}else if(y==="int32"){let b=L.allocInt32Buffer(m);if(b){let F=L.readInt32Column(g,b,m),S=new Int32Array(U.buffer,b,F),_=new Float64Array(F);for(let T=0;T<F;T++)_[T]=S[T];d[A]=_}else d[A]=new Float64Array(m).fill(0)}else if(y==="float32"){let b=L.alloc(m*4);if(b&&b>0){let F=L.readFloat32Column(g,b,m),S=new Float32Array(U.buffer,b,F),_=new Float64Array(F);for(let T=0;T<F;T++)_[T]=S[T];d[A]=_}else d[A]=new Float64Array(m).fill(0)}else y==="string"?d[A]=Array(m).fill("(string data)"):y==="vector"?d[A]=[]:d[A]=[]}catch(b){console.warn(`[Worker] Failed to read column ${A}:`,b),d[A]=[]}}return L.closeFile(),console.log(`[Worker] Read ${m} rows from ${w.length} columns`),{columns:d,rowCount:m,columnNames:w}}async function qe(u,t=1e4){try{console.log(`[Worker] Loading OPFS Lance: ${u}`);let n=u.split("/").filter(S=>S),r=n.pop(),e=await Oe(n),l=await(await e.getFileHandle(r)).getFile(),o=new Uint8Array(await l.arrayBuffer()),a=null;try{let T=await(await(await e.getFileHandle(`${r}.schema`)).getFile()).text();a=JSON.parse(T),console.log(`[Worker] Loaded schema sidecar: ${a.columns?.length} columns`)}catch{}if(!o||o.length===0)return console.error(`[Worker] Empty OPFS file: ${u}`),null;if(o.length<40)return console.error(`[Worker] File too small for Lance format: ${u}`),null;let i=String.fromCharCode(o[o.length-4],o[o.length-3],o[o.length-2],o[o.length-1]);if(i!=="LANC")return console.error(`[Worker] Invalid Lance magic in ${u}: ${i}`),null;let c=new DataView(o.buffer,o.byteOffset),f=o.length-40,h=Number(c.getBigUint64(f+8,!0)),p=c.getUint32(f+28,!0),m=[],d=[];for(let S=0;S<p;S++){let _=h+S*16;if(_+16>o.length){console.log(`[Worker] OPFS column ${S}: offset out of bounds (offsetPos=${_})`);continue}let T=Number(c.getBigUint64(_,!0)),$=Number(c.getBigUint64(_+8,!0));if(T>=o.length||T+$>o.length){console.log(`[Worker] OPFS column ${S}: metadata bounds invalid (pos=${T}, len=${$})`);continue}let C=`col_${S}`,E="unknown";a?.columns?.[S]&&(C=a.columns[S].name,E=a.columns[S].type||"unknown"),m.push({name:C,type:E,metaPos:T,metaLen:$}),d.push(E),console.log(`[Worker] OPFS column ${S}: name=${C}, type=${E}, metaPos=${T}, metaLen=${$}`)}if(!L&&(await te(),!L))throw new Error("WASM not loaded");let w=L.alloc(o.length);if(!w||w<0)throw new Error("Failed to allocate WASM memory for OPFS file");if(new Uint8Array(U.buffer,w,o.length).set(o),L.openFile(w,o.length)===0)throw new Error("WASM openFile failed: invalid Lance file");let A=Number(L.getRowCount(0)),y=Math.min(A,t);console.log(`[Worker] OPFS file has ${p} columns, ${A} rows, reading ${y}`);let b={},F=[];for(let S=0;S<m.length;S++){let{name:_,type:T}=m[S];if(F.push(_),T==="float64"||T==="double"){let $=L.allocFloat64Buffer(y);if($){let C=L.readFloat64Column(S,$,y);b[_]=new Float64Array(U.buffer,$,C).slice()}else b[_]=new Float64Array(y).fill(0)}else if(T==="int64"){let $=L.allocInt64Buffer(y);if($){let C=L.readInt64Column(S,$,y),E=new BigInt64Array(U.buffer,$,C),x=new Float64Array(C);for(let B=0;B<C;B++)x[B]=Number(E[B]);b[_]=x}else b[_]=new Float64Array(y).fill(0)}else if(T==="string"){let $=L.getStringCount?Number(L.getStringCount(S)):0;if(console.log(`[Worker] OPFS column ${S} (${_}): stringCount=${$}`),$>0&&L.readStringAt&&L.allocStringBuffer){let C=[],x=L.allocStringBuffer(4096);if(x){let B=new TextDecoder("utf-8");for(let H=0;H<y;H++){let D=L.readStringAt(S,H,x,4096);if(D>0){let v=Math.min(D,4096),W=new Uint8Array(U.buffer,x,v);C.push(B.decode(W.slice()))}else C.push("")}b[_]=C,console.log(`[Worker] Read ${C.length} strings for column ${_}, first: "${C[0]}"`)}else console.warn(`[Worker] Failed to allocate string buffer for column ${_}`),b[_]=Array(y).fill("")}else console.warn(`[Worker] String column ${_}: no WASM string functions or zero count`),b[_]=Array(y).fill("")}else if(T.includes("vector")||T.includes("list")||T==="float32")if(L.getVectorInfo&&L.readVectorAt&&L.allocFloat32Buffer){let $=L.getVectorInfo(S);if($>0){let C=Number($>>32n),E=Number($&0xFFFFFFFFn),x=Math.min(y,C);if(console.log(`[Worker] OPFS vector column ${_}: dim=${E}, rows=${C}, reading ${x}`),E>0&&x>0){let B=x*E,H=L.allocFloat32Buffer(B);if(H){for(let v=0;v<x;v++){let W=v*E;L.readVectorAt(S,v,H+W,E)}let D=new Float32Array(U.buffer,H,B).slice();b[_]=D,b[`__${_}_dim`]=E}else console.warn(`[Worker] Failed to allocate vector buffer for column ${_}`),b[_]=new Float32Array(0)}else b[_]=new Float32Array(0)}else console.warn(`[Worker] getVectorInfo returned 0 for column ${_}`),b[_]=new Float32Array(0)}else console.warn(`[Worker] No WASM vector functions for column ${_}`),b[_]=new Float32Array(0);else{let $=L.allocFloat64Buffer(y);if($){let C=L.readFloat64Column(S,$,y);C>0?b[_]=new Float64Array(U.buffer,$,C).slice():b[_]=Array(y).fill("")}else b[_]=[]}}return L.closeFile(),console.log(`[Worker] OPFS read ${y} rows from ${F.length} columns: ${F.join(", ")}`),{columns:b,rowCount:y,columnNames:F}}catch(n){return console.error("[Worker] Failed to load OPFS Lance:",n),null}}async function Qe(u,t){if(!L&&(await te(),!L))throw new Error("WASM not loaded");let n=t.replace(/--[^\n]*/g,"").replace(/\/\*[\s\S]*?\*\//g,"").trim(),r=Le(),e=lt(n);for(let{url:o,alias:a}of e){let i=r.hasTable(a);if(console.log(`[Worker] Processing URL mapping: alias=${a}, url=${o.substring(0,50)}..., alreadyRegistered=${i}`),i){console.log(`[Worker] Table ${a} already registered, skipping`);continue}let c=null,f=null;try{if(o.startsWith("https://")||o.startsWith("http://"))console.log(`[Worker] Fetching remote Lance: ${o} as ${a}`),c=await ft(o);else if(o.startsWith("opfs://")){let h=o.replace("opfs://","");console.log(`[Worker] Loading OPFS Lance: ${h} as ${a}`),c=await qe(h)}else console.log(`[Worker] Loading OPFS Lance (no prefix): ${o} as ${a}`),c=await qe(o)}catch(h){f=h,console.error(`[Worker] Failed to load ${o}:`,h)}if(c){let h=Object.keys(c.columns),p=h.filter(d=>{let w=c.columns[d];return w&&(Array.isArray(w),w.length>0)});console.log(`[Worker] Registering table ${a} with ${c.rowCount} rows, columns: ${h.join(", ")}, non-empty: ${p.join(", ")}`);try{r.registerTable(a,c.columns,c.rowCount,o)}catch(d){throw console.error(`[Worker] Registration error for ${a}:`,d),new Error(`Failed to register table ${a}: ${d.message}`)}let m=r.hasTable(a);if(console.log(`[Worker] hasTable(${a}) = ${m}`),!m)throw new Error(`Failed to register table ${a} from ${o} - hasTable returned false`)}else{let h=f?f.message:"file may not exist or returned empty data";throw new Error(`Could not load read_lance('${o}'): ${h}`)}}let s=e.length>0?ct(n,e):n,l=r.getTableNames(s);for(let o of l){if(r.hasTable(o))continue;let i=u.tables.get(o);if(!i)continue;let c=u._columnarBuffer?.get(o),f=c?.__length||0,h=`${o}:${i.fragments?.length||0}:${f}:${i.deletionVector?.length||0}`,p=i.fragments.length>0,m=f>0;if(p){let d=[];for(let w of i.fragments){let g=await yt(w);g&&d.push(g)}if(r.registerTableFromFiles(o,i.fragments,h),m){let w={};for(let g of i.schema){let A=c[g.name];A&&ArrayBuffer.isView(A)&&(w[g.name]=A.subarray(0,f))}r.appendTableMemory(o,w,f)}}else if(m){let d=await u.selectColumnar(o);if(d){let{columns:w,rowCount:g}=d;r.registerTable(o,w,g,h)}}}return r.execute(s)}var L=null,U=null,ae=new Map,gt=1;async function Oe(u){let t=await navigator.storage.getDirectory();t=await t.getDirectoryHandle("lanceql",{create:!0});for(let n of u)t=await t.getDirectoryHandle(n,{create:!0});return t}function mt(){return{env:{opfs_open:(u,t)=>{try{let n=new Uint8Array(U.buffer,u,t),r=new TextDecoder().decode(n);for(let[e,s]of ae.entries())if(s._path===r)return e;return console.warn("[LanceQLWorker] WASM tried to open unregistered path:",r),0}catch(n){return console.error("[LanceQLWorker] Error:",n),0}},opfs_read:(u,t,n,r)=>{let e=ae.get(u);if(!e)return 0;try{let s=new Uint8Array(U.buffer,t,n);return e.read(s,{at:Number(r)})}catch{return 0}},opfs_size:u=>{let t=ae.get(u);if(!t)return BigInt(0);try{return BigInt(t.getSize())}catch{return BigInt(0)}},opfs_close:u=>{},__assert_fail:(u,t,n,r)=>{let s=new TextDecoder().decode(new Uint8Array(U.buffer,u).subarray(0,100));console.error(`[WASM ASSERT] ${s} at line ${n}`)},js_log:(u,t)=>{let r=new TextDecoder().decode(new Uint8Array(U.buffer,u,t));console.log(`[WASM LOG] ${r}`);for(let e of xe)e.postMessage({type:"log",message:r,marker:"__WASM_LOG_BRIDGE__"})}}}}async function yt(u){try{let t=u.split("/").filter(o=>o),n=t.pop(),s=await(await(await Oe(t)).getFileHandle(n)).createSyncAccessHandle(),l=gt++;return s._path=u,ae.set(l,s),l}catch(t){return console.warn("[LanceQLWorker] Failed to register OPFS file:",u,t),0}}function en(u){let t=ae.get(u);if(t){try{t.close()}catch{}ae.delete(u)}}async function te(){if(L)return L;try{let u=new URL("./lanceql.wasm",import.meta.url);u.searchParams.set("v",Date.now().toString());let n=await(await fetch(u)).arrayBuffer(),r=mt();return L=(await WebAssembly.instantiate(n,r)).instance.exports,U=L.memory,console.log("[LanceQLWorker] WASM loaded with OPFS support"),L}catch(u){return console.warn("[LanceQLWorker] WASM not available:",u.message),null}}function Q(){return L}function J(){return U}var Ie=0,Je=0,pt=1024*1024;function bt(u){if(!L)return 0;if(u<=Je&&Ie!==0)return Ie;let t=Math.max(u,pt),n=L.alloc(t);return n&&(Ie=n,Je=t),n}async function tn(u){let t=await te();if(!t)return 0;try{let n=u.split("/").filter(f=>f),r=n.pop(),l=await(await(await Oe(n)).getFileHandle(r)).createSyncAccessHandle(),o=l.getSize(),a=bt(o);if(!a)return l.close(),0;let i=new Uint8Array(U.buffer,a,o),c=l.read(i,{at:0});return l.close(),c!==o?0:t.openFile(a,o)}catch(n){return console.warn("[LanceQLWorker] Failed to load fragment:",u,n),0}}async function _t(u,t){let n=t.split("/").filter(e=>e),r=u;for(let e=0;e<n.length-1;e++)r=await r.getDirectoryHandle(n[e],{create:!1});return await r.getFileHandle(n[n.length-1],{create:!1})}var ve=null;async function At(u){let t=ke.get(u);if(t)return t;ve||(ve=await navigator.storage.getDirectory());let e=await(await(await _t(ve,u)).getFile()).arrayBuffer();return t=new Uint8Array(e),t&&ke.set(u,t,t.byteLength),t}async function nn(u,t,n){if(!await At(u))return null;let e=L;switch(n){case"sum":return e.opfsSumFloat64Column(t);case"min":return e.opfsMinFloat64Column(t);case"max":return e.opfsMaxFloat64Column(t);case"avg":return e.opfsAvgFloat64Column(t);case"count":return Number(e.opfsCountRows());default:return null}}te();var ke=new re,Ce=new Map,Be=new Map,me=null,xe=new Set,oe=null,ee=0,St=1024,ye=new Map,Ye=1;async function Z(u=null){return me||(me=new ge),await me.open(u),me}async function P(u,t={},n=null){let r=n?.keyId||"none",e=`${u}:${r}:${JSON.stringify(t)}`;if(!Ce.has(e)){let s=new de(u,t);await s.open(n),Ce.set(e,s)}return Ce.get(e)}async function V(u){if(!Be.has(u)){let t=new se(u,ke);await t.open(),Be.set(u,t)}return Be.get(u)}function Tt(u,t,n){if(n&&n._format==="wasm_binary"){u.postMessage({id:t,result:{_format:"wasm_binary",buffer:n.buffer,columns:n.columns,rowCount:n.rowCount,schema:n.schema}},[n.buffer]);return}if(n&&n._format==="columnar"&&n.data){let r=n.columns,e=n.rowCount;if(e<1e5){let p=[],m={},d=new Set;for(let w of r){let g=n.data[w];if(ArrayBuffer.isView(g)){let A=g.byteOffset!==0||g.byteLength<g.buffer.byteLength,y=d.has(g.buffer);if(A||y){let b=new g.constructor(g);m[w]=b,p.push(b.buffer)}else m[w]=g,p.push(g.buffer),d.add(g.buffer)}else g&&g._arrowString?(m[w]=g,g.offsets&&g.offsets.buffer&&!d.has(g.offsets.buffer)&&(p.push(g.offsets.buffer),d.add(g.offsets.buffer)),g.bytes&&g.bytes.buffer&&!d.has(g.bytes.buffer)&&(p.push(g.bytes.buffer),d.add(g.bytes.buffer))):m[w]=g}u.postMessage({id:t,result:{_format:"columnar",columns:r,rowCount:e,data:m}},p);return}let s=[],l=[],o=0;for(let p of r){let m=n.data[p];ArrayBuffer.isView(m)?(s.push({name:p,arr:m}),o+=m.byteLength):Array.isArray(m)&&l.push({name:p,arr:m})}let a=o>0?new ArrayBuffer(o):null,i={},c=0;if(a){let p=new Uint8Array(a);for(let{name:m,arr:d}of s){let w=new Uint8Array(d.buffer,d.byteOffset,d.byteLength);p.set(w,c),i[m]={offset:c,length:d.length,type:d.constructor.name},c+=d.byteLength}}let f={};for(let{name:p,arr:m}of l)f[p]=m;let h=[];a&&h.push(a),u.postMessage({id:t,result:{_format:"packed",columns:r,rowCount:e,packedBuffer:a,colOffsets:i,stringData:f}},h);return}if(oe&&n!==void 0){let r=JSON.stringify(n);if(r.length>St){let e=z.encode(r);if(ee+e.length<=oe.byteLength){new Uint8Array(oe,ee,e.length).set(e),u.postMessage({id:t,sharedOffset:ee,sharedLength:e.length}),ee+=e.length,ee>oe.byteLength/2&&(ee=0);return}}}u.postMessage({id:t,result:n})}async function Ze(u,t){if(t.type==="initSharedBuffer"){oe=t.buffer,ee=0,console.log("[LanceQLWorker] SharedArrayBuffer initialized:",oe.byteLength,"bytes");return}let{id:n,method:r,args:e}=t;try{let s;if(r==="ping")s="pong";else if(r==="open")await P(e.name,e.options,e.encryption),s=!0;else if(r==="get")s=await(await P(e.name)).get(e.key);else if(r==="set")await(await P(e.name)).set(e.key,e.value),s=!0;else if(r==="delete")await(await P(e.name)).delete(e.key),s=!0;else if(r==="keys")s=await(await P(e.name)).keys();else if(r==="clear")await(await P(e.name)).clear(),s=!0;else if(r==="filter")s=await(await P(e.name)).filter(e.key,e.query);else if(r==="find")s=await(await P(e.name)).find(e.key,e.query);else if(r==="search")s=await(await P(e.name)).search(e.key,e.text,e.limit);else if(r==="count")s=await(await P(e.name)).count(e.key,e.query);else if(r==="enableSemanticSearch")s=await(await P(e.name)).enableSemanticSearch(e.options);else if(r==="disableSemanticSearch")(await P(e.name)).disableSemanticSearch(),s=!0;else if(r==="hasSemanticSearch")s=(await P(e.name)).hasSemanticSearch();else if(r==="db:open")console.log(`[LanceQLWorker] db:open ${e.name}`),await V(e.name),s=!0;else if(r==="db:createTable")console.log(`[LanceQLWorker] db:createTable ${e.tableName}`),s=await(await V(e.db)).createTable(e.tableName,e.columns,e.ifNotExists),console.log(`[LanceQLWorker] db:createTable ${e.tableName} done`);else if(r==="db:dropTable"){console.log(`[LanceQLWorker] db:dropTable ${e.tableName}`),s=await(await V(e.db)).dropTable(e.tableName,e.ifExists);let o=z.encode(e.tableName);Le().clearTable(o,o.length)}else if(r==="db:insert")console.log(`[LanceQLWorker] db:insert into ${e.tableName}, rows: ${e.rows?.length}`),s=await(await V(e.db)).insert(e.tableName,e.rows),console.log("[LanceQLWorker] db:insert done");else if(r==="db:delete"){let l=await V(e.db),o=e.where?a=>evalWhere(e.where,a):()=>!0;s=await l.delete(e.tableName,o)}else if(r==="db:update"){let l=await V(e.db),o=e.where?a=>evalWhere(e.where,a):()=>!0;s=await l.update(e.tableName,e.updates,o)}else if(r==="db:select"){let l=await V(e.db),o={...e.options};e.where&&(o.where=a=>evalWhere(e.where,a)),s=await l.select(e.tableName,o)}else if(r==="db:exec"){let l=await V(e.db),o=ze(e.sql);if(o?.type==="SHOW_VERSIONS"){let a=await l.listVersions(o.table);s={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:a.length,data:{version:new Float64Array(a.map(i=>i.version)),timestamp:a.map(i=>new Date(i.timestamp).toISOString()),operation:a.map(i=>i.operation),rowCount:new Float64Array(a.map(i=>i.rowCount))}}}else if(o?.type==="RESTORE_TABLE"){let a=await l.restoreToVersion(o.table,o.version);s={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([a.newVersion])}}}else if(o?.type==="SELECT_VERSION"){let a=await l.selectAtVersion(o.table,o.version,{});if(a.length>0){let i=Object.keys(a[0]),c={};for(let f of i)c[f]=a.map(h=>h[f]);s={_format:"columnar",columns:i,rowCount:a.length,data:c}}else s={_format:"columnar",columns:[],rowCount:0,data:{}}}else s=await Qe(l,e.sql);if(s&&s._format==="columnar"&&s.rowCount>=1e5){let a=Ye++;ye.set(a,s),s={_format:"cursor",cursorId:a,columns:s.columns,rowCount:s.rowCount}}}else if(r==="cursor:fetch"){let l=ye.get(e.cursorId);if(!l)throw new Error("Cursor not found");s=l,ye.delete(e.cursorId)}else if(r==="db:flush")console.log(`[LanceQLWorker] db:flush ${e.db}`),await(await V(e.db)).flush(),console.log(`[LanceQLWorker] db:flush ${e.db} done`),s=!0;else if(r==="db:compact")s=await(await V(e.db)).compact();else if(r==="db:listTables")s=(await V(e.db)).listTables();else if(r==="db:getTable")s=(await V(e.db)).getTable(e.tableName);else if(r==="db:scanStart")s=await(await V(e.db)).scanStart(e.tableName,e.options);else if(r==="db:scanNext")s=(await V(e.db)).scanNext(e.streamId);else if(r==="db:listVersions")s=await(await V(e.db)).listVersions(e.tableName);else if(r==="db:selectAtVersion"){let l=await V(e.db),o={...e.options};e.where&&(o.where=a=>evalWhere(e.where,a)),s=await l.selectAtVersion(e.tableName,e.version,o)}else if(r==="db:restoreTable")s=await(await V(e.db)).restoreToVersion(e.tableName,e.version);else if(r==="vault:open")await Z(e.encryption),s=!0;else if(r==="vault:get")s=await(await Z()).get(e.key);else if(r==="vault:set")await(await Z()).set(e.key,e.value),s=!0;else if(r==="vault:delete")await(await Z()).delete(e.key),s=!0;else if(r==="vault:keys")s=await(await Z()).keys();else if(r==="vault:has")s=await(await Z()).has(e.key);else if(r==="vault:tables"){let l=await Z();s=l._db?l._db.listTables():[]}else if(r==="vault:exec"){let o=(await Z())._db,a=ze(e.sql);if(a?.type==="SHOW_VERSIONS"){let i=await o.listVersions(a.table);s={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:i.length,data:{version:new Float64Array(i.map(c=>c.version)),timestamp:i.map(c=>new Date(c.timestamp).toISOString()),operation:i.map(c=>c.operation),rowCount:new Float64Array(i.map(c=>c.rowCount))}}}else if(a?.type==="RESTORE_TABLE"){let i=await o.restoreToVersion(a.table,a.version);s={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([i.newVersion])}}}else if(a?.type==="SELECT_VERSION"){let i=await o.selectAtVersion(a.table,a.version,{});if(i.length>0){let c=Object.keys(i[0]),f={};for(let h of c)f[h]=i.map(p=>p[h]);s={_format:"columnar",columns:c,rowCount:i.length,data:f}}else s={_format:"columnar",columns:[],rowCount:0,data:{}}}else s=await Qe(o,e.sql);if(s&&s._format==="columnar"&&s.rowCount>=1e5){let i=Ye++;ye.set(i,s),s={_format:"cursor",cursorId:i,columns:s.columns,rowCount:s.rowCount}}}else throw new Error(`Unknown method: ${r}`);Tt(u,n,s)}catch(s){let l=s.stack||s.message;l.includes("TableDoesNotExist")?l="Table does not exist":l.includes("ColumnDoesNotExist")?l="Column does not exist":l.includes("UnknownEmbeddingModel")&&(l="Unknown embedding model"),u.postMessage({id:n,error:l})}}var Ft=typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope;Ft?self.onconnect=u=>{let t=u.ports[0];xe.add(t),t.onmessage=n=>{Ze(t,n.data)},t.onmessageerror=n=>{console.error("[LanceQLWorker] Message error:",n)},te().then(()=>{t.postMessage({type:"ready"})}).catch(n=>{console.error("[LanceQLWorker] Failed to load WASM:",n),t.postMessage({type:"ready",error:"WASM load failed"})}),t.start(),console.log("[LanceQLWorker] New connection, total ports:",xe.size)}:(self.onmessage=u=>{Ze(self,u.data)},te().then(()=>{self.postMessage({type:"ready"})}).catch(u=>{console.error("[LanceQLWorker] Failed to load WASM:",u),self.postMessage({type:"ready",error:"WASM load failed"})}));console.log("[LanceQLWorker] Initialized");export{en as closeOPFSFile,Q as getWasm,J as getWasmMemory,tn as loadFragmentToWasm,yt as registerOPFSFile,nn as wasmAggregate};
//# sourceMappingURL=lanceql-worker.js.map
