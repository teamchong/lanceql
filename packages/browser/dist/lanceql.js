var fe=Object.defineProperty;var Xt=Object.getOwnPropertyDescriptor;var Zt=Object.getOwnPropertyNames;var er=Object.prototype.hasOwnProperty;var tr=(o,e,t)=>e in o?fe(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var rr=(o,e)=>{for(var t in e)fe(o,t,{get:e[t],enumerable:!0})},sr=(o,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of Zt(e))!er.call(o,s)&&s!==t&&fe(o,s,{get:()=>e[s],enumerable:!(r=Xt(e,s))||r.enumerable});return o};var nr=o=>sr(fe({},"__esModule",{value:!0}),o);var rt=(o,e,t)=>tr(o,typeof e!="symbol"?e+"":e,t);var Jr={};rr(Jr,{DistanceMetric:()=>O,LanceQL:()=>Ue,LocalDatabase:()=>Ae,RemoteLanceDataset:()=>Q,TableRef:()=>se,Vault:()=>re,default:()=>Ie,getGPUAggregator:()=>Me,getGPUGrouper:()=>Le,getGPUJoiner:()=>Oe,getGPUSorter:()=>Ge,getGPUVectorSearch:()=>Y,vault:()=>Ie});module.exports=nr(Jr);var ur={},W=null,Fe=null,ir=0,Se=new Map,he="clone",te=null,or=16*1024*1024;function ar(){try{if(typeof SharedArrayBuffer<"u"&&typeof crossOriginIsolated<"u"&&crossOriginIsolated)return te=new SharedArrayBuffer(or),he="sharedBuffer",console.log("[LanceQL] Using SharedArrayBuffer (zero-copy)"),!0}catch{}try{let o=new ArrayBuffer(8);return typeof ArrayBuffer.prototype.transfer<"u",he="transfer",console.log("[LanceQL] Using Transferable ArrayBuffers"),!1}catch{}return he="clone",console.log("[LanceQL] Using structured clone (fallback)"),!1}function cr(){return W||(ar(),Fe=new Promise((o,e)=>{console.log("[LanceQL] Using regular Worker for better logging");try{W=new Worker(new URL("./lanceql-worker.js?v="+Date.now(),ur.url),{type:"module",name:"lanceql"}),W.onmessage=t=>{lr(t.data,W,o)},W.onerror=t=>{console.error("[LanceQL] Worker error:",t),e(t)},te&&W.postMessage({type:"initSharedBuffer",buffer:te})}catch(t){console.error("[LanceQL] Failed to create Worker:",t),e(t)}})),Fe}function lr(o,e,t){if(console.log("[LanceQL] Incoming worker message:",o.type||(o.id!==void 0?"RPC reply":"unknown")),o.type==="ready"){t(e);return}if(o.type==="log"){console.log(o.message);return}if(o.id!==void 0){let r=Se.get(o.id);if(r)if(Se.delete(o.id),o.sharedOffset!==void 0&&te){let s=new Uint8Array(te,o.sharedOffset,o.sharedLength),n=JSON.parse(new TextDecoder().decode(s));r.resolve(n)}else if(o.error)r.reject(new Error(o.error));else{let s=o.result;if(s&&s._format==="cursor"){let{cursorId:n,columns:i,rowCount:a}=s;s={_format:"columnar",columns:i,rowCount:a,_cursorId:n,_fetched:!1},Object.defineProperty(s,"data",{configurable:!0,enumerable:!0,get(){return this._fetched||console.warn("Cursor data accessed - fetching from worker"),{}}}),Object.defineProperty(s,"rows",{configurable:!0,enumerable:!0,get(){return[]}})}else if(s&&s._format==="wasm_binary"){let n=-9223372036854775808n,{buffer:i,columns:a,rowCount:c,schema:f}=s,u=new DataView(i),l=new Uint8Array(i),h=32,d=24,g={};for(let p=0;p<a.length;p++){let _=h+p*d,w=u.getUint32(_,!0),m=u.getUint32(_+8,!0),y=Number(u.getBigUint64(_+12,!0)),b=u.getUint32(_+20,!0),x=a[p];if(w<=3){let P=y/b;w===0?g[x]=new BigInt64Array(i,m,P):w===1?g[x]=new Float64Array(i,m,P):w===2?g[x]=new Int32Array(i,m,P):w===3&&(g[x]=new Float32Array(i,m,P))}else{let P=m,v=new Uint32Array(i,P,c),U=m+c*4,B=y-c*4,A=l.subarray(U,U+B),k=new TextDecoder,T=new Array(c),M=!1;g[x]=new Proxy(T,{get(S,G){if(G==="length")return c;if(typeof G=="string"&&!isNaN(G)){if(!M){for(let I=0;I<c;I++){let Z=v[I],N=I<c-1?v[I+1]:B;S[I]=k.decode(A.subarray(Z,N))}M=!0}return S[+G]}if(G===Symbol.iterator){if(!M){for(let I=0;I<c;I++){let Z=v[I],N=I<c-1?v[I+1]:B;S[I]=k.decode(A.subarray(Z,N))}M=!0}return()=>S[Symbol.iterator]()}return S[G]}})}}s={_format:"columnar",columns:a,rowCount:c,data:g},Object.defineProperty(s,"rows",{configurable:!0,enumerable:!0,get(){let p=new Array(c),_=a.map(w=>g[w]);for(let w=0;w<c;w++){let m={};for(let y=0;y<a.length;y++){let b=_[y][w];(b===n||typeof b=="number"&&isNaN(b))&&(b=null),m[a[y]]=b}p[w]=m}return Object.defineProperty(this,"rows",{value:p,writable:!1}),p}})}else if(s&&s._format==="packed"){let{columns:n,rowCount:i,packedBuffer:a,colOffsets:c,stringData:f}=s,u={...f||{}};if(a&&c){let l={Float64Array,Float32Array,Int32Array,Int16Array,Int8Array,Uint32Array,Uint16Array,Uint8Array,BigInt64Array,BigUint64Array};for(let[h,d]of Object.entries(c)){let g=l[d.type]||Float64Array;u[h]=new g(a,d.offset,d.length)}}s.data=u,s._format="columnar",Object.defineProperty(s,"rows",{configurable:!0,enumerable:!0,get(){let l=new Array(i),h=n.map(d=>u[d]);for(let d=0;d<i;d++){let g={};for(let p=0;p<n.length;p++)g[n[p]]=h[p][d];l[d]=g}return Object.defineProperty(this,"rows",{value:l,writable:!1}),l}})}else if(s&&s._format==="columnar"){let{columns:n,rowCount:i,data:a}=s;for(let c of n){let f=a[c];if(f&&f._arrowString){let{offsets:u,bytes:l,isList:h,nullable:d}=f;h&&console.log(`[WorkerRPC] Column ${c} is list mode`);let g=new TextDecoder,p=new Array(i),_=!1;a[c]=new Proxy(p,{get(w,m){if(m==="length")return i;if(typeof m=="string"&&!isNaN(m)){if(!_&&l&&u){for(let y=0;y<i;y++){let b=u[y],x=u[y+1];if(d&&b===x){w[y]=null;continue}let P=g.decode(l.subarray(b,x));try{w[y]=h?JSON.parse(P):P}catch{w[y]=P}}_=!0}return w[+m]}if(m===Symbol.iterator){if(!_&&l&&u){for(let y=0;y<i;y++){let b=u[y],x=u[y+1];if(d&&b===x){w[y]=null;continue}let P=g.decode(l.subarray(b,x));try{w[y]=h?JSON.parse(P):P}catch{w[y]=P}}_=!0}return()=>w[Symbol.iterator]()}return w[m]}})}}Object.defineProperty(s,"rows",{configurable:!0,enumerable:!0,get(){let c=new Array(i),f=n.map(u=>a[u]);for(let u=0;u<i;u++){let l={};for(let h=0;h<n.length;h++)l[n[h]]=f[h][u];c[u]=l}return Object.defineProperty(this,"rows",{value:c,writable:!1}),c}})}r.resolve(s)}}}async function F(o,e){let t=await cr(),r=++ir;return new Promise((s,n)=>{Se.set(r,{resolve:s,reject:n});let i=[];if(he==="transfer"&&e)for(let a of Object.keys(e)){let c=e[a];c instanceof ArrayBuffer?i.push(c):ArrayBuffer.isView(c)&&i.push(c.buffer)}i.length>0?t.postMessage({id:r,method:o,args:e},i):t.postMessage({id:r,method:o,args:e})})}var st=new Uint8Array([76,65,78,67]);var j=class o{constructor(){this.chunks=[]}static encodeVarint(e){let t=[],r=typeof e=="bigint"?e:BigInt(e);for(;r>0x7fn;)t.push(Number(r&0x7fn)|128),r>>=7n;return t.push(Number(r)),new Uint8Array(t)}static encodeFieldHeader(e,t){let r=e<<3|t;return o.encodeVarint(r)}writeVarint(e,t){this.chunks.push(o.encodeFieldHeader(e,0)),this.chunks.push(o.encodeVarint(t))}writeBytes(e,t){this.chunks.push(o.encodeFieldHeader(e,2)),this.chunks.push(o.encodeVarint(t.length)),this.chunks.push(t)}writePackedUint64(e,t){let r=[];for(let n of t)r.push(o.encodeVarint(n));let s=r.reduce((n,i)=>n+i.length,0);this.chunks.push(o.encodeFieldHeader(e,2)),this.chunks.push(o.encodeVarint(s));for(let n of r)this.chunks.push(n)}toBytes(){let e=this.chunks.reduce((s,n)=>s+n.length,0),t=new Uint8Array(e),r=0;for(let s of this.chunks)t.set(s,r),r+=s.length;return t}clear(){this.chunks=[]}},D={INT64:"int64",FLOAT64:"float64",STRING:"string",BOOL:"bool",INT32:"int32",FLOAT32:"float32"},de=class{constructor(e={}){this.majorVersion=e.majorVersion??0,this.minorVersion=e.minorVersion??3,this.columns=[],this.rowCount=null}_validateRowCount(e){if(this.rowCount===null)this.rowCount=e;else if(this.rowCount!==e)throw new Error(`Row count mismatch: expected ${this.rowCount}, got ${e}`)}addInt64Column(e,t){this._validateRowCount(t.length),this.columns.push({name:e,type:D.INT64,data:new Uint8Array(t.buffer,t.byteOffset,t.byteLength),length:t.length})}addInt32Column(e,t){this._validateRowCount(t.length),this.columns.push({name:e,type:D.INT32,data:new Uint8Array(t.buffer,t.byteOffset,t.byteLength),length:t.length})}addFloat64Column(e,t){this._validateRowCount(t.length),this.columns.push({name:e,type:D.FLOAT64,data:new Uint8Array(t.buffer,t.byteOffset,t.byteLength),length:t.length})}addFloat32Column(e,t){this._validateRowCount(t.length),this.columns.push({name:e,type:D.FLOAT32,data:new Uint8Array(t.buffer,t.byteOffset,t.byteLength),length:t.length})}addBoolColumn(e,t){this._validateRowCount(t.length);let r=new Uint8Array(t.length);for(let s=0;s<t.length;s++)r[s]=t[s]?1:0;this.columns.push({name:e,type:D.BOOL,data:r,length:t.length})}addStringColumn(e,t){this._validateRowCount(t.length);let r=new TextEncoder,s=new Int32Array(t.length+1),n=[],i=0;for(let l=0;l<t.length;l++){s[l]=i;let h=r.encode(t[l]);n.push(h),i+=h.length}s[t.length]=i;let a=new Uint8Array(s.buffer),c=n.reduce((l,h)=>l+h.length,0),f=new Uint8Array(c),u=0;for(let l of n)f.set(l,u),u+=l.length;this.columns.push({name:e,type:D.STRING,offsetsData:a,stringData:f,data:null,length:t.length})}_buildColumnMeta(e,t,r,s){let n=new j;n.writePackedUint64(1,[BigInt(e)]),n.writePackedUint64(2,[BigInt(t)]),n.writeVarint(3,r),n.writeVarint(5,0);let i=n.toBytes(),a=new j;return a.writeBytes(2,i),a.toBytes()}_buildStringColumnMeta(e,t,r,s,n){let i=new j;i.writePackedUint64(1,[BigInt(e),BigInt(r)]),i.writePackedUint64(2,[BigInt(t),BigInt(s)]),i.writeVarint(3,n),i.writeVarint(5,0);let a=i.toBytes(),c=new j;return c.writeBytes(2,a),c.toBytes()}finalize(){if(this.columns.length===0)throw new Error("No columns added");let e=[],t=0,r=[];for(let m of this.columns)if(m.type===D.STRING){let y=t;e.push(m.offsetsData),t+=m.offsetsData.length;let b=t;e.push(m.stringData),t+=m.stringData.length,r.push({type:"string",offsetsOffset:y,offsetsSize:m.offsetsData.length,dataOffset:b,dataSize:m.stringData.length,length:m.length})}else{let y=t;e.push(m.data),t+=m.data.length,r.push({type:m.type,offset:y,size:m.data.length,length:m.length})}let s=[];for(let m=0;m<this.columns.length;m++){let y=r[m],b;y.type==="string"?b=this._buildStringColumnMeta(y.offsetsOffset,y.offsetsSize,y.dataOffset,y.dataSize,y.length):b=this._buildColumnMeta(y.offset,y.size,y.length,y.type),s.push(b)}let n=t,i=[],a=0;for(let m of s)i.push(a),e.push(m),t+=m.length,a+=m.length;let c=t,f=new BigUint64Array(i.length);for(let m=0;m<i.length;m++)f[m]=BigInt(i[m]);let u=new Uint8Array(f.buffer);e.push(u),t+=u.length;let l=t,h=0,d=new ArrayBuffer(40),g=new DataView(d);g.setBigUint64(0,BigInt(n),!0),g.setBigUint64(8,BigInt(c),!0),g.setBigUint64(16,BigInt(l),!0),g.setUint32(24,h,!0),g.setUint32(28,this.columns.length,!0),g.setUint16(32,this.majorVersion,!0),g.setUint16(34,this.minorVersion,!0),new Uint8Array(d,36,4).set(st),e.push(new Uint8Array(d));let p=t+40,_=new Uint8Array(p),w=0;for(let m of e)_.set(m,w),w+=m.length;return _}getNumColumns(){return this.columns.length}getRowCount(){return this.rowCount}getColumnNames(){return this.columns.map(e=>e.name)}};var re=class{constructor(e=null){this._getEncryptionKey=e,this._encryptionKeyId=null,this._ready=!1}async _init(){if(this._ready)return this;let e=null;if(this._getEncryptionKey){let t=await this._getEncryptionKey();this._encryptionKeyId=`vault:${Date.now()}`;let r;if(t instanceof CryptoKey)r=await crypto.subtle.exportKey("raw",t);else if(t instanceof ArrayBuffer||t instanceof Uint8Array)r=t instanceof Uint8Array?t:new Uint8Array(t);else if(typeof t=="string"){let n=new TextEncoder().encode(t),i=await crypto.subtle.digest("SHA-256",n);r=new Uint8Array(i)}else throw new Error("Encryption key must be CryptoKey, ArrayBuffer, Uint8Array, or string");e={keyId:this._encryptionKeyId,keyBytes:Array.from(r instanceof Uint8Array?r:new Uint8Array(r))}}return await F("vault:open",{encryption:e}),this._ready=!0,this}async get(e){return F("vault:get",{key:e})}async set(e,t){await F("vault:set",{key:e,value:t})}async delete(e){return F("vault:delete",{key:e})}async keys(){return F("vault:keys",{})}async has(e){return await this.get(e)!==void 0}async exec(e){return F("vault:exec",{sql:e})}async query(e){let t=await this.exec(e);return!t||!t.columns||!t.rows?[]:t.rows.map(r=>{let s={};return t.columns.forEach((n,i)=>{s[n]=r[i]}),s})}table(e){return new se(this,e)}async tables(){return F("vault:tables",{})}async exportToLance(e){let t=await this.exec(`SELECT * FROM ${e} LIMIT 0`);if(!t||!t.columns)throw new Error(`Table '${e}' not found or empty`);let r=await this.exec(`SELECT * FROM ${e}`);if(!r||!r.rows||r.rows.length===0)throw new Error(`Table '${e}' is empty`);let s=new de,n=r.columns,i=r.rows;for(let a=0;a<n.length;a++){let c=n[a],f=i.map(l=>l[c]!==void 0?l[c]:l[a]),u=f.find(l=>l!=null);if(u===void 0)s.addStringColumn(c,f.map(l=>l===null?"":String(l)));else if(typeof u=="bigint")s.addInt64Column(c,BigInt64Array.from(f.map(l=>l===null?0n:BigInt(l))));else if(typeof u=="number")Number.isInteger(u)&&u<=2147483647&&u>=-2147483648?s.addInt32Column(c,Int32Array.from(f.map(l=>l===null?0:l))):s.addFloat64Column(c,Float64Array.from(f.map(l=>l===null?0:l)));else if(typeof u=="boolean")s.addBoolColumn(c,f.map(l=>l===null?!1:l));else if(Array.isArray(u)){let l=u.length,h=new Float32Array(f.length*l);for(let d=0;d<f.length;d++){let g=f[d]||new Array(l).fill(0);for(let p=0;p<l;p++)h[d*l+p]=g[p]||0}s.addVectorColumn(c,h,l)}else s.addStringColumn(c,f.map(l=>l===null?"":String(l)))}return s.finalize()}async uploadToUrl(e,t,r={}){let{onProgress:s}=r;if(s&&typeof XMLHttpRequest<"u")return new Promise((i,a)=>{let c=new XMLHttpRequest;c.open("PUT",t,!0),c.setRequestHeader("Content-Type","application/octet-stream"),c.upload.onprogress=f=>{f.lengthComputable&&s(f.loaded,f.total)},c.onload=()=>{c.status>=200&&c.status<300?i({ok:!0,status:c.status}):a(new Error(`Upload failed: ${c.status} ${c.statusText}`))},c.onerror=()=>a(new Error("Upload failed: network error")),c.send(e)});let n=await fetch(t,{method:"PUT",body:e,headers:{"Content-Type":"application/octet-stream"}});if(!n.ok)throw new Error(`Upload failed: ${n.status} ${n.statusText}`);return n}async exportToRemote(e,t,r={}){let s=await this.exportToLance(e);return await this.uploadToUrl(s,t,r),{size:s.length,url:t.split("?")[0]}}},se=class o{constructor(e,t){this._vault=e,this._tableName=t,this._filters=[],this._similar=null,this._selectCols=null,this._limitValue=null,this._orderBy=null}filter(e,t,r){let s=this._clone();return s._filters.push({column:e,op:t,value:r}),s}similar(e,t,r=20){let s=this._clone();return s._similar={column:e,text:t,limit:r},s}select(...e){let t=this._clone();return t._selectCols=e.flat(),t}limit(e){let t=this._clone();return t._limitValue=e,t}orderBy(e,t="ASC"){let r=this._clone();return r._orderBy={column:e,direction:t},r}async toArray(){let e=this._toSQL();return this._vault.query(e)}async first(){let e=this._clone();return e._limitValue=1,(await e.toArray())[0]||null}async count(){let e=this._toSQL(!0);return(await this._vault.exec(e))?.rows?.[0]?.[0]||0}_toSQL(e=!1){let r=`SELECT ${e?"COUNT(*)":this._selectCols?.join(", ")||"*"} FROM ${this._tableName}`,s=[];for(let i of this._filters){let a=typeof i.value=="string"?`'${i.value}'`:i.value;s.push(`${i.column} ${i.op} ${a}`)}this._similar&&s.push(`${this._similar.column} NEAR '${this._similar.text}'`),s.length>0&&(r+=" WHERE "+s.join(" AND ")),this._orderBy&&!e&&(r+=` ORDER BY ${this._orderBy.column} ${this._orderBy.direction}`);let n=this._similar?.limit||this._limitValue;return n&&!e&&(r+=` LIMIT ${n}`),r}_clone(){let e=new o(this._vault,this._tableName);return e._filters=[...this._filters],e._similar=this._similar,e._selectCols=this._selectCols?[...this._selectCols]:null,e._limitValue=this._limitValue,e._orderBy=this._orderBy,e}};async function Ie(o=null){let e=new re(o);return await e._init(),e}function ge(o){let e=0;for(let t=0;t<o.length;t++)e=(e<<5)-e+o.charCodeAt(t),e|=0;return e.toString(36)}var me=class{constructor(e,t=256*1024*1024){this.device=e,this.maxPoolSize=t,this.currentSize=0,this.buffers=new Map,this.accessOrder=[]}getOrCreate(e,t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST){let s=ge(e),n=this.buffers.get(s);if(n){if(this._touch(s),n.size===t.byteLength)return n.buffer;this.invalidate(e)}this._ensureSpace(t.byteLength);let i=this.device.createBuffer({size:t.byteLength,usage:r,mappedAtCreation:!0}),a=t.constructor;return new a(i.getMappedRange()).set(t),i.unmap(),this.buffers.set(s,{buffer:i,size:t.byteLength,lastAccess:Date.now(),usage:r,originalKey:e}),this.currentSize+=t.byteLength,this.accessOrder.push(s),i}getStorageBuffer(e,t){return this.getOrCreate(e,t,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST)}getUniformBuffer(e,t){return this.getOrCreate(e,t,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST)}has(e){return this.buffers.has(ge(e))}get(e){let t=ge(e),r=this.buffers.get(t);return r?(this._touch(t),r.buffer):null}invalidate(e){let t=ge(e),r=this.buffers.get(t);r&&(r.buffer.destroy(),this.currentSize-=r.size,this.buffers.delete(t),this.accessOrder=this.accessOrder.filter(s=>s!==t))}invalidatePrefix(e){let t=[];for(let[r,s]of this.buffers)s.originalKey.startsWith(e)&&t.push(r);for(let r of t){let s=this.buffers.get(r);s.buffer.destroy(),this.currentSize-=s.size,this.buffers.delete(r)}this.accessOrder=this.accessOrder.filter(r=>!t.includes(r))}clear(){for(let e of this.buffers.values())e.buffer.destroy();this.buffers.clear(),this.accessOrder=[],this.currentSize=0}stats(){return{entries:this.buffers.size,currentSize:this.currentSize,maxSize:this.maxPoolSize,utilization:this.currentSize/this.maxPoolSize}}_touch(e){let t=this.accessOrder.indexOf(e);t!==-1&&this.accessOrder.splice(t,1),this.accessOrder.push(e);let r=this.buffers.get(e);r&&(r.lastAccess=Date.now())}_ensureSpace(e){for(;this.currentSize+e>this.maxPoolSize&&this.accessOrder.length>0;){let t=this.accessOrder.shift(),r=this.buffers.get(t);r&&(r.buffer.destroy(),this.currentSize-=r.size,this.buffers.delete(t))}}},it=new WeakMap;function R(o,e=256*1024*1024){let t=it.get(o);return t||(t=new me(o,e),it.set(o,t)),t}var pe=class{constructor(){this.device=null,this.pipeline=null,this.available=!1,this._initPromise=null}async init(){return this._initPromise?this._initPromise:(this._initPromise=this._doInit(),this._initPromise)}async _doInit(){if(!navigator.gpu)return console.log("[WebGPU] Not available in this browser"),!1;try{let e=await navigator.gpu.requestAdapter();return e?(this.device=await e.requestDevice(),this._createPipeline(),this.available=!0,console.log("[WebGPU] Initialized successfully"),!0):(console.log("[WebGPU] No adapter found"),!1)}catch(e){return console.warn("[WebGPU] Init failed:",e),!1}}_createPipeline(){let t=this.device.createShaderModule({code:`
            struct Params {
                dim: u32,
                numVectors: u32,
            }

            @group(0) @binding(0) var<uniform> params: Params;
            @group(0) @binding(1) var<storage, read> query: array<f32>;
            @group(0) @binding(2) var<storage, read> vectors: array<f32>;
            @group(0) @binding(3) var<storage, read_write> scores: array<f32>;

            @compute @workgroup_size(256)
            fn main(@builtin(global_invocation_id) globalId: vec3u) {
                let idx = globalId.x;
                if (idx >= params.numVectors) {
                    return;
                }

                let dim = params.dim;
                let offset = idx * dim;

                // Compute dot product (= cosine similarity for normalized vectors)
                var dot: f32 = 0.0;
                for (var i: u32 = 0u; i < dim; i++) {
                    dot += query[i] * vectors[offset + i];
                }

                scores[idx] = dot;
            }
        `});this.pipeline=this.device.createComputePipeline({layout:"auto",compute:{module:t,entryPoint:"main"}})}async batchCosineSimilarity(e,t,r=!0,s=!1){if(!this.available||t.length===0)return null;let n=e.length,i=s?t.length/n:t.length,a=i*n*4,c=this.device.limits?.maxStorageBufferBindingSize||134217728;if(a>c)return console.warn(`[WebGPU] Buffer size ${(a/1024/1024).toFixed(1)}MB exceeds limit ${(c/1024/1024).toFixed(1)}MB, falling back`),null;let f=this.device.createBuffer({size:8,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),u=this.device.createBuffer({size:n*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),l=this.device.createBuffer({size:i*n*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),h=this.device.createBuffer({size:i*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),d=this.device.createBuffer({size:i*4,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST});if(this.device.queue.writeBuffer(f,0,new Uint32Array([n,i])),this.device.queue.writeBuffer(u,0,e),s)this.device.queue.writeBuffer(l,0,t);else{let m=new Float32Array(i*n);for(let y=0;y<i;y++)m.set(t[y],y*n);this.device.queue.writeBuffer(l,0,m)}let g=this.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:u}},{binding:2,resource:{buffer:l}},{binding:3,resource:{buffer:h}}]}),p=this.device.createCommandEncoder(),_=p.beginComputePass();_.setPipeline(this.pipeline),_.setBindGroup(0,g),_.dispatchWorkgroups(Math.ceil(i/256)),_.end(),p.copyBufferToBuffer(h,0,d,0,i*4),this.device.queue.submit([p.finish()]),await d.mapAsync(GPUMapMode.READ);let w=new Float32Array(d.getMappedRange().slice(0));return d.unmap(),f.destroy(),u.destroy(),l.destroy(),h.destroy(),d.destroy(),w}isAvailable(){return this.available}getMaxVectorsPerBatch(e){if(!this.available)return 0;let t=this.device.limits?.maxStorageBufferBindingSize||134217728;return Math.floor(t*.9/(e*4))}},ke=null;function z(){return ke||(ke=new pe),ke}var H={F32:0,F16:1,Q4_0:2,Q4_1:3,Q5_0:6,Q5_1:7,Q8_0:8,Q8_1:9,Q2_K:10,Q3_K:11,Q4_K:12,Q5_K:13,Q6_K:14,Q8_K:15,I8:16,I16:17,I32:18,I64:19,F64:20,BF16:21},cs={[H.F32]:4,[H.F16]:2,[H.BF16]:2,[H.Q8_0]:33,[H.Q4_0]:18,[H.Q4_1]:20};var mr=`
struct ReduceParams {
    size: u32,
    workgroups: u32,
}

@group(0) @binding(0) var<uniform> params: ReduceParams;
@group(0) @binding(1) var<storage, read> input: array<f32>;
@group(0) @binding(2) var<storage, read_write> output: array<f32>;

var<workgroup> shared_data: array<f32, 256>;

@compute @workgroup_size(256)
fn reduce_sum(@builtin(global_invocation_id) gid: vec3<u32>,
              @builtin(local_invocation_id) lid: vec3<u32>,
              @builtin(workgroup_id) wid: vec3<u32>) {
    let tid = lid.x;
    shared_data[tid] = select(0.0, input[gid.x], gid.x < params.size);
    workgroupBarrier();
    for (var s: u32 = 128u; s > 0u; s >>= 1u) {
        if (tid < s) { shared_data[tid] += shared_data[tid + s]; }
        workgroupBarrier();
    }
    if (tid == 0u) { output[wid.x] = shared_data[0]; }
}

@compute @workgroup_size(256)
fn reduce_sum_final(@builtin(local_invocation_id) lid: vec3<u32>) {
    let tid = lid.x;
    shared_data[tid] = select(0.0, input[tid], tid < params.workgroups);
    workgroupBarrier();
    for (var s: u32 = 128u; s > 0u; s >>= 1u) {
        if (tid < s) { shared_data[tid] += shared_data[tid + s]; }
        workgroupBarrier();
    }
    if (tid == 0u) { output[0] = shared_data[0]; }
}

@compute @workgroup_size(256)
fn reduce_min(@builtin(global_invocation_id) gid: vec3<u32>,
              @builtin(local_invocation_id) lid: vec3<u32>,
              @builtin(workgroup_id) wid: vec3<u32>) {
    let tid = lid.x;
    shared_data[tid] = select(3.4e+38, input[gid.x], gid.x < params.size);
    workgroupBarrier();
    for (var s: u32 = 128u; s > 0u; s >>= 1u) {
        if (tid < s) { shared_data[tid] = min(shared_data[tid], shared_data[tid + s]); }
        workgroupBarrier();
    }
    if (tid == 0u) { output[wid.x] = shared_data[0]; }
}

@compute @workgroup_size(256)
fn reduce_min_final(@builtin(local_invocation_id) lid: vec3<u32>) {
    let tid = lid.x;
    shared_data[tid] = select(3.4e+38, input[tid], tid < params.workgroups);
    workgroupBarrier();
    for (var s: u32 = 128u; s > 0u; s >>= 1u) {
        if (tid < s) { shared_data[tid] = min(shared_data[tid], shared_data[tid + s]); }
        workgroupBarrier();
    }
    if (tid == 0u) { output[0] = shared_data[0]; }
}

@compute @workgroup_size(256)
fn reduce_max(@builtin(global_invocation_id) gid: vec3<u32>,
              @builtin(local_invocation_id) lid: vec3<u32>,
              @builtin(workgroup_id) wid: vec3<u32>) {
    let tid = lid.x;
    shared_data[tid] = select(-3.4e+38, input[gid.x], gid.x < params.size);
    workgroupBarrier();
    for (var s: u32 = 128u; s > 0u; s >>= 1u) {
        if (tid < s) { shared_data[tid] = max(shared_data[tid], shared_data[tid + s]); }
        workgroupBarrier();
    }
    if (tid == 0u) { output[wid.x] = shared_data[0]; }
}

@compute @workgroup_size(256)
fn reduce_max_final(@builtin(local_invocation_id) lid: vec3<u32>) {
    let tid = lid.x;
    shared_data[tid] = select(-3.4e+38, input[tid], tid < params.workgroups);
    workgroupBarrier();
    for (var s: u32 = 128u; s > 0u; s >>= 1u) {
        if (tid < s) { shared_data[tid] = max(shared_data[tid], shared_data[tid + s]); }
        workgroupBarrier();
    }
    if (tid == 0u) { output[0] = shared_data[0]; }
}
`,Ce=1e4,we=class{constructor(){this.device=null,this.pipelines=new Map,this.available=!1,this.bufferPool=null}async init(){if(this.device)return this.available;if(typeof navigator>"u"||!navigator.gpu)return console.log("[GPUAggregator] WebGPU not available"),!1;try{let e=await navigator.gpu.requestAdapter();return e?(this.device=await e.requestDevice({requiredLimits:{maxStorageBufferBindingSize:256*1024*1024,maxBufferSize:256*1024*1024}}),await this._compileShaders(),this.bufferPool=R(this.device),this.available=!0,console.log("[GPUAggregator] Initialized"),!0):(console.log("[GPUAggregator] No WebGPU adapter"),!1)}catch(e){return console.error("[GPUAggregator] Init failed:",e),!1}}isAvailable(){return this.available}async _compileShaders(){let e=this.device.createShaderModule({code:mr});for(let t of["sum","min","max"])this.pipelines.set(`reduce_${t}`,this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:`reduce_${t}`}})),this.pipelines.set(`reduce_${t}_final`,this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:`reduce_${t}_final`}}))}async sum(e,t){return e.length<Ce||!this.available?this._cpuSum(e):this._gpuReduce(e,"sum",t)}count(e){return e.length}async avg(e){return e.length===0?null:await this.sum(e)/e.length}async min(e,t){return e.length===0?null:e.length<Ce||!this.available?this._cpuMin(e):this._gpuReduce(e,"min",t)}async max(e,t){return e.length===0?null:e.length<Ce||!this.available?this._cpuMax(e):this._gpuReduce(e,"max",t)}async batch(e,t){let r={};for(let s of t)switch(s){case"sum":r.sum=await this.sum(e);break;case"count":r.count=await this.count(e);break;case"avg":r.sum!==void 0?r.avg=e.length>0?r.sum/e.length:null:r.avg=await this.avg(e);break;case"min":r.min=await this.min(e);break;case"max":r.max=await this.max(e);break}return r}async _gpuReduce(e,t,r){let s=e.length,i=Math.ceil(s/256),a=e instanceof Float32Array?e:new Float32Array(e),c,f=!1;r&&this.bufferPool?(c=this.bufferPool.getStorageBuffer(r,a),f=!0):(c=this.device.createBuffer({size:a.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.device.queue.writeBuffer(c,0,a));let u=this.device.createBuffer({size:i*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),l=this.device.createBuffer({size:4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),h=this.device.createBuffer({size:4,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),d=new Uint32Array([s,i]),g=this.device.createBuffer({size:8,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.device.queue.writeBuffer(g,0,d);let p=this.pipelines.get(`reduce_${t}`),_=this.device.createBindGroup({layout:p.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:g}},{binding:1,resource:{buffer:c}},{binding:2,resource:{buffer:u}}]}),w=new Uint32Array([i,i]),m=this.device.createBuffer({size:8,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.device.queue.writeBuffer(m,0,w);let y=this.pipelines.get(`reduce_${t}_final`),b=this.device.createBindGroup({layout:y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:m}},{binding:1,resource:{buffer:u}},{binding:2,resource:{buffer:l}}]}),x=this.device.createCommandEncoder(),P=x.beginComputePass();P.setPipeline(p),P.setBindGroup(0,_),P.dispatchWorkgroups(i),P.end();let v=x.beginComputePass();v.setPipeline(y),v.setBindGroup(0,b),v.dispatchWorkgroups(1),v.end(),x.copyBufferToBuffer(l,0,h,0,4),this.device.queue.submit([x.finish()]),await h.mapAsync(GPUMapMode.READ);let U=new Float32Array(h.getMappedRange())[0];return h.unmap(),f||c.destroy(),u.destroy(),l.destroy(),h.destroy(),g.destroy(),m.destroy(),U}_cpuSum(e){let t=0;for(let r=0;r<e.length;r++)t+=e[r];return t}_cpuMin(e){let t=e[0];for(let r=1;r<e.length;r++)e[r]<t&&(t=e[r]);return t}_cpuMax(e){let t=e[0];for(let r=1;r<e.length;r++)e[r]>t&&(t=e[r]);return t}getBufferPool(){return this.bufferPool}invalidateTable(e){this.bufferPool&&this.bufferPool.invalidatePrefix(e+":")}dispose(){this.bufferPool&&(this.bufferPool.clear(),this.bufferPool=null),this.pipelines.clear(),this.device=null,this.available=!1}},Te=null;function Me(){return Te||(Te=new we),Te}var pr=`
struct BuildParams { size: u32, capacity: u32 }
struct ProbeParams { left_size: u32, capacity: u32, max_matches: u32 }
struct InitParams { capacity: u32 }

@group(0) @binding(0) var<uniform> build_params: BuildParams;
@group(0) @binding(1) var<storage, read> keys: array<u32>;
@group(0) @binding(2) var<storage, read_write> hash_table: array<atomic<u32>>;

fn fnv_hash(key: u32) -> u32 {
    var h = 2166136261u;
    h ^= (key & 0xFFu); h *= 16777619u;
    h ^= ((key >> 8u) & 0xFFu); h *= 16777619u;
    h ^= ((key >> 16u) & 0xFFu); h *= 16777619u;
    h ^= ((key >> 24u) & 0xFFu); h *= 16777619u;
    return h;
}

@compute @workgroup_size(256)
fn build(@builtin(global_invocation_id) gid: vec3<u32>) {
    let tid = gid.x;
    if (tid >= build_params.size) { return; }
    let key = keys[tid];
    var slot = fnv_hash(key) % build_params.capacity;
    for (var p = 0u; p < build_params.capacity; p++) {
        let idx = slot * 2u;
        let old = atomicCompareExchangeWeak(&hash_table[idx], 0xFFFFFFFFu, key);
        if (old.exchanged) { atomicStore(&hash_table[idx + 1u], tid); return; }
        slot = (slot + 1u) % build_params.capacity;
    }
}

@group(0) @binding(0) var<uniform> probe_params: ProbeParams;
@group(0) @binding(1) var<storage, read> left_keys: array<u32>;
@group(0) @binding(2) var<storage, read> probe_table: array<u32>;
@group(0) @binding(3) var<storage, read_write> matches: array<u32>;
@group(0) @binding(4) var<storage, read_write> match_count: atomic<u32>;

@compute @workgroup_size(256)
fn probe(@builtin(global_invocation_id) gid: vec3<u32>) {
    let left_idx = gid.x;
    if (left_idx >= probe_params.left_size) { return; }
    let key = left_keys[left_idx];
    var slot = fnv_hash(key) % probe_params.capacity;
    for (var p = 0u; p < probe_params.capacity; p++) {
        let idx = slot * 2u;
        let stored = probe_table[idx];
        if (stored == 0xFFFFFFFFu) { return; }
        if (stored == key) {
            let right_idx = probe_table[idx + 1u];
            let out = atomicAdd(&match_count, 1u);
            if (out * 2u + 1u < probe_params.max_matches * 2u) {
                matches[out * 2u] = left_idx;
                matches[out * 2u + 1u] = right_idx;
            }
        }
        slot = (slot + 1u) % probe_params.capacity;
    }
}

@group(0) @binding(0) var<uniform> init_params: InitParams;
@group(0) @binding(1) var<storage, read_write> table_data: array<u32>;

@compute @workgroup_size(256)
fn clear_table(@builtin(global_invocation_id) gid: vec3<u32>) {
    let idx = gid.x;
    if (idx >= init_params.capacity * 2u) { return; }
    table_data[idx] = select(0u, 0xFFFFFFFFu, idx % 2u == 0u);
}
`,ot=316,ye=class{constructor(){this.device=null,this.pipelines=new Map,this.available=!1,this._initPromise=null,this.bufferPool=null}async init(){return this._initPromise?this._initPromise:(this._initPromise=this._doInit(),this._initPromise)}async _doInit(){if(typeof navigator>"u"||!navigator.gpu)return console.log("[GPUJoiner] WebGPU not available"),!1;try{let e=await navigator.gpu.requestAdapter();return e?(this.device=await e.requestDevice({requiredLimits:{maxStorageBufferBindingSize:256*1024*1024,maxBufferSize:256*1024*1024}}),await this._compileShaders(),this.bufferPool=R(this.device),this.available=!0,console.log("[GPUJoiner] Initialized"),!0):(console.log("[GPUJoiner] No WebGPU adapter"),!1)}catch(e){return console.error("[GPUJoiner] Init failed:",e),!1}}async _compileShaders(){let e=this.device.createShaderModule({code:pr});this.pipelines.set("init",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"clear_table"}})),this.pipelines.set("build",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"build"}})),this.pipelines.set("probe",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"probe"}}))}isAvailable(){return this.available}async hashJoin(e,t,r,s,n="INNER",i={}){let a=e.length,c=t.length;if(!this.available||a*c<ot*ot)return this._cpuHashJoin(e,t,r,s,n);let f=this._extractKeys(e,r),u=this._extractKeys(t,s),l=this._nextPowerOf2(c*4),h=Math.max(a*10,1e5),d,g,p=!1,_=!1;i.rightBufferKey&&this.bufferPool?(d=this.bufferPool.getStorageBuffer(i.rightBufferKey,u),p=!0):d=this._createBuffer(u,GPUBufferUsage.STORAGE),i.leftBufferKey&&this.bufferPool?(g=this.bufferPool.getStorageBuffer(i.leftBufferKey,f),_=!0):g=this._createBuffer(f,GPUBufferUsage.STORAGE);let w=this.device.createBuffer({size:l*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),m=this.device.createBuffer({size:h*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),y=this.device.createBuffer({size:4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),b=this.device.createBuffer({size:4,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),x=this._createUniformBuffer(new Uint32Array([l])),P=this.pipelines.get("init"),v=this.device.createBindGroup({layout:P.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:x}},{binding:1,resource:{buffer:w}}]}),U=this._createUniformBuffer(new Uint32Array([c,l])),B=this.pipelines.get("build"),A=this.device.createBindGroup({layout:B.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:U}},{binding:1,resource:{buffer:d}},{binding:2,resource:{buffer:w}}]}),k=this._createUniformBuffer(new Uint32Array([a,l,h])),T=this.pipelines.get("probe"),M=this.device.createBindGroup({layout:T.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:k}},{binding:1,resource:{buffer:g}},{binding:2,resource:{buffer:w}},{binding:3,resource:{buffer:m}},{binding:4,resource:{buffer:y}}]}),S=this.device.createCommandEncoder(),G=Math.ceil(l*2/256),I=S.beginComputePass();I.setPipeline(P),I.setBindGroup(0,v),I.dispatchWorkgroups(G),I.end();let Z=Math.ceil(c/256),N=S.beginComputePass();N.setPipeline(B),N.setBindGroup(0,A),N.dispatchWorkgroups(Z),N.end();let Jt=Math.ceil(a/256),ue=S.beginComputePass();ue.setPipeline(T),ue.setBindGroup(0,M),ue.dispatchWorkgroups(Jt),ue.end(),S.copyBufferToBuffer(y,0,b,0,4),this.device.queue.submit([S.finish()]),await b.mapAsync(GPUMapMode.READ);let Qt=new Uint32Array(b.getMappedRange())[0];b.unmap();let V=Math.min(Qt,h),ee=this.device.createBuffer({size:V*2*4,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),Xe=this.device.createCommandEncoder();Xe.copyBufferToBuffer(m,0,ee,0,V*2*4),this.device.queue.submit([Xe.finish()]),await ee.mapAsync(GPUMapMode.READ);let Ze=new Uint32Array(ee.getMappedRange().slice(0));ee.unmap();let et=new Uint32Array(V),tt=new Uint32Array(V);for(let q=0;q<V;q++)et[q]=Ze[q*2],tt[q]=Ze[q*2+1];return p||d.destroy(),_||g.destroy(),w.destroy(),m.destroy(),y.destroy(),b.destroy(),ee.destroy(),x.destroy(),U.destroy(),k.destroy(),{leftIndices:et,rightIndices:tt,matchCount:V}}_cpuHashJoin(e,t,r,s,n){let i=new Map;for(let f=0;f<t.length;f++){let u=this._hashKey(t[f][s]);i.has(u)||i.set(u,[]),i.get(u).push(f)}let a=[],c=[];for(let f=0;f<e.length;f++){let u=this._hashKey(e[f][r]),l=i.get(u)||[];for(let h of l)a.push(f),c.push(h)}return{leftIndices:new Uint32Array(a),rightIndices:new Uint32Array(c),matchCount:a.length}}_extractKeys(e,t){let r=new Uint32Array(e.length);for(let s=0;s<e.length;s++)r[s]=this._hashKey(e[s][t]);return r}_hashKey(e){if(e==null)return 4294967294;if(typeof e=="number"){if(Number.isInteger(e)&&e>=0&&e<4294967295)return e>>>0;let t=new ArrayBuffer(4);return new Float32Array(t)[0]=e,new Uint32Array(t)[0]}if(typeof e=="string"){let t=2166136261;for(let r=0;r<e.length;r++)t^=e.charCodeAt(r),t=Math.imul(t,16777619);return t>>>0}return this._hashKey(String(e))}_createBuffer(e,t){let r=this.device.createBuffer({size:e.byteLength,usage:t|GPUBufferUsage.COPY_DST});return this.device.queue.writeBuffer(r,0,e),r}_createUniformBuffer(e){let t=this.device.createBuffer({size:Math.max(e.byteLength,16),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return this.device.queue.writeBuffer(t,0,e),t}_nextPowerOf2(e){let t=1;for(;t<e;)t*=2;return t}getBufferPool(){return this.bufferPool}invalidateTable(e){this.bufferPool&&this.bufferPool.invalidatePrefix(e+":")}dispose(){this.bufferPool&&(this.bufferPool.clear(),this.bufferPool=null),this.pipelines.clear(),this.device=null,this.available=!1}},Re=null;function Oe(){return Re||(Re=new ye),Re}var wr=`
// GPU Bitonic Sort Shader
// Implements parallel bitonic sorting network for ORDER BY operations

struct LocalSortParams {
    size: u32,
    stage: u32,
    step: u32,
    ascending: u32,
}

@group(0) @binding(0) var<uniform> local_params: LocalSortParams;
@group(0) @binding(1) var<storage, read_write> keys: array<f32>;
@group(0) @binding(2) var<storage, read_write> indices: array<u32>;

var<workgroup> shared_keys: array<f32, 512>;
var<workgroup> shared_indices: array<u32, 512>;

fn compare_swap(i: u32, j: u32, dir: bool) {
    let ki = shared_keys[i];
    let kj = shared_keys[j];
    let should_swap = select(ki > kj, ki < kj, dir);
    if (should_swap) {
        shared_keys[i] = kj;
        shared_keys[j] = ki;
        let ti = shared_indices[i];
        shared_indices[i] = shared_indices[j];
        shared_indices[j] = ti;
    }
}

@compute @workgroup_size(256)
fn local_bitonic_sort(
    @builtin(global_invocation_id) gid: vec3<u32>,
    @builtin(local_invocation_id) lid: vec3<u32>,
    @builtin(workgroup_id) wid: vec3<u32>
) {
    let local_size = 512u;
    let base = wid.x * local_size;
    let tid = lid.x;

    let idx1 = base + tid;
    let idx2 = base + tid + 256u;

    if (idx1 < local_params.size) {
        shared_keys[tid] = keys[idx1];
        shared_indices[tid] = indices[idx1];
    } else {
        shared_keys[tid] = 3.4e38;
        shared_indices[tid] = idx1;
    }

    if (idx2 < local_params.size) {
        shared_keys[tid + 256u] = keys[idx2];
        shared_indices[tid + 256u] = indices[idx2];
    } else {
        shared_keys[tid + 256u] = 3.4e38;
        shared_indices[tid + 256u] = idx2;
    }

    workgroupBarrier();

    let ascending = local_params.ascending == 1u;

    for (var stage = 1u; stage < local_size; stage = stage << 1u) {
        for (var step = stage; step > 0u; step = step >> 1u) {
            let pair_distance = step;
            let block_size = step << 1u;
            let pos = tid;
            if (pos < 256u) {
                let block_id = pos / step;
                let in_block = pos % step;
                let i = block_id * block_size + in_block;
                let j = i + pair_distance;
                if (j < local_size) {
                    let dir = ((i / (stage << 1u)) % 2u == 0u) == ascending;
                    compare_swap(i, j, dir);
                }
            }
            workgroupBarrier();
        }
    }

    if (idx1 < local_params.size) {
        keys[idx1] = shared_keys[tid];
        indices[idx1] = shared_indices[tid];
    }
    if (idx2 < local_params.size) {
        keys[idx2] = shared_keys[tid + 256u];
        indices[idx2] = shared_indices[tid + 256u];
    }
}

struct MergeParams {
    size: u32,
    stage: u32,
    step: u32,
    ascending: u32,
}

@group(0) @binding(0) var<uniform> merge_params: MergeParams;
@group(0) @binding(1) var<storage, read_write> merge_keys: array<f32>;
@group(0) @binding(2) var<storage, read_write> merge_indices: array<u32>;

@compute @workgroup_size(256)
fn bitonic_merge_step(@builtin(global_invocation_id) gid: vec3<u32>) {
    let tid = gid.x;
    let step = merge_params.step;
    let stage = merge_params.stage;
    let ascending = merge_params.ascending == 1u;

    let block_size = 1u << (stage + 1u);
    let half_block = 1u << stage;

    let block_id = tid / half_block;
    let in_half = tid % half_block;

    let i = block_id * block_size + in_half;
    let j = i + step;

    if (j >= merge_params.size) { return; }

    let dir = ((i / block_size) % 2u == 0u) == ascending;

    let ki = merge_keys[i];
    let kj = merge_keys[j];
    let should_swap = select(ki > kj, ki < kj, dir);

    if (should_swap) {
        merge_keys[i] = kj;
        merge_keys[j] = ki;
        let ti = merge_indices[i];
        merge_indices[i] = merge_indices[j];
        merge_indices[j] = ti;
    }
}

struct InitParams { size: u32 }

@group(0) @binding(0) var<uniform> init_params: InitParams;
@group(0) @binding(1) var<storage, read_write> init_indices: array<u32>;

@compute @workgroup_size(256)
fn init_indices(@builtin(global_invocation_id) gid: vec3<u32>) {
    if (gid.x < init_params.size) {
        init_indices[gid.x] = gid.x;
    }
}
`,at=1e4,_e=class{constructor(){this.device=null,this.pipelines=new Map,this.available=!1,this._initPromise=null,this.bufferPool=null}async init(){return this._initPromise?this._initPromise:(this._initPromise=this._doInit(),this._initPromise)}async _doInit(){if(typeof navigator>"u"||!navigator.gpu)return console.log("[GPUSorter] WebGPU not available"),!1;try{let e=await navigator.gpu.requestAdapter();return e?(this.device=await e.requestDevice({requiredLimits:{maxStorageBufferBindingSize:256*1024*1024,maxBufferSize:256*1024*1024}}),await this._compileShaders(),this.bufferPool=R(this.device),this.available=!0,console.log("[GPUSorter] Initialized"),!0):(console.log("[GPUSorter] No WebGPU adapter"),!1)}catch(e){return console.error("[GPUSorter] Init failed:",e),!1}}async _compileShaders(){let e=this.device.createShaderModule({code:wr});this.pipelines.set("init",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"init_indices"}})),this.pipelines.set("local_sort",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"local_bitonic_sort"}})),this.pipelines.set("merge",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"bitonic_merge_step"}}))}isAvailable(){return this.available}async sort(e,t=!0){let r=e.length;if(!this.available||r<at)return this._cpuSort(e,t);let s=this._nextPowerOf2(r),n=new Float32Array(s);n.set(e instanceof Float32Array?e:new Float32Array(e));for(let P=r;P<s;P++)n[P]=34e37;let i=this._createBuffer(n,GPUBufferUsage.STORAGE),a=this.device.createBuffer({size:s*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),c=this._createUniformBuffer(new Uint32Array([s])),f=this.pipelines.get("init"),u=this.device.createBindGroup({layout:f.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:c}},{binding:1,resource:{buffer:a}}]}),l=this.device.createCommandEncoder(),h=Math.ceil(s/256),d=l.beginComputePass();d.setPipeline(f),d.setBindGroup(0,u),d.dispatchWorkgroups(h),d.end();let g=this.pipelines.get("local_sort"),p=this._createUniformBuffer(new Uint32Array([s,0,0,t?1:0])),_=this.device.createBindGroup({layout:g.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:p}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:a}}]}),w=Math.ceil(s/512),m=l.beginComputePass();if(m.setPipeline(g),m.setBindGroup(0,_),m.dispatchWorkgroups(w),m.end(),this.device.queue.submit([l.finish()]),s>512){let P=this.pipelines.get("merge");for(let v=9;1<<v<s;v++){let U=1<<v;for(let B=U;B>0;B>>=1){let A=this.device.createCommandEncoder(),k=this._createUniformBuffer(new Uint32Array([s,v,B,t?1:0])),T=this.device.createBindGroup({layout:P.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:k}},{binding:1,resource:{buffer:i}},{binding:2,resource:{buffer:a}}]}),M=Math.ceil(s/256),S=A.beginComputePass();S.setPipeline(P),S.setBindGroup(0,T),S.dispatchWorkgroups(M),S.end(),this.device.queue.submit([A.finish()]),k.destroy()}}}let y=this.device.createBuffer({size:r*4,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),b=this.device.createCommandEncoder();b.copyBufferToBuffer(a,0,y,0,r*4),this.device.queue.submit([b.finish()]),await y.mapAsync(GPUMapMode.READ);let x=new Uint32Array(y.getMappedRange().slice(0));return y.unmap(),i.destroy(),a.destroy(),c.destroy(),p.destroy(),y.destroy(),x}async sortRows(e,t,r){if(e.length<at||!this.available)return this._cpuSortRows(e,t,r);let s=new Uint32Array(e.length);for(let i=0;i<e.length;i++)s[i]=i;for(let i=t.length-1;i>=0;i--){let{column:a,direction:c}=t[i],f=typeof a=="string"?a:a.name,u=c!=="DESC",l=new Float32Array(e.length);for(let g=0;g<e.length;g++){let _=e[s[g]][f];_==null?l[g]=u?34e37:-34e37:typeof _=="number"?l[g]=_:typeof _=="string"?l[g]=this._stringToSortKey(_):l[g]=0}let h=await this.sort(l,u),d=new Uint32Array(e.length);for(let g=0;g<e.length;g++)d[g]=s[h[g]];s=d}let n=new Array(e.length);for(let i=0;i<e.length;i++)n[i]=e[s[i]];return n}_cpuSort(e,t){let r=Array.from(e).map((s,n)=>({v:s,i:n}));return r.sort((s,n)=>{if(s.v===n.v)return 0;let i=s.v<n.v?-1:1;return t?i:-i}),new Uint32Array(r.map(s=>s.i))}_cpuSortRows(e,t,r){let s=[...e];return s.sort((n,i)=>{for(let{column:a,direction:c}of t){let f=typeof a=="string"?a:a.name,u=n[f],l=i[f];if(u==null){if(l!=null)return 1;continue}if(l==null)return-1;let h=0;if(typeof u=="string"&&typeof l=="string"?h=u.localeCompare(l):h=u<l?-1:u>l?1:0,h!==0)return c==="DESC"?-h:h}return 0}),s}_stringToSortKey(e){let t=0;for(let r=0;r<Math.min(4,e.length);r++)t=t*256+e.charCodeAt(r);return t}_createBuffer(e,t){let r=this.device.createBuffer({size:e.byteLength,usage:t|GPUBufferUsage.COPY_DST});return this.device.queue.writeBuffer(r,0,e),r}_createUniformBuffer(e){let t=this.device.createBuffer({size:Math.max(e.byteLength,16),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return this.device.queue.writeBuffer(t,0,e),t}_nextPowerOf2(e){let t=1;for(;t<e;)t*=2;return t}getBufferPool(){return this.bufferPool}invalidateTable(e){this.bufferPool&&this.bufferPool.invalidatePrefix(e+":")}dispose(){this.bufferPool&&(this.bufferPool.clear(),this.bufferPool=null),this.pipelines.clear(),this.device=null,this.available=!1}},Ee=null;function Ge(){return Ee||(Ee=new _e),Ee}var yr=`
struct BP { size: u32, cap: u32 }
struct AP { size: u32, cap: u32 }
struct AGP { size: u32, num_groups: u32, agg_type: u32 }
struct IP { cap: u32 }
struct IAP { num_groups: u32, init_value: u32 }

@group(0) @binding(0) var<uniform> bp: BP;
@group(0) @binding(1) var<storage, read> bkeys: array<u32>;
@group(0) @binding(2) var<storage, read_write> ht: array<atomic<u32>>;
@group(0) @binding(3) var<storage, read_write> gc: atomic<u32>;

fn fnv(k: u32) -> u32 {
    var h = 2166136261u;
    h ^= (k & 0xFFu); h *= 16777619u;
    h ^= ((k >> 8u) & 0xFFu); h *= 16777619u;
    h ^= ((k >> 16u) & 0xFFu); h *= 16777619u;
    h ^= ((k >> 24u) & 0xFFu); h *= 16777619u;
    return h;
}

@compute @workgroup_size(256)
fn build(@builtin(global_invocation_id) g: vec3<u32>) {
    if (g.x >= bp.size) { return; }
    let k = bkeys[g.x];
    var s = fnv(k) % bp.cap;
    for (var p = 0u; p < bp.cap; p++) {
        let i = s * 2u;
        let o = atomicCompareExchangeWeak(&ht[i], 0xFFFFFFFFu, k);
        if (o.exchanged) { atomicStore(&ht[i + 1u], atomicAdd(&gc, 1u)); return; }
        if (o.old_value == k) { return; }
        s = (s + 1u) % bp.cap;
    }
}

@group(0) @binding(0) var<uniform> ap: AP;
@group(0) @binding(1) var<storage, read> akeys: array<u32>;
@group(0) @binding(2) var<storage, read> lt: array<u32>;
@group(0) @binding(3) var<storage, read_write> gids: array<u32>;

@compute @workgroup_size(256)
fn assign(@builtin(global_invocation_id) g: vec3<u32>) {
    if (g.x >= ap.size) { return; }
    let k = akeys[g.x];
    var s = fnv(k) % ap.cap;
    for (var p = 0u; p < ap.cap; p++) {
        let i = s * 2u;
        if (lt[i] == k) { gids[g.x] = lt[i + 1u]; return; }
        if (lt[i] == 0xFFFFFFFFu) { gids[g.x] = 0xFFFFFFFFu; return; }
        s = (s + 1u) % ap.cap;
    }
    gids[g.x] = 0xFFFFFFFFu;
}

@group(0) @binding(0) var<uniform> agp: AGP;
@group(0) @binding(1) var<storage, read> agids: array<u32>;
@group(0) @binding(2) var<storage, read> vals: array<f32>;
@group(0) @binding(3) var<storage, read_write> res: array<atomic<u32>>;

fn f2s(f: f32) -> u32 { let b = bitcast<u32>(f); return select(b ^ 0x80000000u, ~b, (b & 0x80000000u) != 0u); }

@compute @workgroup_size(256)
fn count_agg(@builtin(global_invocation_id) g: vec3<u32>) {
    if (g.x >= agp.size) { return; }
    let gid = agids[g.x];
    if (gid < agp.num_groups) { atomicAdd(&res[gid], 1u); }
}

@compute @workgroup_size(256)
fn sum_agg(@builtin(global_invocation_id) g: vec3<u32>) {
    if (g.x >= agp.size) { return; }
    let gid = agids[g.x]; let v = vals[g.x];
    if (gid < agp.num_groups && !isNan(v)) { atomicAdd(&res[gid], u32(i32(v * 1000.0))); }
}

@compute @workgroup_size(256)
fn min_agg(@builtin(global_invocation_id) g: vec3<u32>) {
    if (g.x >= agp.size) { return; }
    let gid = agids[g.x]; let v = vals[g.x];
    if (gid < agp.num_groups && !isNan(v)) { atomicMin(&res[gid], f2s(v)); }
}

@compute @workgroup_size(256)
fn max_agg(@builtin(global_invocation_id) g: vec3<u32>) {
    if (g.x >= agp.size) { return; }
    let gid = agids[g.x]; let v = vals[g.x];
    if (gid < agp.num_groups && !isNan(v)) { atomicMax(&res[gid], f2s(v)); }
}

@group(0) @binding(0) var<uniform> ip: IP;
@group(0) @binding(1) var<storage, read_write> it: array<u32>;

@compute @workgroup_size(256)
fn init_ht(@builtin(global_invocation_id) g: vec3<u32>) {
    if (g.x >= ip.cap * 2u) { return; }
    it[g.x] = select(0u, 0xFFFFFFFFu, g.x % 2u == 0u);
}

@group(0) @binding(0) var<uniform> iap: IAP;
@group(0) @binding(1) var<storage, read_write> iar: array<u32>;

@compute @workgroup_size(256)
fn init_agg(@builtin(global_invocation_id) g: vec3<u32>) {
    if (g.x >= iap.num_groups) { return; }
    iar[g.x] = iap.init_value;
}
`,ct=1e4,be=class{constructor(){this.device=null,this.pipelines=new Map,this.available=!1,this._initPromise=null,this.bufferPool=null}async init(){return this._initPromise?this._initPromise:(this._initPromise=this._doInit(),this._initPromise)}async _doInit(){if(typeof navigator>"u"||!navigator.gpu)return console.log("[GPUGrouper] WebGPU not available"),!1;try{let e=await navigator.gpu.requestAdapter();return e?(this.device=await e.requestDevice({requiredLimits:{maxStorageBufferBindingSize:256*1024*1024,maxBufferSize:256*1024*1024}}),await this._compileShaders(),this.bufferPool=R(this.device),this.available=!0,console.log("[GPUGrouper] Initialized"),!0):(console.log("[GPUGrouper] No WebGPU adapter"),!1)}catch(e){return console.error("[GPUGrouper] Init failed:",e),!1}}async _compileShaders(){let e=this.device.createShaderModule({code:yr});this.pipelines.set("init_ht",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"init_ht"}})),this.pipelines.set("build",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"build"}})),this.pipelines.set("assign",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"assign"}})),this.pipelines.set("init_agg",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"init_agg"}})),this.pipelines.set("count",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"count_agg"}})),this.pipelines.set("sum",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"sum_agg"}})),this.pipelines.set("min",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"min_agg"}})),this.pipelines.set("max",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"max_agg"}}))}isAvailable(){return this.available}async groupBy(e){let t=e.length;if(!this.available||t<ct)return this._cpuGroupBy(e);let r=Math.min(t,1e5),s=this._nextPowerOf2(r*2),n=this._createBuffer(e,GPUBufferUsage.STORAGE),i=this.device.createBuffer({size:s*2*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),a=this.device.createBuffer({size:4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),c=this.device.createBuffer({size:t*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),f=this.pipelines.get("init_ht"),u=this._createUniformBuffer(new Uint32Array([s])),l=this.device.createBindGroup({layout:f.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:u}},{binding:1,resource:{buffer:i}}]}),h=this.pipelines.get("build"),d=this._createUniformBuffer(new Uint32Array([t,s])),g=this.device.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:d}},{binding:1,resource:{buffer:n}},{binding:2,resource:{buffer:i}},{binding:3,resource:{buffer:a}}]}),p=this.pipelines.get("assign"),_=this._createUniformBuffer(new Uint32Array([t,s])),w=this.device.createBindGroup({layout:p.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:_}},{binding:1,resource:{buffer:n}},{binding:2,resource:{buffer:i}},{binding:3,resource:{buffer:c}}]}),m=this.device.createCommandEncoder(),y=Math.ceil(s*2/256),b=m.beginComputePass();b.setPipeline(f),b.setBindGroup(0,l),b.dispatchWorkgroups(y),b.end();let x=Math.ceil(t/256),P=m.beginComputePass();P.setPipeline(h),P.setBindGroup(0,g),P.dispatchWorkgroups(x),P.end();let v=m.beginComputePass();v.setPipeline(p),v.setBindGroup(0,w),v.dispatchWorkgroups(x),v.end();let U=this.device.createBuffer({size:4,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST});m.copyBufferToBuffer(a,0,U,0,4),this.device.queue.submit([m.finish()]),await U.mapAsync(GPUMapMode.READ);let B=new Uint32Array(U.getMappedRange())[0];U.unmap();let A=this.device.createBuffer({size:t*4,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),k=this.device.createCommandEncoder();k.copyBufferToBuffer(c,0,A,0,t*4),this.device.queue.submit([k.finish()]),await A.mapAsync(GPUMapMode.READ);let T=new Uint32Array(A.getMappedRange().slice(0));return A.unmap(),n.destroy(),i.destroy(),a.destroy(),c.destroy(),U.destroy(),A.destroy(),u.destroy(),d.destroy(),_.destroy(),{groupIds:T,numGroups:B}}async groupAggregate(e,t,r,s){let n=e.length;if(!this.available||n<ct)return this._cpuGroupAggregate(e,t,r,s);let i=0,a="count";s==="SUM"?a="sum":s==="MIN"?(i=2139095039,a="min"):s==="MAX"&&(i=0,a="max");let c=this._createBuffer(t,GPUBufferUsage.STORAGE),f=this._createBuffer(e,GPUBufferUsage.STORAGE),u=this.device.createBuffer({size:r*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),l=this.pipelines.get("init_agg"),h=this._createUniformBuffer(new Uint32Array([r,i])),d=this.device.createBindGroup({layout:l.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:h}},{binding:1,resource:{buffer:u}}]}),g=this.pipelines.get(a),p=this._createUniformBuffer(new Uint32Array([n,r,0])),_=this.device.createBindGroup({layout:g.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:p}},{binding:1,resource:{buffer:c}},{binding:2,resource:{buffer:f}},{binding:3,resource:{buffer:u}}]}),w=this.device.createCommandEncoder(),m=Math.ceil(r/256),y=w.beginComputePass();y.setPipeline(l),y.setBindGroup(0,d),y.dispatchWorkgroups(Math.max(1,m)),y.end();let b=Math.ceil(n/256),x=w.beginComputePass();x.setPipeline(g),x.setBindGroup(0,_),x.dispatchWorkgroups(b),x.end();let P=this.device.createBuffer({size:r*4,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST});w.copyBufferToBuffer(u,0,P,0,r*4),this.device.queue.submit([w.finish()]),await P.mapAsync(GPUMapMode.READ);let v=new Uint32Array(P.getMappedRange().slice(0));P.unmap();let U=new Float32Array(r);for(let B=0;B<r;B++)if(s==="COUNT")U[B]=v[B];else if(s==="SUM")U[B]=(v[B]|0)/1e3;else if(s==="MIN"||s==="MAX"){let A=v[B],k=A&2147483648?A^2147483648:~A;U[B]=new Float32Array(new Uint32Array([k]).buffer)[0]}return c.destroy(),f.destroy(),u.destroy(),P.destroy(),h.destroy(),p.destroy(),U}_cpuGroupBy(e){let t=new Map,r=new Uint32Array(e.length),s=0;for(let n=0;n<e.length;n++){let i=e[n];t.has(i)||t.set(i,s++),r[n]=t.get(i)}return{groupIds:r,numGroups:s}}_cpuGroupAggregate(e,t,r,s){let n=new Float32Array(r);s==="MIN"?n.fill(1/0):s==="MAX"&&n.fill(-1/0);for(let i=0;i<e.length;i++){let a=t[i],c=e[i];a>=r||isNaN(c)||(s==="COUNT"?n[a]++:s==="SUM"?n[a]+=c:s==="MIN"?n[a]=Math.min(n[a],c):s==="MAX"&&(n[a]=Math.max(n[a],c)))}return n}_createBuffer(e,t){let r=this.device.createBuffer({size:e.byteLength,usage:t|GPUBufferUsage.COPY_DST});return this.device.queue.writeBuffer(r,0,e),r}_createUniformBuffer(e){let t=this.device.createBuffer({size:Math.max(e.byteLength,16),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});return this.device.queue.writeBuffer(t,0,e),t}_nextPowerOf2(e){let t=1;for(;t<e;)t*=2;return t}getBufferPool(){return this.bufferPool}invalidateTable(e){this.bufferPool&&this.bufferPool.invalidatePrefix(e+":")}dispose(){this.bufferPool&&(this.bufferPool.clear(),this.bufferPool=null),this.pipelines.clear(),this.device=null,this.available=!1}},ze=null;function Le(){return ze||(ze=new be),ze}var _r=5e3,br=1e4,O={COSINE:0,L2:1,DOT_PRODUCT:2},Pr=`
struct DistanceParams {
    dim: u32,
    num_vectors: u32,
    num_queries: u32,
    metric: u32,
}

@group(0) @binding(0) var<uniform> params: DistanceParams;
@group(0) @binding(1) var<storage, read> queries: array<f32>;
@group(0) @binding(2) var<storage, read> vectors: array<f32>;
@group(0) @binding(3) var<storage, read_write> distances: array<f32>;

var<workgroup> shared_query: array<f32, 512>;

fn compute_dot(vec_offset: u32, dim: u32) -> f32 {
    var sum: f32 = 0.0;
    let dim4 = dim / 4u;
    for (var i = 0u; i < dim4; i++) {
        let base = i * 4u;
        sum += shared_query[base] * vectors[vec_offset + base];
        sum += shared_query[base + 1u] * vectors[vec_offset + base + 1u];
        sum += shared_query[base + 2u] * vectors[vec_offset + base + 2u];
        sum += shared_query[base + 3u] * vectors[vec_offset + base + 3u];
    }
    for (var i = dim4 * 4u; i < dim; i++) {
        sum += shared_query[i] * vectors[vec_offset + i];
    }
    return sum;
}

fn compute_l2(vec_offset: u32, dim: u32) -> f32 {
    var sum: f32 = 0.0;
    let dim4 = dim / 4u;
    for (var i = 0u; i < dim4; i++) {
        let base = i * 4u;
        let d0 = shared_query[base] - vectors[vec_offset + base];
        let d1 = shared_query[base + 1u] - vectors[vec_offset + base + 1u];
        let d2 = shared_query[base + 2u] - vectors[vec_offset + base + 2u];
        let d3 = shared_query[base + 3u] - vectors[vec_offset + base + 3u];
        sum += d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;
    }
    for (var i = dim4 * 4u; i < dim; i++) {
        let d = shared_query[i] - vectors[vec_offset + i];
        sum += d * d;
    }
    return sqrt(sum);
}

@compute @workgroup_size(256)
fn compute_distances(@builtin(global_invocation_id) gid: vec3<u32>,
                     @builtin(local_invocation_id) lid: vec3<u32>,
                     @builtin(workgroup_id) wid: vec3<u32>) {
    let query_idx = wid.y;
    let vec_idx = gid.x;

    if (vec_idx >= params.num_vectors || query_idx >= params.num_queries) {
        return;
    }

    let dim = params.dim;
    let tid = lid.x;

    for (var i = tid; i < dim && i < 512u; i += 256u) {
        shared_query[i] = queries[query_idx * dim + i];
    }
    workgroupBarrier();

    let vec_offset = vec_idx * dim;
    var result: f32 = 0.0;

    switch params.metric {
        case 0u, 2u: {
            result = compute_dot(vec_offset, dim);
        }
        case 1u: {
            result = compute_l2(vec_offset, dim);
        }
        default: {
            result = compute_dot(vec_offset, dim);
        }
    }

    distances[query_idx * params.num_vectors + vec_idx] = result;
}
`,xr=`
struct TopKParams {
    size: u32,
    k: u32,
    descending: u32,
    num_workgroups: u32,
}

@group(0) @binding(0) var<uniform> params: TopKParams;
@group(0) @binding(1) var<storage, read> input_scores: array<f32>;
@group(0) @binding(2) var<storage, read> input_indices: array<u32>;
@group(0) @binding(3) var<storage, read_write> output_scores: array<f32>;
@group(0) @binding(4) var<storage, read_write> output_indices: array<u32>;

var<workgroup> local_scores: array<f32, 512>;
var<workgroup> local_indices: array<u32, 512>;

fn should_swap(a: f32, b: f32, descending: bool) -> bool {
    if (descending) {
        return a < b;
    } else {
        return a > b;
    }
}

fn get_sentinel(descending: bool) -> f32 {
    if (descending) {
        return -3.4028235e+38;
    } else {
        return 3.4028235e+38;
    }
}

@compute @workgroup_size(256)
fn local_topk(@builtin(global_invocation_id) gid: vec3<u32>,
              @builtin(local_invocation_id) lid: vec3<u32>,
              @builtin(workgroup_id) wid: vec3<u32>) {
    let chunk_size = 512u;
    let base = wid.x * chunk_size;
    let tid = lid.x;
    let descending = params.descending == 1u;
    let sentinel = get_sentinel(descending);

    let idx1 = base + tid;
    let idx2 = base + tid + 256u;

    if (idx1 < params.size) {
        local_scores[tid] = input_scores[idx1];
        local_indices[tid] = input_indices[idx1];
    } else {
        local_scores[tid] = sentinel;
        local_indices[tid] = 0xFFFFFFFFu;
    }

    if (idx2 < params.size) {
        local_scores[tid + 256u] = input_scores[idx2];
        local_indices[tid + 256u] = input_indices[idx2];
    } else {
        local_scores[tid + 256u] = sentinel;
        local_indices[tid + 256u] = 0xFFFFFFFFu;
    }

    workgroupBarrier();

    for (var k = 2u; k <= chunk_size; k = k << 1u) {
        for (var j = k >> 1u; j > 0u; j = j >> 1u) {
            for (var t = 0u; t < 2u; t++) {
                let i = tid + t * 256u;
                let ixj = i ^ j;

                if (ixj > i && ixj < chunk_size) {
                    let direction = ((i & k) == 0u) == descending;
                    if (should_swap(local_scores[i], local_scores[ixj], direction)) {
                        let tmp_score = local_scores[i];
                        local_scores[i] = local_scores[ixj];
                        local_scores[ixj] = tmp_score;
                        let tmp_idx = local_indices[i];
                        local_indices[i] = local_indices[ixj];
                        local_indices[ixj] = tmp_idx;
                    }
                }
            }
            workgroupBarrier();
        }
    }

    let k_per_wg = min(params.k, chunk_size);
    if (tid < k_per_wg) {
        let out_base = wid.x * params.k;
        output_scores[out_base + tid] = local_scores[tid];
        output_indices[out_base + tid] = local_indices[tid];
    }
    if (tid + 256u < k_per_wg) {
        let out_base = wid.x * params.k;
        output_scores[out_base + tid + 256u] = local_scores[tid + 256u];
        output_indices[out_base + tid + 256u] = local_indices[tid + 256u];
    }
}

struct MergeParams {
    num_candidates: u32,
    k: u32,
    descending: u32,
    _pad: u32,
}

@group(0) @binding(0) var<uniform> merge_params: MergeParams;
@group(0) @binding(1) var<storage, read> merge_scores: array<f32>;
@group(0) @binding(2) var<storage, read> merge_indices: array<u32>;
@group(0) @binding(3) var<storage, read_write> final_scores: array<f32>;
@group(0) @binding(4) var<storage, read_write> final_indices: array<u32>;

@compute @workgroup_size(256)
fn merge_topk(@builtin(local_invocation_id) lid: vec3<u32>) {
    let tid = lid.x;
    let n = merge_params.num_candidates;
    let k = merge_params.k;
    let descending = merge_params.descending == 1u;
    let sentinel = get_sentinel(descending);

    let n_local = min(n, 512u);

    if (tid < n_local) {
        local_scores[tid] = merge_scores[tid];
        local_indices[tid] = merge_indices[tid];
    } else if (tid < 512u) {
        local_scores[tid] = sentinel;
        local_indices[tid] = 0xFFFFFFFFu;
    }

    if (tid + 256u < n_local) {
        local_scores[tid + 256u] = merge_scores[tid + 256u];
        local_indices[tid + 256u] = merge_indices[tid + 256u];
    } else if (tid + 256u < 512u) {
        local_scores[tid + 256u] = sentinel;
        local_indices[tid + 256u] = 0xFFFFFFFFu;
    }

    workgroupBarrier();

    let chunk_size = 512u;
    for (var ks = 2u; ks <= chunk_size; ks = ks << 1u) {
        for (var j = ks >> 1u; j > 0u; j = j >> 1u) {
            for (var t = 0u; t < 2u; t++) {
                let i = tid + t * 256u;
                let ixj = i ^ j;

                if (ixj > i && ixj < chunk_size) {
                    let direction = ((i & ks) == 0u) == descending;
                    if (should_swap(local_scores[i], local_scores[ixj], direction)) {
                        let tmp_score = local_scores[i];
                        local_scores[i] = local_scores[ixj];
                        local_scores[ixj] = tmp_score;
                        let tmp_idx = local_indices[i];
                        local_indices[i] = local_indices[ixj];
                        local_indices[ixj] = tmp_idx;
                    }
                }
            }
            workgroupBarrier();
        }
    }

    if (tid < k) {
        final_scores[tid] = local_scores[tid];
        final_indices[tid] = local_indices[tid];
    }
}

struct InitParams {
    size: u32,
}

@group(0) @binding(0) var<uniform> init_params: InitParams;
@group(0) @binding(1) var<storage, read_write> indices: array<u32>;

@compute @workgroup_size(256)
fn init_indices(@builtin(global_invocation_id) gid: vec3<u32>) {
    let idx = gid.x;
    if (idx < init_params.size) {
        indices[idx] = idx;
    }
}
`,Pe=class{constructor(){this.device=null,this.pipelines=new Map,this.available=!1,this._initPromise=null,this.bufferPool=null}async init(){return this._initPromise?this._initPromise:(this._initPromise=this._doInit(),this._initPromise)}async _doInit(){if(typeof navigator>"u"||!navigator.gpu)return console.log("[GPUVectorSearch] WebGPU not available"),!1;try{let e=await navigator.gpu.requestAdapter();return e?(this.device=await e.requestDevice({requiredLimits:{maxStorageBufferBindingSize:256*1024*1024,maxBufferSize:256*1024*1024}}),await this._compileShaders(),this.bufferPool=R(this.device),this.available=!0,console.log("[GPUVectorSearch] Initialized"),!0):!1}catch(e){return console.error("[GPUVectorSearch] Init failed:",e),!1}}async _compileShaders(){let e=this.device.createShaderModule({code:Pr});this.pipelines.set("distance",this.device.createComputePipeline({layout:"auto",compute:{module:e,entryPoint:"compute_distances"}}));let t=this.device.createShaderModule({code:xr});this.pipelines.set("local_topk",this.device.createComputePipeline({layout:"auto",compute:{module:t,entryPoint:"local_topk"}})),this.pipelines.set("merge_topk",this.device.createComputePipeline({layout:"auto",compute:{module:t,entryPoint:"merge_topk"}})),this.pipelines.set("init_indices",this.device.createComputePipeline({layout:"auto",compute:{module:t,entryPoint:"init_indices"}}))}isAvailable(){return this.available}async computeDistances(e,t,r=1,s=O.COSINE,n={}){let i=t.length,a=e.length/r;if(!this.available||i<_r)return this._cpuComputeDistances(e,t,r,s);let c=new Float32Array(i*a);for(let y=0;y<i;y++)c.set(t[y],y*a);let f=this.device.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.device.queue.writeBuffer(f,0,new Uint32Array([a,i,r,s]));let u=this.device.createBuffer({size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});this.device.queue.writeBuffer(u,0,e);let l,h=!1;n.vectorsBufferKey&&this.bufferPool?(l=this.bufferPool.getStorageBuffer(n.vectorsBufferKey,c),h=!0):(l=this.device.createBuffer({size:c.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.device.queue.writeBuffer(l,0,c));let d=this.device.createBuffer({size:r*i*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),g=this.device.createBuffer({size:r*i*4,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),p=this.device.createBindGroup({layout:this.pipelines.get("distance").getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:u}},{binding:2,resource:{buffer:l}},{binding:3,resource:{buffer:d}}]}),_=this.device.createCommandEncoder(),w=_.beginComputePass();w.setPipeline(this.pipelines.get("distance")),w.setBindGroup(0,p),w.dispatchWorkgroups(Math.ceil(i/256),r,1),w.end(),_.copyBufferToBuffer(d,0,g,0,r*i*4),this.device.queue.submit([_.finish()]),await g.mapAsync(GPUMapMode.READ);let m=new Float32Array(g.getMappedRange().slice(0));return g.unmap(),f.destroy(),u.destroy(),h||l.destroy(),d.destroy(),g.destroy(),m}async topK(e,t=null,r=10,s=!0){let n=e.length;if(!this.available||n<br)return this._cpuTopK(e,t,r,s);if(!t){t=new Uint32Array(n);for(let B=0;B<n;B++)t[B]=B}let i=Math.ceil(n/512),a=Math.min(r,512),c=i*a,f=this.device.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.device.queue.writeBuffer(f,0,new Uint32Array([n,r,s?1:0,i]));let u=this.device.createBuffer({size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});this.device.queue.writeBuffer(u,0,e);let l=this.device.createBuffer({size:t.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});this.device.queue.writeBuffer(l,0,t);let h=this.device.createBuffer({size:c*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),d=this.device.createBuffer({size:c*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),g=this.device.createBindGroup({layout:this.pipelines.get("local_topk").getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:u}},{binding:2,resource:{buffer:l}},{binding:3,resource:{buffer:h}},{binding:4,resource:{buffer:d}}]}),p=this.device.createCommandEncoder(),_=p.beginComputePass();_.setPipeline(this.pipelines.get("local_topk")),_.setBindGroup(0,g),_.dispatchWorkgroups(i,1,1),_.end(),this.device.queue.submit([p.finish()]);let w=this.device.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.device.queue.writeBuffer(w,0,new Uint32Array([c,r,s?1:0,0]));let m=this.device.createBuffer({size:r*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),y=this.device.createBuffer({size:r*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),b=this.device.createBuffer({size:r*4,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),x=this.device.createBuffer({size:r*4,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),P=this.device.createBindGroup({layout:this.pipelines.get("merge_topk").getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:w}},{binding:1,resource:{buffer:h}},{binding:2,resource:{buffer:d}},{binding:3,resource:{buffer:m}},{binding:4,resource:{buffer:y}}]});p=this.device.createCommandEncoder(),_=p.beginComputePass(),_.setPipeline(this.pipelines.get("merge_topk")),_.setBindGroup(0,P),_.dispatchWorkgroups(1,1,1),_.end(),p.copyBufferToBuffer(m,0,b,0,r*4),p.copyBufferToBuffer(y,0,x,0,r*4),this.device.queue.submit([p.finish()]),await Promise.all([b.mapAsync(GPUMapMode.READ),x.mapAsync(GPUMapMode.READ)]);let v=new Float32Array(b.getMappedRange().slice(0)),U=new Uint32Array(x.getMappedRange().slice(0));return b.unmap(),x.unmap(),f.destroy(),u.destroy(),l.destroy(),h.destroy(),d.destroy(),w.destroy(),m.destroy(),y.destroy(),b.destroy(),x.destroy(),{indices:U,scores:v}}async search(e,t,r=10,s={}){let{metric:n=O.COSINE}=s,i=await this.computeDistances(e,t,1,n),a=n===O.COSINE||n===O.DOT_PRODUCT;return await this.topK(i,null,r,a)}async batchSearch(e,t,r=10,s={}){let{metric:n=O.COSINE}=s,i=e.length,a=e[0].length,c=new Float32Array(i*a);for(let d=0;d<i;d++)c.set(e[d],d*a);let f=await this.computeDistances(c,t,i,n),u=n===O.COSINE||n===O.DOT_PRODUCT,l=[],h=t.length;for(let d=0;d<i;d++){let g=new Float32Array(f.buffer,d*h*4,h),p=await this.topK(new Float32Array(g),null,r,u);l.push(p)}return l}_cpuComputeDistances(e,t,r,s){let n=e.length/r,i=t.length,a=new Float32Array(r*i);for(let c=0;c<r;c++){let f=c*n;for(let u=0;u<i;u++){let l=t[u],h=0;if(s===O.L2){for(let d=0;d<n;d++){let g=e[f+d]-l[d];h+=g*g}h=Math.sqrt(h)}else for(let d=0;d<n;d++)h+=e[f+d]*l[d];a[c*i+u]=h}}return a}_cpuTopK(e,t,r,s){let n=e.length;if(!t){t=new Uint32Array(n);for(let c=0;c<n;c++)t[c]=c}let i=Array.from(e).map((c,f)=>({score:c,idx:t[f]}));s?i.sort((c,f)=>f.score-c.score):i.sort((c,f)=>c.score-f.score);let a=i.slice(0,r);return{indices:new Uint32Array(a.map(c=>c.idx)),scores:new Float32Array(a.map(c=>c.score))}}getBufferPool(){return this.bufferPool}invalidateTable(e){this.bufferPool&&this.bufferPool.invalidatePrefix(e+":")}dispose(){this.bufferPool&&(this.bufferPool.clear(),this.bufferPool=null),this.pipelines.clear(),this.device=null,this.available=!1}},Ne=null;function Y(){return Ne||(Ne=new Pe),Ne}var Fs=256*1024*1024;var Ms=256*1024*1024;var ne=class{constructor(e,t){this.lanceql=e,this.wasm=e.wasm,this.memory=e.memory;let r=new Uint8Array(t);if(this.dataPtr=this.wasm.alloc(r.length),!this.dataPtr)throw new Error("Failed to allocate memory for Lance file");if(this.dataLen=r.length,new Uint8Array(this.memory.buffer).set(r,this.dataPtr),this.wasm.openFile(this.dataPtr,this.dataLen)===0)throw this.wasm.free(this.dataPtr,this.dataLen),new Error("Failed to open Lance file")}close(){this.wasm.closeFile(),this.dataPtr&&(this.wasm.free(this.dataPtr,this.dataLen),this.dataPtr=null)}get numColumns(){return this.wasm.getNumColumns()}getRowCount(e){return this.wasm.getRowCount(e)}getColumnDebugInfo(e){return{offset:this.wasm.getColumnBufferOffset(e),size:this.wasm.getColumnBufferSize(e),rows:this.wasm.getRowCount(e)}}readInt64Column(e){let t=Number(this.getRowCount(e));if(t===0)return new BigInt64Array(0);let r=this.wasm.allocInt64Buffer(t);if(!r)throw new Error("Failed to allocate int64 buffer");try{let s=this.wasm.readInt64Column(e,r,t),n=new BigInt64Array(s),i=new BigInt64Array(this.memory.buffer,r,s);return n.set(i),n}finally{this.wasm.freeInt64Buffer(r,t)}}readFloat64Column(e){let t=Number(this.getRowCount(e));if(t===0)return new Float64Array(0);let r=this.wasm.allocFloat64Buffer(t);if(!r)throw new Error("Failed to allocate float64 buffer");try{let s=this.wasm.readFloat64Column(e,r,t),n=new Float64Array(s),i=new Float64Array(this.memory.buffer,r,s);return n.set(i),n}finally{this.wasm.freeFloat64Buffer(r,t)}}readInt32Column(e){let t=Number(this.getRowCount(e));if(t===0)return new Int32Array(0);let r=this.wasm.allocInt32Buffer(t);if(!r)throw new Error("Failed to allocate int32 buffer");try{let s=this.wasm.readInt32Column(e,r,t),n=new Int32Array(s),i=new Int32Array(this.memory.buffer,r,s);return n.set(i),n}finally{this.wasm.free(r,t*4)}}readInt16Column(e){let t=Number(this.getRowCount(e));if(t===0)return new Int16Array(0);let r=this.wasm.allocInt16Buffer(t);if(!r)throw new Error("Failed to allocate int16 buffer");try{let s=this.wasm.readInt16Column(e,r,t),n=new Int16Array(s),i=new Int16Array(this.memory.buffer,r,s);return n.set(i),n}finally{this.wasm.free(r,t*2)}}readInt8Column(e){let t=Number(this.getRowCount(e));if(t===0)return new Int8Array(0);let r=this.wasm.allocInt8Buffer(t);if(!r)throw new Error("Failed to allocate int8 buffer");try{let s=this.wasm.readInt8Column(e,r,t),n=new Int8Array(s),i=new Int8Array(this.memory.buffer,r,s);return n.set(i),n}finally{this.wasm.free(r,t)}}readUint64Column(e){let t=Number(this.getRowCount(e));if(t===0)return new BigUint64Array(0);let r=this.wasm.allocUint64Buffer(t);if(!r)throw new Error("Failed to allocate uint64 buffer");try{let s=this.wasm.readUint64Column(e,r,t),n=new BigUint64Array(s),i=new BigUint64Array(this.memory.buffer,r,s);return n.set(i),n}finally{this.wasm.free(r,t*8)}}readUint32Column(e){let t=Number(this.getRowCount(e));if(t===0)return new Uint32Array(0);let r=this.wasm.allocIndexBuffer(t);if(!r)throw new Error("Failed to allocate uint32 buffer");try{let s=this.wasm.readUint32Column(e,r,t),n=new Uint32Array(s),i=new Uint32Array(this.memory.buffer,r,s);return n.set(i),n}finally{this.wasm.free(r,t*4)}}readUint16Column(e){let t=Number(this.getRowCount(e));if(t===0)return new Uint16Array(0);let r=this.wasm.allocUint16Buffer(t);if(!r)throw new Error("Failed to allocate uint16 buffer");try{let s=this.wasm.readUint16Column(e,r,t),n=new Uint16Array(s),i=new Uint16Array(this.memory.buffer,r,s);return n.set(i),n}finally{this.wasm.free(r,t*2)}}readUint8Column(e){let t=Number(this.getRowCount(e));if(t===0)return new Uint8Array(0);let r=this.wasm.allocStringBuffer(t);if(!r)throw new Error("Failed to allocate uint8 buffer");try{let s=this.wasm.readUint8Column(e,r,t),n=new Uint8Array(s),i=new Uint8Array(this.memory.buffer,r,s);return n.set(i),n}finally{this.wasm.free(r,t)}}readFloat32Column(e){let t=Number(this.getRowCount(e));if(t===0)return new Float32Array(0);let r=this.wasm.allocFloat32Buffer(t);if(!r)throw new Error("Failed to allocate float32 buffer");try{let s=this.wasm.readFloat32Column(e,r,t),n=new Float32Array(s),i=new Float32Array(this.memory.buffer,r,s);return n.set(i),n}finally{this.wasm.free(r,t*4)}}readBoolColumn(e){let t=Number(this.getRowCount(e));if(t===0)return new Uint8Array(0);let r=this.wasm.allocStringBuffer(t);if(!r)throw new Error("Failed to allocate bool buffer");try{let s=this.wasm.readBoolColumn(e,r,t),n=new Uint8Array(s),i=new Uint8Array(this.memory.buffer,r,s);return n.set(i),n}finally{this.wasm.free(r,t)}}readInt32AtIndices(e,t){if(t.length===0)return new Int32Array(0);let r=this.wasm.allocIndexBuffer(t.length);if(!r)throw new Error("Failed to allocate index buffer");let s=this.wasm.allocInt32Buffer(t.length);if(!s)throw this.wasm.free(r,t.length*4),new Error("Failed to allocate output buffer");try{new Uint32Array(this.memory.buffer,r,t.length).set(t);let n=this.wasm.readInt32AtIndices(e,r,t.length,s),i=new Int32Array(n),a=new Int32Array(this.memory.buffer,s,n);return i.set(a),i}finally{this.wasm.free(r,t.length*4),this.wasm.free(s,t.length*4)}}readFloat32AtIndices(e,t){if(t.length===0)return new Float32Array(0);let r=this.wasm.allocIndexBuffer(t.length);if(!r)throw new Error("Failed to allocate index buffer");let s=this.wasm.allocFloat32Buffer(t.length);if(!s)throw this.wasm.free(r,t.length*4),new Error("Failed to allocate output buffer");try{new Uint32Array(this.memory.buffer,r,t.length).set(t);let n=this.wasm.readFloat32AtIndices(e,r,t.length,s),i=new Float32Array(n),a=new Float32Array(this.memory.buffer,s,n);return i.set(a),i}finally{this.wasm.free(r,t.length*4),this.wasm.free(s,t.length*4)}}readUint8AtIndices(e,t){if(t.length===0)return new Uint8Array(0);let r=this.wasm.allocIndexBuffer(t.length);if(!r)throw new Error("Failed to allocate index buffer");let s=this.wasm.allocStringBuffer(t.length);if(!s)throw this.wasm.free(r,t.length*4),new Error("Failed to allocate output buffer");try{new Uint32Array(this.memory.buffer,r,t.length).set(t);let n=this.wasm.readUint8AtIndices(e,r,t.length,s),i=new Uint8Array(n),a=new Uint8Array(this.memory.buffer,s,n);return i.set(a),i}finally{this.wasm.free(r,t.length*4),this.wasm.free(s,t.length)}}readBoolAtIndices(e,t){if(t.length===0)return new Uint8Array(0);let r=this.wasm.allocIndexBuffer(t.length);if(!r)throw new Error("Failed to allocate index buffer");let s=this.wasm.allocStringBuffer(t.length);if(!s)throw this.wasm.free(r,t.length*4),new Error("Failed to allocate output buffer");try{new Uint32Array(this.memory.buffer,r,t.length).set(t);let n=this.wasm.readBoolAtIndices(e,r,t.length,s),i=new Uint8Array(n),a=new Uint8Array(this.memory.buffer,s,n);return i.set(a),i}finally{this.wasm.free(r,t.length*4),this.wasm.free(s,t.length)}}filterInt64(e,t,r){let s=Number(this.getRowCount(e));if(s===0)return new Uint32Array(0);let n=this.wasm.allocIndexBuffer(s);if(!n)throw new Error("Failed to allocate index buffer");try{let i=this.wasm.filterInt64Column(e,t,BigInt(r),n,s),a=new Uint32Array(i),c=new Uint32Array(this.memory.buffer,n,i);return a.set(c),a}finally{this.wasm.free(n,s*4)}}filterFloat64(e,t,r){let s=Number(this.getRowCount(e));if(s===0)return new Uint32Array(0);let n=this.wasm.allocIndexBuffer(s);if(!n)throw new Error("Failed to allocate index buffer");try{let i=this.wasm.filterFloat64Column(e,t,r,n,s),a=new Uint32Array(i),c=new Uint32Array(this.memory.buffer,n,i);return a.set(c),a}finally{this.wasm.free(n,s*4)}}readInt64AtIndices(e,t){if(t.length===0)return new BigInt64Array(0);let r=this.wasm.allocIndexBuffer(t.length);if(!r)throw new Error("Failed to allocate index buffer");let s=this.wasm.allocInt64Buffer(t.length);if(!s)throw this.wasm.free(r,t.length*4),new Error("Failed to allocate output buffer");try{new Uint32Array(this.memory.buffer,r,t.length).set(t);let n=this.wasm.readInt64AtIndices(e,r,t.length,s),i=new BigInt64Array(n),a=new BigInt64Array(this.memory.buffer,s,n);return i.set(a),i}finally{this.wasm.free(r,t.length*4),this.wasm.freeInt64Buffer(s,t.length)}}readFloat64AtIndices(e,t){if(t.length===0)return new Float64Array(0);let r=this.wasm.allocIndexBuffer(t.length);if(!r)throw new Error("Failed to allocate index buffer");let s=this.wasm.allocFloat64Buffer(t.length);if(!s)throw this.wasm.free(r,t.length*4),new Error("Failed to allocate output buffer");try{new Uint32Array(this.memory.buffer,r,t.length).set(t);let n=this.wasm.readFloat64AtIndices(e,r,t.length,s),i=new Float64Array(n),a=new Float64Array(this.memory.buffer,s,n);return i.set(a),i}finally{this.wasm.free(r,t.length*4),this.wasm.freeFloat64Buffer(s,t.length)}}sumInt64(e){return this.wasm.sumInt64Column(e)}sumFloat64(e){return this.wasm.sumFloat64Column(e)}minInt64(e){return this.wasm.minInt64Column(e)}maxInt64(e){return this.wasm.maxInt64Column(e)}avgFloat64(e){return this.wasm.avgFloat64Column(e)}debugStringColInfo(e){let t=this.wasm.debugStringColInfo(e);return{offsetsSize:Number(BigInt(t)>>32n),dataSize:Number(BigInt(t)&0xFFFFFFFFn)}}debugReadStringInfo(e,t){let r=this.wasm.debugReadStringInfo(e,t);if((r&0xFFFF0000n)===0xDEAD0000n){let s=Number(r&0xFFFFn);return{error:{1:"No file data",2:"No column entry",3:"Col meta out of bounds",4:"Not a string column",5:"Row out of bounds",6:"Invalid offset size"}[s]||`Unknown error ${s}`}}return{strStart:Number(BigInt(r)>>32n),strLen:Number(BigInt(r)&0xFFFFFFFFn)}}debugStringDataStart(e){let t=this.wasm.debugStringDataStart(e);return{dataStart:Number(BigInt(t)>>32n),fileLen:Number(BigInt(t)&0xFFFFFFFFn)}}getStringCount(e){return Number(this.wasm.getStringCount(e))}readStringAt(e,t){let s=this.wasm.allocStringBuffer(4096);if(!s)throw new Error("Failed to allocate string buffer");try{let n=this.wasm.readStringAt(e,t,s,4096);if(n===0)return"";let i=new Uint8Array(this.memory.buffer,s,Math.min(n,4096));return new TextDecoder().decode(i)}finally{this.wasm.free(s,4096)}}readStringColumn(e,t=1e3){let r=Math.min(this.getStringCount(e),t);if(r===0)return[];let s=[];for(let n=0;n<r;n++)s.push(this.readStringAt(e,n));return s}readStringsAtIndices(e,t){if(t.length===0)return[];let r=Math.min(t.length*256,256*1024),s=this.wasm.allocIndexBuffer(t.length);if(!s)throw new Error("Failed to allocate index buffer");let n=this.wasm.allocStringBuffer(r);if(!n)throw this.wasm.free(s,t.length*4),new Error("Failed to allocate string buffer");let i=this.wasm.allocU32Buffer(t.length);if(!i)throw this.wasm.free(s,t.length*4),this.wasm.free(n,r),new Error("Failed to allocate length buffer");try{new Uint32Array(this.memory.buffer,s,t.length).set(t);let a=this.wasm.readStringsAtIndices(e,s,t.length,n,r,i),c=new Uint32Array(this.memory.buffer,i,t.length),f=[],u=0;for(let l=0;l<t.length;l++){let h=c[l];if(h>0&&u+h<=a){let d=new Uint8Array(this.memory.buffer,n+u,h);f.push(new TextDecoder().decode(d)),u+=h}else f.push("")}return f}finally{this.wasm.free(s,t.length*4),this.wasm.free(n,r),this.wasm.free(i,t.length*4)}}getVectorInfo(e){let t=this.wasm.getVectorInfo(e);return{rows:Number(BigInt(t)>>32n),dimension:Number(BigInt(t)&0xFFFFFFFFn)}}readVectorAt(e,t){let r=this.getVectorInfo(e);if(r.dimension===0)return new Float32Array(0);let s=this.wasm.allocFloat32Buffer(r.dimension);if(!s)throw new Error("Failed to allocate vector buffer");try{let n=this.wasm.readVectorAt(e,t,s,r.dimension),i=new Float32Array(n),a=new Float32Array(this.memory.buffer,s,n);return i.set(a),i}finally{this.wasm.free(s,r.dimension*4)}}cosineSimilarity(e,t){if(e.length!==t.length)throw new Error("Vector dimensions must match");let r=this.wasm.allocFloat32Buffer(e.length),s=this.wasm.allocFloat32Buffer(t.length);if(!r||!s)throw new Error("Failed to allocate buffers");try{return new Float32Array(this.memory.buffer,r,e.length).set(e),new Float32Array(this.memory.buffer,s,t.length).set(t),this.wasm.cosineSimilarity(r,s,e.length)}finally{this.wasm.free(r,e.length*4),this.wasm.free(s,t.length*4)}}batchCosineSimilarity(e,t,r=!0){if(t.length===0)return new Float32Array(0);let s=e.length,n=t.length,i=this.wasm.allocFloat32Buffer(s),a=this.wasm.allocFloat32Buffer(n*s),c=this.wasm.allocFloat32Buffer(n);if(!i||!a||!c)throw new Error("Failed to allocate WASM buffers");try{new Float32Array(this.memory.buffer,i,s).set(e);let f=new Float32Array(this.memory.buffer,a,n*s);for(let l=0;l<n;l++)f.set(t[l],l*s);this.wasm.batchCosineSimilarity(i,a,s,n,c,r?1:0);let u=new Float32Array(n);return u.set(new Float32Array(this.memory.buffer,c,n)),u}finally{this.wasm.free(i,s*4),this.wasm.free(a,n*s*4),this.wasm.free(c,n*4)}}readAllVectors(e){let t=this.getVectorInfo(e);if(t.dimension===0||t.rows===0)return[];let r=t.dimension,s=t.rows,n=[],i=this.wasm.allocFloat32Buffer(s*r);if(!i)throw new Error("Failed to allocate vector buffer");try{if(this.wasm.readVectorColumn){let a=this.wasm.readVectorColumn(e,i,s*r),c=new Float32Array(this.memory.buffer,i,a);for(let f=0;f<s&&f*r<a;f++){let u=new Float32Array(r);u.set(c.subarray(f*r,(f+1)*r)),n.push(u)}}else for(let a=0;a<s;a++)n.push(this.readVectorAt(e,a));return n}finally{this.wasm.free(i,s*r*4)}}async vectorSearch(e,t,r=10,s=null){let n=t.length,a=this.getVectorInfo(e).rows,c=z();if(c.isAvailable()){s&&s(0,a);let l=this.readAllVectors(e);s&&s(a,a);let h=await c.batchCosineSimilarity(t,l,!0);return await Y().topK(h,null,r,!0)}s&&s(0,a);let f=this.readAllVectors(e);s&&s(a,a);let u=this.lanceql.batchCosineSimilarity(t,f,!0);return await Y().topK(u,null,r,!0)}df(){return new DataFrame(this)}};rt(ne,"Op",{EQ:0,NE:1,LT:2,LE:3,GT:4,GE:5});var $e=class{constructor(e=null,t={}){this.storage=e,this.cacheDir=t.cacheDir||"_cache",this.maxFileSize=t.maxFileSize||10*1024*1024,this.maxCacheSize=t.maxCacheSize||500*1024*1024,this.enabled=t.enabled??!0,this._stats={hits:0,misses:0,bytesFromCache:0,bytesFromNetwork:0},this._metaCache=new Map,this._metaCacheOrder=[],this.maxMetaCacheEntries=t.maxMetaCacheEntries||100}_setMetaCache(e,t){let r=this._metaCacheOrder.indexOf(e);for(r!==-1&&this._metaCacheOrder.splice(r,1);this._metaCacheOrder.length>=this.maxMetaCacheEntries;){let s=this._metaCacheOrder.shift();this._metaCache.delete(s)}this._metaCache.set(e,t),this._metaCacheOrder.push(e)}async init(){this.storage||(this.storage=new OPFSStorage,await this.storage.open())}_getCacheKey(e){let t=0;for(let r=0;r<e.length;r++){let s=e.charCodeAt(r);t=(t<<5)-t+s,t=t&t}return Math.abs(t).toString(36)}_getCachePath(e,t=""){let r=this._getCacheKey(e);return`${this.cacheDir}/${r}${t}`}async isCached(e){if(!this.enabled)return{cached:!1};try{await this.init();let t=this._getCachePath(e,"/meta.json"),r=await this.storage.load(t);return r?{cached:!0,meta:JSON.parse(new TextDecoder().decode(r))}:{cached:!1}}catch{return{cached:!1}}}async getFile(e,t=null){if(!this.enabled)return this._fetchFile(e);await this.init();let{cached:r,meta:s}=await this.isCached(e);if(r&&s.fullFile){let i=this._getCachePath(e,"/data.lance"),a=await this.storage.load(i);if(a)return this._stats.hits++,this._stats.bytesFromCache+=a.byteLength,console.log(`[HotTierCache] HIT: ${e} (${(a.byteLength/1024).toFixed(1)} KB)`),a}this._stats.misses++;let n=await this._fetchFile(e);return this._stats.bytesFromNetwork+=n.byteLength,n.byteLength<=this.maxFileSize&&await this._cacheFile(e,n),n}async getRange(e,t,r,s=null){if(!this.enabled)return this._fetchRange(e,t,r);let n=this._metaCache.get(e);if(n?.fullFileData){let a=n.fullFileData;if(a.byteLength>r)return this._stats.hits++,this._stats.bytesFromCache+=r-t+1,a.slice(t,r+1).buffer}if(await this.init(),!n){let{cached:a,meta:c}=await this.isCached(e);if(a&&c.fullFile){let f=this._getCachePath(e,"/data.lance"),u=await this.storage.load(f);if(u&&u.byteLength>r)return this._setMetaCache(e,{meta:c,fullFileData:u}),this._stats.hits++,this._stats.bytesFromCache+=r-t+1,u.slice(t,r+1).buffer}this._setMetaCache(e,{meta:a?c:null,fullFileData:null})}this._stats.misses++;let i=await this._fetchRange(e,t,r);return this._stats.bytesFromNetwork+=i.byteLength,i}async prefetch(e,t=null){await this.init();let{cached:r,meta:s}=await this.isCached(e);if(r&&s.fullFile){console.log(`[HotTierCache] Already cached: ${e}`);return}console.log(`[HotTierCache] Prefetching: ${e}`);let n=await this._fetchFile(e,t);await this._cacheFile(e,n),console.log(`[HotTierCache] Cached: ${e} (${(n.byteLength/1024/1024).toFixed(2)} MB)`)}async evict(e){await this.init();let t=this._getCachePath(e);await this.storage.delete(t),console.log(`[HotTierCache] Evicted: ${e}`)}async clear(){await this.init(),await this.storage.delete(this.cacheDir),this._stats={hits:0,misses:0,bytesFromCache:0,bytesFromNetwork:0},console.log("[HotTierCache] Cleared all cache")}getStats(){let e=this._stats.hits+this._stats.misses>0?(this._stats.hits/(this._stats.hits+this._stats.misses)*100).toFixed(1):0;return{...this._stats,hitRate:`${e}%`,bytesFromCacheMB:(this._stats.bytesFromCache/1024/1024).toFixed(2),bytesFromNetworkMB:(this._stats.bytesFromNetwork/1024/1024).toFixed(2)}}async _fetchFile(e,t=null){let r=await fetch(e);if(!r.ok)throw new Error(`HTTP error: ${r.status}`);if(t&&r.headers.get("content-length")){let n=parseInt(r.headers.get("content-length")),i=r.body.getReader(),a=[],c=0;for(;;){let{done:l,value:h}=await i.read();if(l)break;a.push(h),c+=h.length,t(c,n)}let f=new Uint8Array(c),u=0;for(let l of a)f.set(l,u),u+=l.length;return f}let s=await r.arrayBuffer();return new Uint8Array(s)}async _fetchRange(e,t,r){let s=await fetch(e,{headers:{Range:`bytes=${t}-${r}`}});if(!s.ok&&s.status!==206)throw new Error(`HTTP error: ${s.status}`);return s.arrayBuffer()}async _cacheFile(e,t){let r=this._getCachePath(e,"/meta.json"),s=this._getCachePath(e,"/data.lance"),n={url:e,size:t.byteLength,cachedAt:Date.now(),fullFile:!0,ranges:null};await this.storage.save(r,new TextEncoder().encode(JSON.stringify(n))),await this.storage.save(s,t)}async _cacheRange(e,t,r,s,n){let i=this._getCachePath(e,"/meta.json"),a=this._getCachePath(e,`/ranges/${t}-${r}`),c,{cached:f,meta:u}=await this.isCached(e);f?(c=u,c.ranges=c.ranges||[]):c={url:e,size:n,cachedAt:Date.now(),fullFile:!1,ranges:[]},c.ranges.push({start:t,end:r,cachedAt:Date.now()}),c.ranges=this._mergeRanges(c.ranges),await this.storage.save(i,new TextEncoder().encode(JSON.stringify(c))),await this.storage.save(a,s)}_mergeRanges(e){if(e.length<=1)return e;e.sort((r,s)=>r.start-s.start);let t=[e[0]];for(let r=1;r<e.length;r++){let s=t[t.length-1],n=e[r];n.start<=s.end+1?s.end=Math.max(s.end,n.end):t.push(n)}return t}},De=null;function lt(){return De||(De=new $e),De}async function ut(o){let e=[1,5,10,20,50,100],t=await Promise.all(e.map(async s=>{try{return(await fetch(`${o}/_versions/${s}.manifest`,{method:"HEAD"})).ok?s:0}catch{return 0}})),r=Math.max(...t);if(r===0)return null;for(let s=r+1;s<=r+30;s++)try{if((await fetch(`${o}/_versions/${s}.manifest`,{method:"HEAD"})).ok)r=s;else break}catch{break}return r}function ft(o){let t=new DataView(o.buffer,o.byteOffset).getUint32(0,!0),r=o.slice(4,4+t),s=0,n=null,i=null,a=(c,f)=>{let u=0,l=0,h=f;for(;h<c.length;){let d=c[h++];if(u|=(d&127)<<l,(d&128)===0)break;l+=7}return{value:u,pos:h}};for(;s<r.length;){let c=a(r,s);s=c.pos;let f=c.value>>3,u=c.value&7;if(u===2){let l=a(r,s);s=l.pos;let h=r.slice(s,s+l.value);if(s+=l.value,f===1){let d=Br(h);d?.uuid&&(n=d.uuid,i=d.fieldId)}}else u===0?s=a(r,s).pos:u===5?s+=4:u===1&&(s+=8)}return n?{uuid:n,fieldId:i}:null}function Br(o){let e=0,t=null,r=null,s=()=>{let n=0,i=0;for(;e<o.length;){let a=o[e++];if(n|=(a&127)<<i,(a&128)===0)break;i+=7}return n};for(;e<o.length;){let n=s(),i=n>>3,a=n&7;if(a===2){let c=s(),f=o.slice(e,e+c);e+=c,i===1&&(t=Ur(f))}else if(a===0){let c=s();i===2&&(r=c)}else a===5?e+=4:a===1&&(e+=8)}return{uuid:t,fieldId:r}}function Ur(o){let e=0;for(;e<o.length;){let t=o[e++],r=t>>3,s=t&7;if(s===2&&r===1){let n=o[e++],i=o.slice(e,e+n),a=Array.from(i).map(c=>c.toString(16).padStart(2,"0")).join("");return`${a.slice(0,8)}-${a.slice(8,12)}-${a.slice(12,16)}-${a.slice(16,20)}-${a.slice(20,32)}`}else if(s===0)for(;e<o.length&&o[e++]&128;);else s===5?e+=4:s===1&&(e+=8)}return null}function ht(o,e,t){let r=new t,s=dt(o);if(s&&(s.centroids&&(r.centroids=s.centroids.data,r.numPartitions=s.centroids.numPartitions,r.dimension=s.centroids.dimension),s.offsets?.length>0&&(r.partitionOffsets=s.offsets),s.lengths?.length>0&&(r.partitionLengths=s.lengths)),!r.centroids){let n=0,i=()=>{let a=0,c=0;for(;n<o.length;){let f=o[n++];if(a|=(f&127)<<c,(f&128)===0)break;c+=7}return a};for(;n<o.length-4;){let c=i()&7;if(c===2){let f=i();if(f>o.length-n)break;let u=o.slice(n,n+f);if(n+=f,f>100&&f<1e8){let l=gt(u);l&&(r.centroids=l.data,r.numPartitions=l.numPartitions,r.dimension=l.dimension)}}else c===0?i():c===5?n+=4:c===1&&(n+=8)}}return r.centroids?r:null}function dt(o){let e=0,t=[],r=[],s=null,n=()=>{let i=0,a=0;for(;e<o.length;){let c=o[e++];if(i|=(c&127)<<a,(c&128)===0)break;a+=7}return i};for(;e<o.length-4;){let i=e,a=n(),c=a>>3,f=a&7;if(f===2){let u=n();if(u>o.length-e||u<0){e=i+1;continue}let l=o.slice(e,e+u);if(e+=u,c===2&&u%8===0&&u>0){let h=new DataView(l.buffer,l.byteOffset,u);for(let d=0;d<u/8;d++)t.push(Number(h.getBigUint64(d*8,!0)))}else if(c===3)if(u%4===0&&u>0){let h=new DataView(l.buffer,l.byteOffset,u);for(let d=0;d<u/4;d++)r.push(h.getUint32(d*4,!0))}else{let h=0;for(;h<l.length;){let d=0,g=0;for(;h<l.length;){let p=l[h++];if(d|=(p&127)<<g,(p&128)===0)break;g+=7}r.push(d)}}else if(c===4)s=gt(l);else if(u>100){let h=dt(l);(h?.centroids||h?.offsets?.length>0)&&(h.centroids&&!s&&(s=h.centroids),h.offsets?.length>t.length&&(t=h.offsets),h.lengths?.length>r.length&&(r=h.lengths))}}else f===0?n():f===5?e+=4:f===1?e+=8:e=i+1}return s||t.length>0||r.length>0?{centroids:s,offsets:t,lengths:r}:null}function gt(o){let e=0,t=[],r=null,s=2,n=()=>{let i=0,a=0;for(;e<o.length;){let c=o[e++];if(i|=(c&127)<<a,(c&128)===0)break;a+=7}return i};for(;e<o.length;){let i=n(),a=i>>3,c=i&7;if(c===0){let f=n();a===1&&(s=f)}else if(c===2){let f=n(),u=o.slice(e,e+f);if(e+=f,a===2){let l=0;for(;l<u.length;){let h=0,d=0;for(;l<u.length;){let g=u[l++];if(h|=(g&127)<<d,(g&128)===0)break;d+=7}t.push(h)}}else a===3&&(r=u)}else c===5?e+=4:c===1&&(e+=8)}if(t.length>=2&&r&&s===2){let i=t[0],a=t[1];if(r.length===i*a*4)return{data:new Float32Array(r.buffer,r.byteOffset,i*a),numPartitions:i,dimension:a}}return null}async function Ve(o){let e;try{e=await fetch(o.auxiliaryUrl,{method:"HEAD"})}catch{return}if(!e.ok)return;let t=parseInt(e.headers.get("content-length"));if(!t)return;let r=await fetch(o.auxiliaryUrl,{headers:{Range:`bytes=${t-40}-${t-1}`}});if(!r.ok)return;let s=new Uint8Array(await r.arrayBuffer()),n=new DataView(s.buffer,s.byteOffset),i=Number(n.getBigUint64(0,!0)),a=Number(n.getBigUint64(8,!0)),c=Number(n.getBigUint64(16,!0)),f=n.getUint32(24,!0);if(new TextDecoder().decode(s.slice(36,40))!=="LANC")return;let l=f*16,h=await fetch(o.auxiliaryUrl,{headers:{Range:`bytes=${c}-${c+l-1}`}});if(!h.ok)return;let d=new Uint8Array(await h.arrayBuffer()),g=new DataView(d.buffer,d.byteOffset),p=[];for(let m=0;m<f;m++){let y=Number(g.getBigUint64(m*16,!0)),b=Number(g.getBigUint64(m*16+8,!0));p.push({offset:y,length:b})}if(p.length<2)return;o._auxBuffers=p,o._auxFileSize=t;let _=await fetch(o.auxiliaryUrl,{headers:{Range:`bytes=${a}-${c-1}`}});if(!_.ok)return;let w=new Uint8Array(await _.arrayBuffer());if(w.length>=32){let m=new DataView(w.buffer,w.byteOffset),y=Number(m.getBigUint64(0,!0)),b=Number(m.getBigUint64(8,!0)),x=await fetch(o.auxiliaryUrl,{headers:{Range:`bytes=${y}-${y+b-1}`}});if(x.ok){let P=new Uint8Array(await x.arrayBuffer());qe(o,P)}}}function qe(o,e){let t=0,r=[],s=()=>{let n=0,i=0;for(;t<e.length;){let a=e[t++];if(n|=(a&127)<<i,(a&128)===0)break;i+=7}return n};for(;t<e.length;){let n=s(),i=n>>3,a=n&7;if(a===2){let c=s();if(c>e.length-t)break;let f=e.slice(t,t+c);if(t+=c,i===2){let u=Fr(f);u&&r.push(u)}}else a===0?s():a===5?t+=4:a===1&&(t+=8)}o._columnPages=r}function Fr(o){let e=0,t=0,r=[],s=[],n=()=>{let i=0,a=0;for(;e<o.length;){let c=o[e++];if(i|=(c&127)<<a,(c&128)===0)break;a+=7}return i};for(;e<o.length;){let i=n(),a=i>>3,c=i&7;if(c===0){let f=n();a===3&&(t=f)}else if(c===2){let f=n(),u=o.slice(e,e+f);if(e+=f,a===1){let l=0;for(;l<u.length;){let h=0n,d=0n;for(;l<u.length;){let g=u[l++];if(h|=BigInt(g&127)<<d,(g&128)===0)break;d+=7n}r.push(Number(h))}}if(a===2){let l=0;for(;l<u.length;){let h=0n,d=0n;for(;l<u.length;){let g=u[l++];if(h|=BigInt(g&127)<<d,(g&128)===0)break;d+=7n}s.push(Number(h))}}}else c===5?e+=4:c===1&&(e+=8)}return{numRows:t,bufferOffsets:r,bufferSizes:s}}function mt(o,e){let t=0,r=()=>{let s=0,n=0;for(;t<e.length;){let i=e[t++];if(s|=(i&127)<<n,(i&128)===0)break;n+=7}return s};for(;t<e.length-4;){let s=r(),n=s>>3,i=s&7;if(i===2){let a=r();if(a>e.length-t)break;let c=e.slice(t,t+a);if(t+=a,n===2&&a>100&&a<2e3){let f=[],u=0;for(;u<c.length;){let l=0,h=0;for(;u<c.length;){let d=c[u++];if(l|=(d&127)<<h,(d&128)===0)break;h+=7}f.push(l)}f.length===o.numPartitions&&(o.partitionOffsets=f)}else if(n===3&&a>100&&a<2e3){let f=[],u=0;for(;u<c.length;){let l=0,h=0;for(;u<c.length;){let d=c[u++];if(l|=(d&127)<<h,(d&128)===0)break;h+=7}f.push(l)}f.length===o.numPartitions&&(o.partitionLengths=f)}}else if(i===0)r();else if(i===1)t+=8;else if(i===5)t+=4;else break}}var xe=class{constructor(e={}){this.maxSize=e.maxSize??50*1024*1024,this.currentSize=0,this.cache=new Map,this._head=null,this._tail=null}get(e){let t=this.cache.get(e);if(t)return this._moveToHead(t),t.data}delete(e){let t=this.cache.get(e);return t?(this._removeNode(t),this.cache.delete(e),this.currentSize-=t.size,!0):!1}set(e,t,r=null){return this.put(e,t,r)}put(e,t,r=null){let s=this.cache.get(e);s&&(this._removeNode(s),this.currentSize-=s.size,this.cache.delete(e));let n=r;for(n===null&&(t==null?n=0:t.byteLength!==void 0?n=t.byteLength:typeof t=="string"?n=t.length*2:typeof t=="object"?n=JSON.stringify(t).length*2:n=8);this.currentSize+n>this.maxSize&&this._tail;)this._evictTail();if(n>this.maxSize)return;let i={key:e,data:t,size:n,prev:null,next:null};this._addToHead(i),this.cache.set(e,i),this.currentSize+=n}_addToHead(e){e.prev=null,e.next=this._head,this._head&&(this._head.prev=e),this._head=e,this._tail||(this._tail=e)}_removeNode(e){e.prev?e.prev.next=e.next:this._head=e.next,e.next?e.next.prev=e.prev:this._tail=e.prev,e.prev=null,e.next=null}_moveToHead(e){e!==this._head&&(this._removeNode(e),this._addToHead(e))}_evictTail(){if(!this._tail)return;let e=this._tail;this._removeNode(e),this.cache.delete(e.key),this.currentSize-=e.size}clear(){this.cache.clear(),this._head=null,this._tail=null,this.currentSize=0}stats(){return{entries:this.cache.size,currentSize:this.currentSize,maxSize:this.maxSize,utilization:(this.currentSize/this.maxSize*100).toFixed(1)+"%"}}};var Ir=50*1024*1024;async function We(o){let e=`${o.datasetBaseUrl}/ivf_vectors.bin`;o.partitionVectorsUrl=e;let t=await fetch(e,{headers:{Range:"bytes=0-2055"}});if(!t.ok)return;let r=await t.arrayBuffer(),s=new BigUint64Array(r);o.partitionOffsets=Array.from(s,n=>Number(n)),o.hasPartitionIndex=!0}async function wt(o,e,t=384,r=null){if(!o.hasPartitionIndex||!o.partitionVectorsUrl)return null;let s=0,n=0,i=[],a=new Map;o._partitionCache||(o._partitionCache=new xe({maxSize:Ir}));for(let f of e){let u=o._partitionCache.get(f);u!==void 0?a.set(f,u):(i.push(f),s+=o.partitionOffsets[f+1]-o.partitionOffsets[f])}if(i.length===0)return pt(e,a,t,r);o._fetchStats||(o._fetchStats={concurrency:6,recentLatencies:[],minConcurrency:2,maxConcurrency:12});let c=o._fetchStats;for(let f=0;f<i.length;f+=c.concurrency){let u=i.slice(f,f+c.concurrency),l=performance.now(),h=await Promise.all(u.map(async p=>{let _=o.partitionOffsets[p],w=o.partitionOffsets[p+1],m=w-_;try{let y=await fetch(o.partitionVectorsUrl,{headers:{Range:`bytes=${_}-${w-1}`}});if(!y.ok)return{p,rowIds:[],vectors:[]};let b=await y.arrayBuffer(),P=new DataView(b).getUint32(0,!0),v=4+P*4,U=new Uint32Array(b.slice(4,v)),B=new Float32Array(b.slice(v));return n+=m,r&&r(n,s),{p,rowIds:Array.from(U),vectors:B,numVectors:P}}catch{return{p,rowIds:[],vectors:[]}}}));for(let p of h){let _={rowIds:p.rowIds,vectors:p.vectors,numVectors:p.numVectors??p.rowIds.length},w=p.rowIds.length*4+(p.vectors.byteLength||p.vectors.length*4);o._partitionCache.set(p.p,_,w),a.set(p.p,_)}let d=performance.now()-l;c.recentLatencies.push(d),c.recentLatencies.length>10&&c.recentLatencies.shift();let g=c.recentLatencies.reduce((p,_)=>p+_,0)/c.recentLatencies.length;g<50&&c.concurrency<c.maxConcurrency?c.concurrency++:g>200&&c.concurrency>c.minConcurrency&&c.concurrency--}return pt(e,a,t,r)}function pt(o,e,t,r){let s=0,n=0;for(let u of o){let l=e.get(u);l&&(s+=l.rowIds.length,n+=l.vectors.length)}let i=new Array(s),a=new Float32Array(n),c=0,f=0;for(let u of o){let l=e.get(u);if(l){for(let h=0;h<l.rowIds.length;h++)i[c++]=l.rowIds[h];a.set(l.vectors,f),f+=l.vectors.length}}return r&&r(100,100),{rowIds:i,vectors:a,preFlattened:!0}}async function je(o){if(!o.auxiliaryUrl||!o._auxBufferOffsets||o._rowIdCacheReady)return;let e=o.partitionLengths.reduce((s,n)=>s+n,0);if(e===0)return;let t=o._auxBufferOffsets[1],r=e*8;try{let s=await fetch(o.auxiliaryUrl,{headers:{Range:`bytes=${t}-${t+r-1}`}});if(!s.ok)return;let n=new Uint8Array(await s.arrayBuffer()),i=new DataView(n.buffer,n.byteOffset);o._rowIdCache=new Map;let a=0;for(let c=0;c<o.partitionLengths.length;c++){let f=o.partitionLengths[c],u=[];for(let l=0;l<f;l++){let h=Number(i.getBigUint64(a*8,!0));u.push({fragId:Math.floor(h/4294967296),rowOffset:h%4294967296}),a++}o._rowIdCache.set(c,u)}o._rowIdCacheReady=!0}catch{}}async function yt(o,e){if(o._rowIdCacheReady&&o._rowIdCache){let n=[];for(let i of e){let a=o._rowIdCache.get(i);if(a)for(let c of a)n.push({...c,partition:i})}return n}if(!o.auxiliaryUrl||!o._auxBufferOffsets)return null;let t=[];for(let n of e)n<o.partitionOffsets.length&&t.push({partition:n,startRow:o.partitionOffsets[n],numRows:o.partitionLengths[n]});if(t.length===0)return[];let r=[],s=o._auxBufferOffsets[1];for(let n of t){let i=s+n.startRow*8,a=i+n.numRows*8-1;try{let c=await fetch(o.auxiliaryUrl,{headers:{Range:`bytes=${i}-${a}`}});if(!c.ok)continue;let f=new Uint8Array(await c.arrayBuffer()),u=new DataView(f.buffer,f.byteOffset);for(let l=0;l<n.numRows;l++){let h=Number(u.getBigUint64(l*8,!0));r.push({fragId:Math.floor(h/4294967296),rowOffset:h%4294967296,partition:n.partition})}}catch{}}return r}function _t(o,e){let t=0;for(let r of e)r<o.partitionLengths.length&&(t+=o.partitionLengths[r]);return t}var He=new Map,ve=new Map;function Cr(o,e){if(e>=o.length)return o;if(e<=0)return[];let t=0,r=o.length-1;for(;t<r;){let s=t+r>>1;o[s].score>o[t].score&&ie(o,t,s),o[r].score>o[t].score&&ie(o,t,r),o[s].score>o[r].score&&ie(o,s,r);let n=o[r].score,i=t;for(let a=t;a<r;a++)o[a].score>=n&&(ie(o,i,a),i++);if(ie(o,i,r),i===e-1)break;i<e-1?t=i+1:r=i-1}return o.slice(0,e)}function ie(o,e,t){let r=o[e];o[e]=o[t],o[t]=r}var K=class o{constructor(){this.centroids=null,this.numPartitions=0,this.dimension=0,this.partitionOffsets=[],this.partitionLengths=[],this.metricType="cosine",this.partitionIndexUrl=null,this.partitionStarts=null,this.hasPartitionIndex=!1,this._rowIdCache=null,this._rowIdCacheReady=!1,this._accessCounts=new Map}static async tryLoad(e){if(!e)return null;if(He.has(e))return He.get(e);if(ve.has(e))return ve.get(e);let t=o._doLoad(e);ve.set(e,t);try{let r=await t;return r&&He.set(e,r),r}finally{ve.delete(e)}}static async _doLoad(e){try{let t=await ut(e);if(!t)return null;let r=`${e}/_versions/${t}.manifest`,s=await fetch(r);if(!s.ok)return null;let n=await s.arrayBuffer(),i=ft(new Uint8Array(n));if(!i?.uuid)return null;let a=`${e}/_indices/${i.uuid}/index.idx`,c=await fetch(a);if(!c.ok)return null;let f=await c.arrayBuffer(),u=ht(new Uint8Array(f),i,o);if(!u)return null;u.auxiliaryUrl=`${e}/_indices/${i.uuid}/auxiliary.idx`,u.datasetBaseUrl=e;try{await Ve(u)}catch{}try{await We(u)}catch{}try{await je(u)}catch{}return u}catch{return null}}async _loadPartitionIndex(){return We(this)}fetchPartitionData(e,t=384,r=null){return wt(this,e,t,r)}async _loadAuxiliaryMetadata(){return Ve(this)}_parseColumnMetaForPartitions(e){return qe(this,e)}_parseAuxiliaryPartitionInfo(e){return mt(this,e)}async prefetchAllRowIds(){return je(this)}fetchPartitionRowIds(e){return yt(this,e)}getPartitionRowCount(e){return _t(this,e)}findNearestPartitions(e,t=10){if(!this.centroids||e.length!==this.dimension)return[];t=Math.min(t,this.numPartitions);let r=new Array(this.numPartitions),s=0;for(let c=0;c<this.dimension;c++)s+=e[c]*e[c];let n=Math.sqrt(s);for(let c=0;c<this.numPartitions;c++){let f=c*this.dimension,u=0,l=0;for(let d=0;d<this.dimension;d++){let g=this.centroids[f+d];u+=e[d]*g,l+=g*g}let h=n*Math.sqrt(l);r[c]={idx:c,score:h===0?0:u/h}}let a=Cr(r,t).map(c=>c.idx);for(let c of a)this._accessCounts.set(c,(this._accessCounts.get(c)||0)+1);return a}async prefetchHotPartitions(e=10,t=3){if(!this._accessCounts||this._accessCounts.size===0)return;let r=[...this._accessCounts.entries()].filter(([s,n])=>n>=t).sort((s,n)=>n[1]-s[1]).slice(0,e).map(([s])=>s);r.length!==0&&await this.fetchPartitionData(r,this.dimension)}getAccessStats(){return{totalPartitions:this.numPartitions,accessedPartitions:this._accessCounts.size,topPartitions:[...this._accessCounts.entries()].sort((e,t)=>t[1]-e[1]).slice(0,10)}}};async function bt(o){let e=o.url.match(/^(.+\.lance)\/data\/.+\.lance$/);if(e){o._datasetBaseUrl=e[1];try{let t=`${o._datasetBaseUrl}/_versions/1.manifest`,r=await fetch(t);if(!r.ok)return;let s=await r.arrayBuffer();o._schema=Tr(new Uint8Array(s))}catch{}}}function Tr(o){let e=new DataView(o.buffer,o.byteOffset),t=e.getUint32(0,!0),r=4+t,s;if(r+4<o.length){let c=e.getUint32(r,!0);c>0&&r+4+c<=o.length?s=o.slice(r+4,r+4+c):s=o.slice(4,4+t)}else s=o.slice(4,4+t);let n=0,i=[],a=()=>{let c=0,f=0;for(;n<s.length;){let u=s[n++];if(c|=(u&127)<<f,(u&128)===0)break;f+=7}return c};for(;n<s.length;){let c=a(),f=c>>3,u=c&7;if(f===1&&u===2){let l=a(),h=n+l,d=null,g=null,p=null;for(;n<h;){let _=a(),w=_>>3,m=_&7;if(m===0){let y=a();w===3&&(g=y)}else if(m===2){let y=a(),b=s.slice(n,n+y);n+=y,w===2?d=new TextDecoder().decode(b):w===5&&(p=new TextDecoder().decode(b))}else m===5?n+=4:m===1&&(n+=8)}d&&i.push({name:d,id:g,type:p})}else if(u===0)a();else if(u===2){let l=a();n+=l}else u===5?n+=4:u===1&&(n+=8)}return i}function Pt(o){return o._schema&&o._schema.length>0?o._schema.map(e=>e.name):Array.from({length:o._numColumns},(e,t)=>`column_${t}`)}async function xt(o){if(o._columnTypes)return o._columnTypes;let e=[];if(o._schema&&o._schema.length>0){for(let t=0;t<o._numColumns;t++){let r=o._schema[t],s=r?.type?.toLowerCase()||"",n=r?.name?.toLowerCase()||"",i="unknown",a=n.includes("embedding")||n.includes("vector")||n.includes("emb")||n==="vec";s.includes("utf8")||s.includes("string")||s.includes("large_utf8")?i="string":s.includes("fixed_size_list")||s.includes("vector")||a?i="vector":s.includes("int64")||s==="int64"?i="int64":s.includes("int32")||s==="int32"?i="int32":s.includes("int16")||s==="int16"?i="int16":s.includes("int8")||s==="int8"?i="int8":s.includes("float64")||s.includes("double")?i="float64":s.includes("float32")||s.includes("float")&&!s.includes("64")?i="float32":s.includes("bool")&&(i="bool"),e.push(i)}if(e.some(t=>t!=="unknown"))return o._columnTypes=e,e;e.length=0}for(let t=0;t<o._numColumns;t++){let r="unknown",s=o.columnNames[t]?.toLowerCase()||"",n=s.includes("embedding")||s.includes("vector")||s.includes("emb")||s==="vec";try{await o.readStringAt(t,0),r="string",e.push(r);continue}catch{}try{let i=await o.getColumnOffsetEntry(t);if(i.len>0){let a=await o.fetchRange(i.pos,i.pos+i.len-1),c=new Uint8Array(a),f=o._parseColumnMeta(c);if(f.rows>0&&f.size>0){let u=f.size/f.rows;if(n&&u>=4)r="vector";else if(u===8)r="int64";else if(u===4)try{let l=await o.readInt32AtIndices(t,[0]);if(l.length>0){let h=l[0];h>=-1e6&&h<=1e6&&Number.isInteger(h)?r="int32":r="float32"}}catch{r="float32"}else u>8&&u%4===0?r="vector":u===2?r="int16":u===1&&(r="int8")}}}catch{}e.push(r)}return o._columnTypes=e,e}function vt(o){let e=0,t=[],r=0,s=()=>{let l=0n,h=0n;for(;e<o.length;){let d=o[e++];if(l|=BigInt(d&127)<<h,(d&128)===0)break;h+=7n}return Number(l)};for(;e<o.length;){let l=s(),h=l>>3,d=l&7;if(h===2&&d===2){let g=s(),p=e+g,_=[],w=[],m=0;for(;e<p;){let y=s(),b=y>>3,x=y&7;if(b===1&&x===2){let P=s(),v=e+P;for(;e<v;)_.push(s())}else if(b===2&&x===2){let P=s(),v=e+P;for(;e<v;)w.push(s())}else if(b===3&&x===0)m=s();else if(x===0)s();else if(x===2){let P=s();e+=P}else x===5?e+=4:x===1&&(e+=8)}t.push({offsets:_,sizes:w,rows:m}),r+=m}else if(d===0)s();else if(d===2){let g=s();e+=g}else d===5?e+=4:d===1&&(e+=8)}let n=t[0]||{offsets:[],sizes:[],rows:0},i=n.offsets,a=n.sizes,c=0;for(let l of t){let h=l.sizes.length>1?1:0;c+=l.sizes[h]||0}let f=i.length>1?1:0,u=i.length>1?0:-1;return{offset:i[f]||0,size:t.length>1?c:a[f]||0,rows:r,nullBitmapOffset:u>=0?i[u]:null,nullBitmapSize:u>=0?a[u]:null,bufferOffsets:i,bufferSizes:a,pages:t}}function oe(o){let e=[],t=0,r=()=>{let n=0,i=0;for(;t<o.length;){let a=o[t++];if(n|=(a&127)<<i,(a&128)===0)break;i+=7}return n};for(;t<o.length;){let n=r(),i=n>>3,a=n&7;if(i===2&&a===2){let c=r(),f=t+c,u=[0,0],l=[0,0],h=0;for(;t<f;){let d=r(),g=d>>3,p=d&7;if(g===1&&p===2){let _=r(),w=t+_,m=0;for(;t<w&&m<2;)u[m++]=r();t=w}else if(g===2&&p===2){let _=r(),w=t+_,m=0;for(;t<w&&m<2;)l[m++]=r();t=w}else if(g===3&&p===0)h=r();else if(g===4&&p===2){let _=r();t+=_}else if(p===0)r();else if(p===2){let _=r();t+=_}else p===5?t+=4:p===1&&(t+=8)}e.push({offsetsStart:u[0],offsetsSize:l[0],dataStart:u[1],dataSize:l[1],rows:h})}else if(a===0)r();else if(a===2){let c=r();t+=c}else a===5?t+=4:a===1&&(t+=8)}return{...e[0]||{offsetsStart:0,offsetsSize:0,dataStart:0,dataSize:0,rows:0},pages:e}}function E(o,e,t=1024){if(o.length===0)return[];let r=[...o].map((i,a)=>({idx:i,origPos:a}));r.sort((i,a)=>i.idx-a.idx);let s=[],n=0;for(let i=1;i<=r.length;i++)(i===r.length||(r[i].idx-r[i-1].idx)*e>t)&&(s.push({startIdx:r[n].idx,endIdx:r[i-1].idx,items:r.slice(n,i)}),n=i);return s}async function Bt(o,e,t){if(t.length===0)return new BigInt64Array(0);let r=await o.getColumnOffsetEntry(e),s=await o.fetchRange(r.pos,r.pos+r.len-1),n=o._parseColumnMeta(new Uint8Array(s)),i=new BigInt64Array(t.length),a=8,c=E(t,a);return await Promise.all(c.map(async f=>{let u=n.offset+f.startIdx*a,l=n.offset+(f.endIdx+1)*a-1,h=await o.fetchRange(u,l),d=new DataView(h);for(let g of f.items){let p=(g.idx-f.startIdx)*a;i[g.origPos]=d.getBigInt64(p,!0)}})),i}async function Ut(o,e,t){if(t.length===0)return new Float64Array(0);let r=await o.getColumnOffsetEntry(e),s=await o.fetchRange(r.pos,r.pos+r.len-1),n=o._parseColumnMeta(new Uint8Array(s)),i=new Float64Array(t.length),a=8,c=E(t,a);return await Promise.all(c.map(async f=>{let u=n.offset+f.startIdx*a,l=n.offset+(f.endIdx+1)*a-1,h=await o.fetchRange(u,l),d=new DataView(h);for(let g of f.items){let p=(g.idx-f.startIdx)*a;i[g.origPos]=d.getFloat64(p,!0)}})),i}async function At(o,e,t){if(t.length===0)return new Int32Array(0);let r=await o.getColumnOffsetEntry(e),s=await o.fetchRange(r.pos,r.pos+r.len-1),n=o._parseColumnMeta(new Uint8Array(s)),i=new Int32Array(t.length),a=4,c=E(t,a);return await Promise.all(c.map(async f=>{let u=n.offset+f.startIdx*a,l=n.offset+(f.endIdx+1)*a-1,h=await o.fetchRange(u,l),d=new DataView(h);for(let g of f.items){let p=(g.idx-f.startIdx)*a;i[g.origPos]=d.getInt32(p,!0)}})),i}async function Ft(o,e,t){if(t.length===0)return new Float32Array(0);let r=await o.getColumnOffsetEntry(e),s=await o.fetchRange(r.pos,r.pos+r.len-1),n=o._parseColumnMeta(new Uint8Array(s)),i=new Float32Array(t.length),a=4,c=E(t,a);return await Promise.all(c.map(async f=>{let u=n.offset+f.startIdx*a,l=n.offset+(f.endIdx+1)*a-1,h=await o.fetchRange(u,l),d=new DataView(h);for(let g of f.items){let p=(g.idx-f.startIdx)*a;i[g.origPos]=d.getFloat32(p,!0)}})),i}async function St(o,e,t){if(t.length===0)return new Int16Array(0);let r=await o.getColumnOffsetEntry(e),s=await o.fetchRange(r.pos,r.pos+r.len-1),n=o._parseColumnMeta(new Uint8Array(s)),i=new Int16Array(t.length),a=2,c=E(t,a);return await Promise.all(c.map(async f=>{let u=n.offset+f.startIdx*a,l=n.offset+(f.endIdx+1)*a-1,h=await o.fetchRange(u,l),d=new DataView(h);for(let g of f.items){let p=(g.idx-f.startIdx)*a;i[g.origPos]=d.getInt16(p,!0)}})),i}async function It(o,e,t){if(t.length===0)return new Uint8Array(0);let r=await o.getColumnOffsetEntry(e),s=await o.fetchRange(r.pos,r.pos+r.len-1),n=o._parseColumnMeta(new Uint8Array(s)),i=new Uint8Array(t.length),a=1,c=E(t,a);return await Promise.all(c.map(async f=>{let u=n.offset+f.startIdx*a,l=n.offset+(f.endIdx+1)*a-1,h=await o.fetchRange(u,l),d=new Uint8Array(h);for(let g of f.items){let p=g.idx-f.startIdx;i[g.origPos]=d[p]}})),i}async function kt(o,e,t){if(t.length===0)return new Uint8Array(0);let r=await o.getColumnOffsetEntry(e),s=await o.fetchRange(r.pos,r.pos+r.len-1),n=o._parseColumnMeta(new Uint8Array(s)),i=new Uint8Array(t.length),a=t.map(p=>Math.floor(p/8)),c=[...new Set(a)].sort((p,_)=>p-_);if(c.length===0)return i;let f=c[0],u=c[c.length-1],l=n.offset+f,h=n.offset+u,d=await o.fetchRange(l,h),g=new Uint8Array(d);for(let p=0;p<t.length;p++){let _=t[p],w=Math.floor(_/8),m=_%8,y=w-f;y>=0&&y<g.length&&(i[p]=g[y]>>m&1)}return i}async function Ct(o,e,t){let r=await o.getColumnOffsetEntry(e),s=await o.fetchRange(r.pos,r.pos+r.len-1),n=oe(new Uint8Array(s));if(n.offsetsSize===0||n.dataSize===0)throw new Error(`Not a string column - offsetsSize=${n.offsetsSize}, dataSize=${n.dataSize}`);let i=n.offsetsSize/n.rows;if(i!==4&&i!==8)throw new Error(`Not a string column - bytesPerOffset=${i}, expected 4 or 8`);if(t>=n.rows)return"";let a=i,c=n.offsetsStart+t*a,f=await o.fetchRange(c,c+a*2-1),u=new DataView(f),l,h;if(a===4?(l=u.getUint32(0,!0),h=u.getUint32(4,!0)):(l=Number(u.getBigUint64(0,!0)),h=Number(u.getBigUint64(8,!0))),h<=l)return"";let d=h-l,g=await o.fetchRange(n.dataStart+l,n.dataStart+h-1);return new TextDecoder().decode(g)}async function Tt(o,e,t){if(t.length===0)return[];let r=await o.getColumnOffsetEntry(e),s=await o.fetchRange(r.pos,r.pos+r.len-1),n=oe(new Uint8Array(s));if(!n.pages||n.pages.length===0)return t.map(()=>"");let i=new Array(t.length).fill(""),a=0,c=[];for(let u of n.pages){if(u.offsetsSize===0||u.dataSize===0||u.rows===0){a+=u.rows;continue}c.push({start:a,end:a+u.rows,page:u}),a+=u.rows}let f=new Map;for(let u=0;u<t.length;u++){let l=t[u];for(let h=0;h<c.length;h++){let d=c[h];if(l>=d.start&&l<d.end){f.has(h)||f.set(h,[]),f.get(h).push({globalIdx:l,localIdx:l-d.start,resultIdx:u});break}}}for(let[u,l]of f){let d=c[u].page,g=d.offsetsSize/d.rows;if(g!==4&&g!==8)continue;l.sort((m,y)=>m.localIdx-y.localIdx);let p=[],_=0;for(let m=1;m<=l.length;m++)(m===l.length||l[m].localIdx-l[m-1].localIdx>100)&&(p.push(l.slice(_,m)),_=m);let w=[];if(await Promise.all(p.map(async m=>{let y=m[0].localIdx,b=m[m.length-1].localIdx,x=y>0?y-1:0,P=b,v=d.offsetsStart+x*g,U=d.offsetsStart+(P+1)*g-1,B=await o.fetchRange(v,U),A=new DataView(B);for(let k of m){let T=k.localIdx-x,M,S;g===4?(S=A.getUint32(T*4,!0),M=k.localIdx===0?0:A.getUint32((T-1)*4,!0)):(S=Number(A.getBigUint64(T*8,!0)),M=k.localIdx===0?0:Number(A.getBigUint64((T-1)*8,!0))),S>M&&w.push({start:M,end:S,resultIdx:k.resultIdx,dataStart:d.dataStart})}})),w.length>0){w.sort((b,x)=>b.start-x.start);let m=[],y=0;for(let b=1;b<=w.length;b++)(b===w.length||w[b].start-w[b-1].end>4096)&&(m.push({rangeStart:w[y].start,rangeEnd:w[b-1].end,items:w.slice(y,b),dataStart:w[y].dataStart}),y=b);await Promise.all(m.map(async b=>{let x=await o.fetchRange(b.dataStart+b.rangeStart,b.dataStart+b.rangeEnd-1),P=new Uint8Array(x);for(let v of b.items){let U=v.start-b.rangeStart,B=v.end-v.start,A=P.slice(U,U+B);i[v.resultIdx]=new TextDecoder().decode(A)}}))}}return i}async function Ye(o,e){let t=await o.getColumnOffsetEntry(e);if(t.len===0)return{rows:0,dimension:0};let r=await o.fetchRange(t.pos,t.pos+t.len-1),s=o._parseColumnMeta(new Uint8Array(r));if(s.rows===0)return{rows:0,dimension:0};let n=0;if(s.pages&&s.pages.length>0){let i=s.pages[0],a=i.sizes.length>1?1:0,c=i.sizes[a]||0,f=i.rows||0;f>0&&c>0&&(n=Math.floor(c/(f*4)))}else s.size>0&&(n=Math.floor(s.size/(s.rows*4)));return{rows:s.rows,dimension:n}}async function Mt(o,e,t){let r=await o.getColumnOffsetEntry(e),s=await o.fetchRange(r.pos,r.pos+r.len-1),n=o._parseColumnMeta(new Uint8Array(s));if(n.rows===0)return new Float32Array(0);if(t>=n.rows)return new Float32Array(0);let i=Math.floor(n.size/(n.rows*4));if(i===0)return new Float32Array(0);let a=n.offset+t*i*4,c=a+i*4-1,f=await o.fetchRange(a,c);return new Float32Array(f)}async function Ke(o,e,t){if(t.length===0)return[];let r=await o.getColumnOffsetEntry(e),s=await o.fetchRange(r.pos,r.pos+r.len-1),n=o._parseColumnMeta(new Uint8Array(s));if(n.rows===0)return t.map(()=>new Float32Array(0));let i=Math.floor(n.size/(n.rows*4));if(i===0)return t.map(()=>new Float32Array(0));let a=i*4,c=new Array(t.length),f=E(t,a,a*50),u=6;for(let l=0;l<f.length;l+=u){let h=f.slice(l,l+u);await Promise.all(h.map(async d=>{try{let g=n.offset+d.startIdx*a,p=n.offset+(d.endIdx+1)*a-1,_=await o.fetchRange(g,p);for(let w of d.items){let m=(w.idx-d.startIdx)*a;c[w.origPos]=new Float32Array(_.slice(m,m+a))}}catch{for(let p of d.items)c[p.origPos]=new Float32Array(0)}}))}return c}function Rt(o,e){if(o.length!==e.length)return 0;let t=0,r=0,s=0;for(let i=0;i<o.length;i++)t+=o[i]*e[i],r+=o[i]*o[i],s+=e[i]*e[i];let n=Math.sqrt(r)*Math.sqrt(s);return n===0?0:t/n}async function Ot(o,e,t,r=10,s=null,n={}){let{nprobe:i=10}=n,a=await Ye(o,e);if(a.dimension===0||a.dimension!==t.length)throw new Error(`Dimension mismatch: query=${t.length}, column=${a.dimension}`);if(!o.hasIndex())throw new Error("No IVF index found. Vector search requires an IVF index for efficient querying.");if(o._ivfIndex.dimension!==t.length)throw new Error(`Query dimension (${t.length}) does not match index dimension (${o._ivfIndex.dimension}).`);return await Or(o,e,t,r,i,s)}async function Or(o,e,t,r,s,n){n&&n(0,100);let i=o._ivfIndex.findNearestPartitions(t,s),a=await o._ivfIndex.fetchPartitionRowIds(i);if(a&&a.length>0)return await Er(o,e,t,r,a,n);throw new Error("Failed to fetch row IDs from IVF index. Dataset may be missing auxiliary.idx or ivf_partitions.bin.")}async function Er(o,e,t,r,s,n){let i=t.length,a=new Map;for(let p of s)a.has(p.fragId)||a.set(p.fragId,[]),a.get(p.fragId).push(p.rowOffset);let c=[],f=[],u=0,l=s.length;for(let[p,_]of a){n&&n(u,l);let w=await Ke(o,e,_);for(let m=0;m<_.length;m++){let y=w[m];y&&y.length===i&&(c.push(y),f.push(p*5e4+_[m])),u++}}let h,d=z();d.isAvailable()&&(h=await d.batchCosineSimilarity(t,c,!0)),h||(h=o.lanceql.batchCosineSimilarity(t,c,!0));let g=[];for(let p=0;p<h.length;p++){let _=h[p],w=f[p];g.length<r?(g.push({idx:w,score:_}),g.sort((m,y)=>y.score-m.score)):_>g[r-1].score&&(g[r-1]={idx:w,score:_},g.sort((m,y)=>y.score-m.score))}return n&&n(l,l),{indices:g.map(p=>p.idx),scores:g.map(p=>p.score),usedIndex:!0,searchedRows:c.length}}async function Et(o,e){let t=await o.getColumnOffsetEntry(e),r=await o.fetchRange(t.pos,t.pos+t.len-1),s=o._parseColumnMeta(new Uint8Array(r));if(!s.pages||s.pages.length===0||s.rows===0)return new Float32Array(0);let n=s.pages[0],i=n.sizes.length>1?1:0,a=n.sizes[i]||0,c=n.rows||0;if(c===0||a===0)return new Float32Array(0);let f=Math.floor(a/(c*4));if(f===0)return new Float32Array(0);let u=s.rows,l=new Float32Array(u*f),h=s.pages.map(async(p,_)=>{let w=p.sizes.length>1?1:0,m=p.offsets[w]||0,y=p.sizes[w]||0;if(y===0)return{pageIdx:_,data:new Float32Array(0),rows:0};let b=await o.fetchRange(m,m+y-1),x=new Float32Array(b);return{pageIdx:_,data:x,rows:p.rows}}),d=await Promise.all(h),g=0;for(let p of d.sort((_,w)=>_.pageIdx-w.pageIdx))l.set(p.data,g),g+=p.rows*f;return l}async function Gt(o,{offset:e=0,limit:t=50,columns:r=null}={}){let s=r||Array.from({length:o._numColumns},(h,d)=>d),n=await o.getRowCount(0),i=Math.min(e,n),a=Math.min(t,n-i);if(a<=0)return{columns:s.map(()=>[]),columnNames:o.columnNames.slice(0,s.length),total:n};let c=Array.from({length:a},(h,d)=>i+d),f=await o.detectColumnTypes(),u=s.map(async h=>{let d=f[h]||"unknown";try{switch(d){case"string":case"utf8":case"large_utf8":return await o.readStringsAtIndices(h,c);case"int64":return Array.from(await o.readInt64AtIndices(h,c));case"int32":return Array.from(await o.readInt32AtIndices(h,c));case"int16":return Array.from(await o.readInt16AtIndices(h,c));case"uint8":return Array.from(await o.readUint8AtIndices(h,c));case"float64":case"double":return Array.from(await o.readFloat64AtIndices(h,c));case"float32":case"float":return Array.from(await o.readFloat32AtIndices(h,c));case"bool":case"boolean":return await o.readBoolAtIndices(h,c);case"fixed_size_list":case"vector":let g=await o.readVectorsAtIndices(h,c);return Array.isArray(g)?g:Array.from(g);default:return await o.readStringsAtIndices(h,c)}}catch{return c.map(()=>null)}});return{columns:await Promise.all(u),columnNames:s.map(h=>o.columnNames[h]||`column_${h}`),total:n}}var J=class o{constructor(e,t,r,s){this.lanceql=e,this.wasm=e.wasm,this.memory=e.memory,this.url=t,this.fileSize=r;let n=new Uint8Array(s);if(this.footerPtr=this.wasm.alloc(n.length),!this.footerPtr)throw new Error("Failed to allocate memory for footer");this.footerLen=n.length,new Uint8Array(this.memory.buffer).set(n,this.footerPtr),this._numColumns=this.wasm.parseFooterGetColumns(this.footerPtr,this.footerLen),this._majorVersion=this.wasm.parseFooterGetMajorVersion(this.footerPtr,this.footerLen),this._minorVersion=this.wasm.parseFooterGetMinorVersion(this.footerPtr,this.footerLen),this._columnMetaStart=this.wasm.getColumnMetaStart(this.footerPtr,this.footerLen),this._columnMetaOffsetsStart=this.wasm.getColumnMetaOffsetsStart(this.footerPtr,this.footerLen),this._columnMetaCache=new Map,this._columnOffsetCache=new Map,this._columnTypes=null,this._schema=null,this._datasetBaseUrl=null,this._ivfIndex=null}static async open(e,t){let r=await fetch(t,{method:"HEAD"});if(!r.ok)throw new Error(`HTTP error: ${r.status}`);let s=r.headers.get("Content-Length");if(!s)throw new Error("Server did not return Content-Length");let n=parseInt(s,10),a=n-40,c=await fetch(t,{headers:{Range:`bytes=${a}-${n-1}`}});if(!c.ok&&c.status!==206)throw new Error(`HTTP error: ${c.status}`);let f=await c.arrayBuffer(),u=new Uint8Array(f),l=String.fromCharCode(u[36],u[37],u[38],u[39]);if(l!=="LANC")throw new Error(`Invalid Lance file: expected LANC magic, got "${l}"`);let h=new o(e,t,n,f);await bt(h);let d=t.includes("/data/");return d||await h._tryLoadIndex(),d||console.log(`[LanceQL] Loaded: ${h._numColumns} columns, ${(n/1024/1024).toFixed(1)}MB, schema: ${h._schema?"yes":"no"}, index: ${h.hasIndex()?"yes":"no"}`),h}async _tryLoadIndex(){if(this._datasetBaseUrl)try{this._ivfIndex=await K.tryLoad(this._datasetBaseUrl)}catch{}}hasIndex(){return this._ivfIndex!==null&&this._ivfIndex.centroids!==null}get columnNames(){return Pt(this)}get schema(){return this._schema}get datasetBaseUrl(){return this._datasetBaseUrl}get numColumns(){return this._numColumns}get size(){return this.fileSize}get version(){return{major:this._majorVersion,minor:this._minorVersion}}get columnMetaStart(){return Number(this._columnMetaStart)}get columnMetaOffsetsStart(){return Number(this._columnMetaOffsetsStart)}async fetchRange(e,t){(e<0||t<e||t>=this.size)&&console.error(`Invalid range: ${e}-${t}, file size: ${this.size}`);let r=lt();if(r.enabled){let i=await r.getRange(this.url,e,t,this.size);return this._onFetch&&this._onFetch(i.byteLength,1),i}let s=await fetch(this.url,{headers:{Range:`bytes=${e}-${t}`}});if(!s.ok&&s.status!==206)throw console.error(`Fetch failed: ${s.status} for range ${e}-${t}`),new Error(`HTTP error: ${s.status}`);let n=await s.arrayBuffer();return this._onFetch&&this._onFetch(n.byteLength,1),n}onFetch(e){this._onFetch=e}close(){this.footerPtr&&(this.wasm.free(this.footerPtr,this.footerLen),this.footerPtr=null)}async getColumnOffsetEntry(e){if(e>=this._numColumns)return{pos:0,len:0};if(this._columnOffsetCache.has(e))return this._columnOffsetCache.get(e);let t=this.columnMetaOffsetsStart+e*16,r=await this.fetchRange(t,t+15),s=new DataView(r),n={pos:Number(s.getBigUint64(0,!0)),len:Number(s.getBigUint64(8,!0))};return this._columnOffsetCache.set(e,n),n}async getColumnDebugInfo(e){let t=await this.getColumnOffsetEntry(e);if(t.len===0)return{offset:0,size:0,rows:0};let r=await this.fetchRange(t.pos,t.pos+t.len-1),s=new Uint8Array(r);return this._parseColumnMeta(s)}_parseColumnMeta(e){return vt(e)}_parseStringColumnMeta(e){return oe(e)}_batchIndices(e,t,r=1024){return E(e,t,r)}async _getCachedColumnMeta(e){if(this._columnMetaCache.has(e))return this._columnMetaCache.get(e);let t=await this.getColumnOffsetEntry(e);if(t.len===0)return null;let r=await this.fetchRange(t.pos,t.pos+t.len-1),s=new Uint8Array(r);return this._columnMetaCache.set(e,s),s}readInt64AtIndices(e,t){return Bt(this,e,t)}readFloat64AtIndices(e,t){return Ut(this,e,t)}readInt32AtIndices(e,t){return At(this,e,t)}readFloat32AtIndices(e,t){return Ft(this,e,t)}readInt16AtIndices(e,t){return St(this,e,t)}readUint8AtIndices(e,t){return It(this,e,t)}readBoolAtIndices(e,t){return kt(this,e,t)}readStringAt(e,t){return Ct(this,e,t)}readStringsAtIndices(e,t){return Tt(this,e,t)}async getRowCount(e){return(await this.getColumnDebugInfo(e)).rows}detectColumnTypes(){return xt(this)}getVectorInfo(e){return Ye(this,e)}readVectorAt(e,t){return Mt(this,e,t)}readVectorsAtIndices(e,t){return Ke(this,e,t)}cosineSimilarity(e,t){return Rt(e,t)}vectorSearch(e,t,r=10,s=null,n={}){return Ot(this,e,t,r,s,n)}readVectorColumn(e){return Et(this,e)}readRows(e={}){return Gt(this,e)}};var ae=class{constructor(e="lanceql-cache",t=1){this.dbName=e,this.version=t,this.db=null}async open(){return this.db?this.db:new Promise((e,t)=>{let r=indexedDB.open(this.dbName,this.version);r.onerror=()=>t(r.error),r.onsuccess=()=>{this.db=r.result,e(this.db)},r.onupgradeneeded=s=>{let n=s.target.result;n.objectStoreNames.contains("datasets")||n.createObjectStore("datasets",{keyPath:"url"}).createIndex("timestamp","timestamp")}})}async get(e){try{let t=await this.open();return new Promise(r=>{let i=t.transaction("datasets","readonly").objectStore("datasets").get(e);i.onsuccess=()=>r(i.result||null),i.onerror=()=>r(null)})}catch(t){return console.warn("[MetadataCache] Get failed:",t),null}}async set(e,t){try{let r=await this.open();return new Promise((s,n)=>{let a=r.transaction("datasets","readwrite").objectStore("datasets"),c={url:e,timestamp:Date.now(),...t},f=a.put(c);f.onsuccess=()=>s(),f.onerror=()=>n(f.error)})}catch(r){console.warn("[MetadataCache] Set failed:",r)}}async delete(e){try{let t=await this.open();return new Promise(r=>{let s=t.transaction("datasets","readwrite");s.objectStore("datasets").delete(e),s.oncomplete=()=>r()})}catch(t){console.warn("[MetadataCache] Delete failed:",t)}}async clear(){try{let e=await this.open();return new Promise(t=>{let r=e.transaction("datasets","readwrite");r.objectStore("datasets").clear(),r.oncomplete=()=>t()})}catch(e){console.warn("[MetadataCache] Clear failed:",e)}}},kn=new ae;function zt(o,e,t){let r=0,s=0,n=0,i=0,a=0,c=()=>{let l=0,h=0;for(;a<o.length;){let d=o[a++];if(l|=(d&127)<<h,(d&128)===0)break;h+=7}return l};for(;a<o.length;){let l=c(),h=l>>3,d=l&7;if(d===0){let g=c();h===1?r=g:h===2?s=g:h===3?n=g:h===4&&(i=g)}else if(d===2){let g=c();a+=g}else d===5?a+=4:d===1&&(a+=8)}if(i===0)return null;let u=`_deletions/${e}-${s}-${n}.${r===0?"arrow":"bin"}`;return{fileType:r===0?"arrow":"bitmap",readVersion:s,id:n,numDeletedRows:i,path:u,url:`${t}/${u}`}}function zr(o){let e=new Set,t=0;o.length>=8&&String.fromCharCode(...o.slice(0,6))==="ARROW1"&&(t=8);let r=new DataView(o.buffer,o.byteOffset,o.byteLength);for(;t<o.length-4;)if(r.getInt32(t,!0)===-1){if(t+=4,t+4>o.length)break;let n=r.getInt32(t,!0);for(t+=4+n;t+4<=o.length&&r.getInt32(t,!0)!==-1;){let a=r.getInt32(t,!0);a>=0&&a<1e7&&e.add(a),t+=4}}else t++;return e}function Lr(o){let e=new Set,t=new DataView(o.buffer,o.byteOffset,o.byteLength);if(o.length<8)return e;let r=t.getUint32(0,!0);if(r===12346||r===12347){let s=r===12347,n=4,i=t.getUint16(n,!0);n+=2;let a=n;n+=i*4;for(let c=0;c<i&&n<o.length;c++){let f=t.getUint16(a+c*4,!0),u=t.getUint16(a+c*4+2,!0)+1,l=f<<16;for(let h=0;h<u&&n+2<=o.length;h++){let d=t.getUint16(n,!0);e.add(l|d),n+=2}}}return e}async function Lt(o,e){if(o._deletedRows.has(e))return o._deletedRows.get(e);let t=o._fragments[e];if(!t?.deletionFile){let i=new Set;return o._deletedRows.set(e,i),i}let{url:r,fileType:s,numDeletedRows:n}=t.deletionFile;console.log(`[LanceQL] Loading ${n} deletions from ${r} (${s})`);try{let i=await fetch(r);if(!i.ok){console.warn(`[LanceQL] Failed to load deletion file: ${i.status}`);let u=new Set;return o._deletedRows.set(e,u),u}let a=await i.arrayBuffer(),c=new Uint8Array(a),f;return s==="arrow"?f=zr(c):f=Lr(c),console.log(`[LanceQL] Loaded ${f.size} deleted rows for fragment ${e}`),o._deletedRows.set(e,f),f}catch(i){console.error("[LanceQL] Error loading deletion file:",i);let a=new Set;return o._deletedRows.set(e,a),a}}async function Nt(o,e,t,r=10,s=null,n={}){let{normalized:i=!0,workerPool:a=null,useIndex:c=!0,nprobe:f=20}=n,u=e;if(u<0)throw new Error("No vector column found in dataset");let l=t.length;if(!o.hasIndex())throw new Error("No IVF index found. Vector search requires an IVF index for efficient querying.");if(o._ivfIndex.dimension!==l)throw new Error(`Query dimension (${l}) does not match index dimension (${o._ivfIndex.dimension}).`);if(!o._ivfIndex.hasPartitionIndex)throw new Error("IVF partition index (ivf_partitions.bin) not found. Required for efficient search.");return await Nr(o,t,r,u,f,s)}async function Nr(o,e,t,r,s,n){let i=o._ivfIndex.findNearestPartitions(e,s),a=await o._ivfIndex.fetchPartitionData(i,o._ivfIndex.dimension,(w,m)=>{if(n){let y=m>0?w/m:0;n(Math.floor(y*80),100)}});if(!a||a.rowIds.length===0)throw new Error("IVF index not available. This dataset requires ivf_vectors.bin for efficient search.");let{rowIds:c,vectors:f,preFlattened:u}=a,l=e.length,h=u?f.length/l:f.length,d=new Float32Array(h),g=z();if(g.isAvailable()){let w=g.getMaxVectorsPerBatch(l);if(u)for(let m=0;m<h;m+=w){let y=Math.min(m+w,h),b=y-m,x=f.subarray(m*l,y*l);try{let P=await g.batchCosineSimilarity(e,x,!0,!0);if(P){d.set(P,m);continue}}catch{}if(o.lanceql?.batchCosineSimilarityFlat){let P=o.lanceql.batchCosineSimilarityFlat(e,x,l,!0);d.set(P,m)}else for(let P=0;P<b;P++){let v=P*l,U=0;for(let B=0;B<l;B++)U+=e[B]*x[v+B];d[m+P]=U}}else for(let m=0;m<h;m+=w){let y=Math.min(m+w,h),b=f.slice(m,y);try{let x=await g.batchCosineSimilarity(e,b,!0,!1);if(x){d.set(x,m);continue}}catch{}for(let x=0;x<b.length;x++){let P=b[x];if(!P||P.length!==l)continue;let v=0;for(let U=0;U<l;U++)v+=e[U]*P[U];d[m+x]=v}}}else if(u)for(let w=0;w<h;w++){let m=w*l,y=0;for(let b=0;b<l;b++)y+=e[b]*f[m+b];d[w]=y}else for(let w=0;w<h;w++){let m=f[w];if(!m||m.length!==l)continue;let y=0;for(let b=0;b<l;b++)y+=e[b]*m[b];d[w]=y}n&&n(90,100);let p=new Array(c.length);for(let w=0;w<c.length;w++)p[w]={index:c[w],score:d[w]};let _=Math.min(t,p.length);return Dr(p,_),n&&n(100,100),{indices:p.slice(0,_).map(w=>w.index),scores:p.slice(0,_).map(w=>w.score),usedIndex:!0,searchedRows:c.length}}function Dr(o,e){if(e>=o.length||e<=0)return;let t=0,r=o.length-1;for(;t<r;){let s=t+r>>1;o[s].score>o[t].score&&ce(o,t,s),o[r].score>o[t].score&&ce(o,t,r),o[s].score>o[r].score&&ce(o,s,r);let n=o[r].score,i=t;for(let a=t;a<r;a++)o[a].score>=n&&(ce(o,i,a),i++);if(ce(o,i,r),i===e-1)break;i<e-1?t=i+1:r=i-1}}function ce(o,e,t){let r=o[e];o[e]=o[t],o[t]=r}function Dt(o){if(!o._schema)return-1;for(let e=0;e<o._schema.length;e++){let t=o._schema[e];if(t.name==="embedding"||t.name==="vector"||t.type==="fixed_size_list"||t.type==="list")return e}return o._schema.length-1}function Je(o,e){let t=0;for(let r=0;r<o._fragments.length;r++){let s=o._fragments[r];if(e<t+s.numRows)return{fragmentIndex:r,localIndex:e-t};t+=s.numRows}return null}function $(o,e){let t=new Map;for(let r of e){let s=Je(o,r);s&&(t.has(s.fragmentIndex)||t.set(s.fragmentIndex,{localIndices:[],globalIndices:[]}),t.get(s.fragmentIndex).localIndices.push(s.localIndex),t.get(s.fragmentIndex).globalIndices.push(r))}return t}async function Qe(o,{offset:e=0,limit:t=50,columns:r=null,_isPrefetch:s=!1}={}){let n=[],i=0;for(let g=0;g<o._fragments.length;g++){let p=o._fragments[g],_=i,w=i+p.numRows;if(w>e&&_<e+t){let m=Math.max(0,e-_),y=Math.min(p.numRows,e+t-_);n.push({fragmentIndex:g,localOffset:m,localLimit:y-m,globalStart:_+m})}if(i=w,i>=e+t)break}if(n.length===0)return{columns:[],columnNames:o.columnNames,total:o._totalRows};let a=n.map(async g=>{let _=await(await o.openFragment(g.fragmentIndex)).readRows({offset:g.localOffset,limit:g.localLimit,columns:r});return{...g,result:_}}),c=await Promise.all(a);c.sort((g,p)=>g.globalStart-p.globalStart);let f=[],u=c[0]?.result.columnNames||o.columnNames,l=r?r.length:o._numColumns;for(let g=0;g<l;g++){let p=[];for(let _ of c)_.result.columns[g]&&p.push(..._.result.columns[g]);f.push(p)}let h={columns:f,columnNames:u,total:o._totalRows},d=e+t;return!s&&d<o._totalRows&&t<=100&&Vr(o,d,t,r),h}function Vr(o,e,t,r){let s=`${e}-${t}-${r?.join(",")||"all"}`;if(o._prefetchCache?.has(s))return;o._prefetchCache||(o._prefetchCache=new Map);let n=Qe(o,{offset:e,limit:t,columns:r,_isPrefetch:!0}).then(i=>{o._prefetchCache.set(s,i)}).catch(()=>{});o._prefetchCache.set(s,n)}async function $t(o,e,t){let r=$(o,t),s=new Map,n=[];for(let[i,a]of r)n.push((async()=>{let f=await(await o.openFragment(i)).readStringsAtIndices(e,a.localIndices);for(let u=0;u<a.globalIndices.length;u++)s.set(a.globalIndices[u],f[u])})());return await Promise.all(n),t.map(i=>s.get(i)||null)}async function Vt(o,e,t){let r=$(o,t),s=new Map,n=[];for(let[i,a]of r)n.push((async()=>{let f=await(await o.openFragment(i)).readInt64AtIndices(e,a.localIndices);for(let u=0;u<a.globalIndices.length;u++)s.set(a.globalIndices[u],f[u])})());return await Promise.all(n),new BigInt64Array(t.map(i=>s.get(i)||0n))}async function qt(o,e,t){let r=$(o,t),s=new Map,n=[];for(let[i,a]of r)n.push((async()=>{let f=await(await o.openFragment(i)).readFloat64AtIndices(e,a.localIndices);for(let u=0;u<a.globalIndices.length;u++)s.set(a.globalIndices[u],f[u])})());return await Promise.all(n),new Float64Array(t.map(i=>s.get(i)||0))}async function Wt(o,e,t){let r=$(o,t),s=new Map,n=[];for(let[i,a]of r)n.push((async()=>{let f=await(await o.openFragment(i)).readInt32AtIndices(e,a.localIndices);for(let u=0;u<a.globalIndices.length;u++)s.set(a.globalIndices[u],f[u])})());return await Promise.all(n),new Int32Array(t.map(i=>s.get(i)||0))}async function jt(o,e,t){let r=$(o,t),s=new Map,n=[];for(let[i,a]of r)n.push((async()=>{let f=await(await o.openFragment(i)).readFloat32AtIndices(e,a.localIndices);for(let u=0;u<a.globalIndices.length;u++)s.set(a.globalIndices[u],f[u])})());return await Promise.all(n),new Float32Array(t.map(i=>s.get(i)||0))}function Wr(o){let e={type:"SELECT",columns:"*",limit:null,offset:null,where:null},t=o.toUpperCase();if(t.includes("LIMIT")){let r=o.match(/LIMIT\s+(\d+)/i);r&&(e.limit=parseInt(r[1]))}if(t.includes("OFFSET")){let r=o.match(/OFFSET\s+(\d+)/i);r&&(e.offset=parseInt(r[1]))}return t.includes("WHERE")&&(e.where=!0),e}async function Ht(o,e){let t=Wr(e);if(t.type==="SELECT"&&t.columns==="*"&&!t.where){let u=t.limit||50,l=t.offset||0;return await o.readRows({offset:l,limit:u})}let r=o._fragments.map(async(u,l)=>{let h=await o.openFragment(l);try{return await h.executeSQL(e)}catch(d){return console.warn(`Fragment ${l} query failed:`,d),{columns:[],columnNames:[],total:0}}}),s=await Promise.all(r);if(s.length===0||s.every(u=>u.columns.length===0))return{columns:[],columnNames:o.columnNames,total:0};let n=s.find(u=>u.columns.length>0);if(!n)return{columns:[],columnNames:o.columnNames,total:0};let i=n.columns.length,a=n.columnNames,c=Array.from({length:i},()=>[]),f=0;for(let u of s){for(let l=0;l<i&&l<u.columns.length;l++)c[l].push(...u.columns[l]);f+=u.total}if(t.limit){let u=t.offset||0;for(let l=0;l<i;l++)c[l]=c[l].slice(u,u+t.limit)}return{columns:c,columnNames:a,total:f}}var Be=new ae,Q=class o{constructor(e,t){this.lanceql=e,this.baseUrl=t.replace(/\/$/,""),this._fragments=[],this._schema=null,this._totalRows=0,this._numColumns=0,this._onFetch=null,this._fragmentFiles=new Map,this._isRemote=!0,this._ivfIndex=null,this._deletedRows=new Map}static async open(e,t,r={}){let s=new o(e,t);s._requestedVersion=r.version||null;let n=r.version?`${t}@v${r.version}`:t;if(!r.skipCache){let a=await Be.get(n);a&&a.schema&&a.fragments&&(s._schema=a.schema,s._fragments=a.fragments,s._numColumns=a.schema.length,s._totalRows=a.fragments.reduce((c,f)=>c+f.numRows,0),s._version=a.version,s._columnTypes=a.columnTypes||null,s._fromCache=!0)}return s._fromCache||(await s._tryLoadSidecar()||await s._loadManifest(),Be.set(n,{schema:s._schema,fragments:s._fragments,version:s._version,columnTypes:s._columnTypes||null}).catch(()=>{})),await s._tryLoadIndex(),(r.prefetch??!1)&&s._fragments.length>0&&s._prefetchFragments(),s}async _tryLoadSidecar(){try{let e=`${this.baseUrl}/.meta.json`,t=await fetch(e);if(!t.ok)return!1;let r=await t.json();return!r.schema||!r.fragments?!1:(this._schema=r.schema.map(s=>({name:s.name,id:s.index,type:s.type})),this._fragments=r.fragments.map(s=>({id:s.id,path:s.data_files?.[0]||`${s.id}.lance`,numRows:s.num_rows,physicalRows:s.physical_rows||s.num_rows,url:`${this.baseUrl}/data/${s.data_files?.[0]||s.id+".lance"}`,deletionFile:s.has_deletions?{numDeletedRows:s.deleted_rows||0}:null})),this._numColumns=r.num_columns,this._totalRows=r.total_rows,this._version=r.lance_version,this._columnTypes=r.schema.map(s=>{let n=s.type;return n.startsWith("vector[")?"vector":n==="float64"||n==="double"?"float64":n==="float32"?"float32":n.includes("int")?n:n==="string"?"string":"unknown"}),!0)}catch{return!1}}_prefetchFragments(){let e=this._fragments.map((t,r)=>this.openFragment(r).catch(()=>null));Promise.all(e).catch(()=>{})}hasIndex(){return this._ivfIndex!==null&&this._ivfIndex.centroids!==null}async _tryLoadIndex(){try{this._ivfIndex=await K.tryLoad(this.baseUrl)}catch{this._ivfIndex=null}}async _loadManifest(){let e=null,t=0;if(this._requestedVersion){t=this._requestedVersion;let r=`${this.baseUrl}/_versions/${t}.manifest`,s=await fetch(r);if(!s.ok)throw new Error(`Version ${t} not found (${s.status})`);e=new Uint8Array(await s.arrayBuffer())}else{let r=[1,5,10,20,50,100],s=await Promise.all(r.map(async c=>{try{let f=`${this.baseUrl}/_versions/${c}.manifest`;return(await fetch(f,{method:"HEAD"})).ok?c:0}catch{return 0}})),n=Math.max(...s);if(n>0)for(let c=n+1;c<=n+50;c++)try{let f=`${this.baseUrl}/_versions/${c}.manifest`;if((await fetch(f,{method:"HEAD"})).ok)n=c;else break}catch{break}if(t=n,t===0)throw new Error("No manifest found in dataset");let i=`${this.baseUrl}/_versions/${t}.manifest`,a=await fetch(i);if(!a.ok)throw new Error(`Failed to fetch manifest: ${a.status}`);e=new Uint8Array(await a.arrayBuffer())}this._version=t,this._latestVersion=this._requestedVersion?null:t,this._parseManifest(e)}async listVersions(){let e=[],t=this._latestVersion||100;return(await Promise.all(Array.from({length:t},(s,n)=>n+1).map(async s=>{try{let n=`${this.baseUrl}/_versions/${s}.manifest`;return(await fetch(n,{method:"HEAD"})).ok?s:0}catch{return 0}}))).filter(s=>s>0)}get version(){return this._version}_parseManifest(e){let t=new DataView(e.buffer,e.byteOffset),r=t.getUint32(0,!0),s=4+r,n;if(s+4<e.length){let l=t.getUint32(s,!0);l>0&&s+4+l<=e.length?n=e.slice(s+4,s+4+l):n=e.slice(4,4+r)}else n=e.slice(4,4+r);let i=0,a=[],c=[],f=()=>{let l=0,h=0;for(;i<n.length;){let d=n[i++];if(l|=(d&127)<<h,(d&128)===0)break;h+=7}return l},u=l=>{if(l===0)f();else if(l===2){let h=f();i+=h}else l===5?i+=4:l===1&&(i+=8)};for(;i<n.length;){let l=f(),h=l>>3,d=l&7;if(h===1&&d===2){let g=f(),p=i+g,_=null,w=null,m=null;for(;i<p;){let y=f(),b=y>>3,x=y&7;if(x===0){let P=f();b===3&&(w=P)}else if(x===2){let P=f(),v=n.slice(i,i+P);i+=P,b===2?_=new TextDecoder().decode(v):b===5&&(m=new TextDecoder().decode(v))}else u(x)}_&&a.push({name:_,id:w,type:m})}else if(h===2&&d===2){let g=f(),p=i+g,_=null,w=null,m=0,y=null;for(;i<p;){let b=f(),x=b>>3,P=b&7;if(P===0){let v=f();x===1?_=v:x===4&&(m=v)}else if(P===2){let v=f(),U=n.slice(i,i+v);if(i+=v,x===2){let B=0;for(;B<U.length;){let A=U[B++],k=A>>3,T=A&7;if(T===2){let M=0,S=0;for(;B<U.length;){let I=U[B++];if(M|=(I&127)<<S,(I&128)===0)break;S+=7}let G=U.slice(B,B+M);B+=M,k===1&&(w=new TextDecoder().decode(G))}else if(T===0)for(;B<U.length&&(U[B++]&128)!==0;);else T===5?B+=4:T===1&&(B+=8)}}else x===3&&(y=this._parseDeletionFile(U,_))}else u(P)}if(w){let b=y?m-y.numDeletedRows:m;c.push({id:_,path:w,numRows:b,physicalRows:m,deletionFile:y,url:`${this.baseUrl}/data/${w}`})}}else u(d)}this._schema=a,this._fragments=c,this._numColumns=a.length,this._totalRows=c.reduce((l,h)=>l+h.numRows,0)}_parseDeletionFile(e,t){return zt(e,t,this.baseUrl)}async _loadDeletedRows(e){return Lt(this,e)}async isRowDeleted(e,t){return(await this._loadDeletedRows(e)).has(t)}get numColumns(){return this._numColumns}get rowCount(){return this._totalRows}async getRowCount(e=0){return this._totalRows}async readVectorAt(e,t){let r=this._getFragmentForRow(t);return r?await(await this.openFragment(r.fragmentIndex)).readVectorAt(e,r.localIndex):new Float32Array(0)}async getVectorInfo(e){if(this._fragments.length===0)return{rows:0,dimension:0};let r=await(await this.openFragment(0)).getVectorInfo(e);return r.dimension===0?{rows:0,dimension:0}:{rows:this._totalRows,dimension:r.dimension}}get columnNames(){return this._schema?this._schema.map(e=>e.name):[]}get schema(){return this._schema}get fragments(){return this._fragments}get size(){if(this._cachedSize)return this._cachedSize;let e=0;for(let t=0;t<(this._columnTypes?.length||0);t++){let r=this._columnTypes[t];if(r==="int64"||r==="float64"||r==="double")e+=8;else if(r==="int32"||r==="float32")e+=4;else if(r==="string")e+=50;else if(r==="vector"||r?.startsWith("vector[")){let s=r?.match(/\[(\d+)\]/),n=s?parseInt(s[1]):384;e+=n*4}else e+=8}return e===0&&(e=100),this._cachedSize=this._totalRows*e,this._cachedSize}onFetch(e){this._onFetch=e}async openFragment(e){if(e<0||e>=this._fragments.length)throw new Error(`Invalid fragment index: ${e}`);if(this._fragmentFiles.has(e))return this._fragmentFiles.get(e);let t=this._fragments[e],r=await J.open(this.lanceql,t.url);return this._onFetch&&r.onFetch(this._onFetch),this._fragmentFiles.set(e,r),r}async readRows(e={}){return Qe(this,e)}async detectColumnTypes(){if(this._columnTypes&&this._columnTypes.length>0)return this._columnTypes;if(this._fragments.length===0)return[];let t=await(await this.openFragment(0)).detectColumnTypes();this._columnTypes=t;let r=this._requestedVersion?`${this.baseUrl}@v${this._requestedVersion}`:this.baseUrl;return Be.get(r).then(s=>{s&&(s.columnTypes=t,Be.set(r,s).catch(()=>{}))}).catch(()=>{}),t}_getFragmentForRow(e){return Je(this,e)}_groupIndicesByFragment(e){return $(this,e)}async readStringsAtIndices(e,t){return $t(this,e,t)}async readInt64AtIndices(e,t){return Vt(this,e,t)}async readFloat64AtIndices(e,t){return qt(this,e,t)}async readInt32AtIndices(e,t){return Wt(this,e,t)}async readFloat32AtIndices(e,t){return jt(this,e,t)}async vectorSearch(e,t,r=10,s=null,n={}){return Nt(this,e,t,r,s,n)}_findVectorColumn(){return Dt(this)}async executeSQL(e){return Ht(this,e)}close(){for(let e of this._fragmentFiles.values())e.close&&e.close();this._fragmentFiles.clear()}};var Hr=new TextEncoder,Vn=new TextDecoder,C,le,L=0,X=0,Yt=()=>!L||!X?null:new Uint8Array(le.buffer,L,X),Kt=o=>L&&o<=X?!0:(L&&C.free&&C.free(L,X),X=Math.max(o+1024,4096),L=C.alloc(X),L!==0),Yr=o=>{if(o instanceof Uint8Array)return Kt(o.length)?(Yt().set(o),[L,o.length]):[o];if(typeof o!="string")return[o];let e=Hr.encode(o);return Kt(e.length)?(Yt().set(e),[L,e.length]):[o]};var Kr=o=>({getVersion(){let e=C.getVersion(),t=e>>16&255,r=e>>8&255,s=e&255;return`${t}.${r}.${s}`},open(e){return new ne(o,e)},async openUrl(e){return await z().init(),await J.open(o,e)},async openDataset(e,t={}){return await z().init(),await Q.open(o,e,t)},parseFooter(e){let t=new Uint8Array(e),r=C.alloc(t.length);if(!r)return null;try{new Uint8Array(le.buffer).set(t,r);let s=C.parseFooterGetColumns(r,t.length),n=C.parseFooterGetMajorVersion(r,t.length),i=C.parseFooterGetMinorVersion(r,t.length);return s===0&&n===0?null:{numColumns:s,majorVersion:n,minorVersion:i}}finally{C.free(r,t.length)}},isValidLanceFile(e){let t=new Uint8Array(e),r=C.alloc(t.length);if(!r)return!1;try{return new Uint8Array(le.buffer).set(t,r),C.isValidLanceFile(r,t.length)===1}finally{C.free(r,t.length)}}}),Ue=class{static async load(e="./lanceql.wasm"){let r=await(await fetch(e)).arrayBuffer();C=(await WebAssembly.instantiate(r,{env:{opfs_open:(a,c)=>0,opfs_read:(a,c,f,u)=>0,opfs_size:a=>0n,opfs_close:a=>{},js_log:(a,c)=>{}}})).instance.exports,le=C.memory;let n=null,i=new Proxy({},{get(a,c){return n||(n=Kr(i)),c in n?n[c]:c==="memory"?le:c==="raw"||c==="wasm"?C:typeof C[c]=="function"?(...f)=>C[c](...f.flatMap(Yr)):C[c]}});return i}};var Ae=class{constructor(e){this.name=e,this._ready=!1}async open(){return this._ready?this:(await F("db:open",{name:this.name}),this._ready=!0,this)}async _ensureOpen(){this._ready||await this.open()}async createTable(e,t,r=!1){return await this._ensureOpen(),F("db:createTable",{db:this.name,tableName:e,columns:t,ifNotExists:r})}async dropTable(e,t=!1){return await this._ensureOpen(),F("db:dropTable",{db:this.name,tableName:e,ifExists:t})}async insert(e,t){return await this._ensureOpen(),F("db:insert",{db:this.name,tableName:e,rows:t})}async flush(){return await this._ensureOpen(),F("db:flush",{db:this.name})}async delete(e,t=null){return await this._ensureOpen(),F("db:delete",{db:this.name,tableName:e,where:t})}async update(e,t,r=null){return await this._ensureOpen(),F("db:update",{db:this.name,tableName:e,updates:t,where:r})}async select(e,t={}){await this._ensureOpen();let r={...t};return delete r.where,F("db:select",{db:this.name,tableName:e,options:r,where:t.whereAST||null})}async exec(e){return await this._ensureOpen(),F("db:exec",{db:this.name,sql:e})}async getTable(e){return await this._ensureOpen(),F("db:getTable",{db:this.name,tableName:e})}async listTables(){return await this._ensureOpen(),F("db:listTables",{db:this.name})}async compact(){return await this._ensureOpen(),F("db:compact",{db:this.name})}async*scan(e,t={}){await this._ensureOpen();let r=await F("db:scanStart",{db:this.name,tableName:e,options:t});for(;;){let{batch:s,done:n}=await F("db:scanNext",{db:this.name,streamId:r});if(s.length>0&&(yield s),n)break}}async close(){await this._ensureOpen(),await this.flush()}async listVersions(e){return await this._ensureOpen(),F("db:listVersions",{db:this.name,tableName:e})}async selectAtVersion(e,t,r={}){await this._ensureOpen();let s={...r};return delete s.where,F("db:selectAtVersion",{db:this.name,tableName:e,version:t,options:s,where:r.whereAST||null})}async restoreToVersion(e,t){return await this._ensureOpen(),F("db:restoreTable",{db:this.name,tableName:e,version:t})}};
//# sourceMappingURL=lanceql.js.map
