//! Integration tests using real .lance files generated by Python.
//!
//! These tests validate that our Zig implementation can correctly
//! read files created by the official Lance library.

const std = @import("std");
const lanceql = @import("lanceql");
const format = @import("lanceql.format");
const io = @import("lanceql.io");
const proto = @import("lanceql.proto");
const encoding = @import("lanceql.encoding");
const table_mod = @import("lanceql.table");

const Footer = format.Footer;
const Version = format.Version;
const LanceFile = format.LanceFile;
const FileReader = io.FileReader;
const MemoryReader = io.MemoryReader;
const ColumnMetadata = proto.ColumnMetadata;
const PlainDecoder = encoding.PlainDecoder;
const Table = table_mod.Table;

// Test fixture paths (relative to repo root)
const FIXTURES_DIR = "tests/fixtures";

fn getDataFilePath(allocator: std.mem.Allocator, dataset_name: []const u8) ![]u8 {
    const dataset_dir = try std.fmt.allocPrint(allocator, "{s}/{s}.lance/data", .{ FIXTURES_DIR, dataset_name });
    defer allocator.free(dataset_dir);

    var dir = std.fs.cwd().openDir(dataset_dir, .{ .iterate = true }) catch |err| {
        std.debug.print("Failed to open {s}: {}\n", .{ dataset_dir, err });
        return err;
    };
    defer dir.close();

    var iter = dir.iterate();
    while (try iter.next()) |entry| {
        if (std.mem.endsWith(u8, entry.name, ".lance")) {
            return std.fmt.allocPrint(allocator, "{s}/{s}", .{ dataset_dir, entry.name });
        }
    }

    return error.NoLanceFileFound;
}

fn readFooterFromFile(allocator: std.mem.Allocator, path: []const u8) !Footer {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const stat = try file.stat();
    if (stat.size < lanceql.FOOTER_SIZE) {
        return error.FileTooSmall;
    }

    // Seek to footer position
    try file.seekTo(stat.size - lanceql.FOOTER_SIZE);

    var footer_buf: [lanceql.FOOTER_SIZE]u8 = undefined;
    const bytes_read = try file.readAll(&footer_buf);
    if (bytes_read < lanceql.FOOTER_SIZE) {
        return error.ReadError;
    }

    _ = allocator;
    return Footer.parse(&footer_buf);
}

// ============================================================================
// Simple Int64 Tests
// ============================================================================

test "read simple_int64 footer" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "simple_int64");
    defer allocator.free(path);

    std.debug.print("\nReading: {s}\n", .{path});

    const footer = try readFooterFromFile(allocator, path);

    std.debug.print("Footer parsed successfully!\n", .{});
    std.debug.print("  num_columns: {}\n", .{footer.num_columns});
    std.debug.print("  num_global_buffers: {}\n", .{footer.num_global_buffers});
    std.debug.print("  version: {s} (major={}, minor={})\n", .{
        footer.getVersion().toString(),
        footer.major_version,
        footer.minor_version,
    });
    std.debug.print("  column_meta_start: {}\n", .{footer.column_meta_start});

    // Validate expected values
    try std.testing.expect(footer.num_columns >= 1); // At least 1 column (id)
    try std.testing.expect(footer.isSupported()); // Should be a known version
}

// ============================================================================
// Simple Float64 Tests
// ============================================================================

test "read simple_float64 footer" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "simple_float64");
    defer allocator.free(path);

    const footer = try readFooterFromFile(allocator, path);

    try std.testing.expect(footer.num_columns >= 1);
    try std.testing.expect(footer.isSupported());
}

// ============================================================================
// Mixed Types Tests
// ============================================================================

test "read mixed_types footer" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "mixed_types");
    defer allocator.free(path);

    const footer = try readFooterFromFile(allocator, path);

    std.debug.print("\nmixed_types: {} columns, version {s}\n", .{
        footer.num_columns,
        footer.getVersion().toString(),
    });

    // mixed_types has 3 columns: id, value, name
    try std.testing.expect(footer.num_columns >= 1);
    try std.testing.expect(footer.isSupported());
}

// ============================================================================
// Large File Tests
// ============================================================================

test "read large footer" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "large");
    defer allocator.free(path);

    const footer = try readFooterFromFile(allocator, path);

    std.debug.print("\nlarge: {} columns, version {s}\n", .{
        footer.num_columns,
        footer.getVersion().toString(),
    });

    try std.testing.expect(footer.num_columns >= 1);
    try std.testing.expect(footer.isSupported());
}

// ============================================================================
// Memory Reader Tests (load full file into memory)
// ============================================================================

test "read footer using MemoryReader" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "simple_int64");
    defer allocator.free(path);

    // Read entire file into memory
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const data = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(data);

    // Use MemoryReader
    var mem_reader = MemoryReader.init(data);
    var reader = mem_reader.reader();

    const file_size = try reader.size();
    try std.testing.expect(file_size >= lanceql.FOOTER_SIZE);

    // Read footer using Reader interface
    var footer_buf: [lanceql.FOOTER_SIZE]u8 = undefined;
    try reader.readExact(file_size - lanceql.FOOTER_SIZE, &footer_buf);

    const footer = try Footer.parse(&footer_buf);
    try std.testing.expect(footer.isSupported());

    std.debug.print("\nMemoryReader test: {} columns, version {s}\n", .{
        footer.num_columns,
        footer.getVersion().toString(),
    });
}

// ============================================================================
// All Fixtures Test
// ============================================================================

test "validate all fixture footers" {
    const allocator = std.testing.allocator;

    const fixtures = [_][]const u8{
        "simple_int64",
        "simple_float64",
        "mixed_types",
        "with_nulls",
        "empty",
        "large",
        "multiple_batches",
    };

    std.debug.print("\n", .{});

    for (fixtures) |name| {
        const path = getDataFilePath(allocator, name) catch |err| {
            std.debug.print("  {s}: SKIP ({})\n", .{ name, err });
            continue;
        };
        defer allocator.free(path);

        const footer = readFooterFromFile(allocator, path) catch |err| {
            std.debug.print("  {s}: FAIL ({})\n", .{ name, err });
            continue;
        };

        std.debug.print("  {s}: OK - {} cols, {s}\n", .{
            name,
            footer.num_columns,
            footer.getVersion().toString(),
        });

        try std.testing.expect(footer.isSupported());
    }
}

// ============================================================================
// LanceFile Tests (full file parsing with offset tables)
// ============================================================================

test "LanceFile parses simple_int64 completely" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "simple_int64");
    defer allocator.free(path);

    // Read entire file into memory
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const data = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(data);

    // Open with LanceFile
    var lance_file = try LanceFile.init(allocator, data);
    defer lance_file.deinit();

    std.debug.print("\nLanceFile simple_int64:\n", .{});
    std.debug.print("  num_columns: {}\n", .{lance_file.numColumns()});
    std.debug.print("  num_global_buffers: {}\n", .{lance_file.footer.num_global_buffers});
    std.debug.print("  version: {s}\n", .{lance_file.version().toString()});

    // Validate
    try std.testing.expectEqual(@as(u32, 1), lance_file.numColumns());
    try std.testing.expect(lance_file.footer.num_global_buffers >= 1);

    // Check column metadata entry
    const col_meta = try lance_file.getColumnMetadataBytes(0);
    std.debug.print("  column 0 metadata: {} bytes\n", .{col_meta.len});
    try std.testing.expect(col_meta.len > 0);

    // Check global buffer (schema)
    if (lance_file.getSchemaBytes()) |schema_bytes| {
        std.debug.print("  schema buffer: {} bytes\n", .{schema_bytes.len});
        try std.testing.expect(schema_bytes.len > 0);
    }
}

test "LanceFile parses mixed_types with multiple columns" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "mixed_types");
    defer allocator.free(path);

    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const data = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(data);

    var lance_file = try LanceFile.init(allocator, data);
    defer lance_file.deinit();

    std.debug.print("\nLanceFile mixed_types:\n", .{});
    std.debug.print("  num_columns: {}\n", .{lance_file.numColumns()});

    // mixed_types has 3 columns: id (int64), value (float64), name (string)
    try std.testing.expectEqual(@as(u32, 3), lance_file.numColumns());

    // Verify we can read all column metadata
    var i: u32 = 0;
    while (i < lance_file.numColumns()) : (i += 1) {
        const col_meta = try lance_file.getColumnMetadataBytes(i);
        std.debug.print("  column {} metadata: {} bytes\n", .{ i, col_meta.len });
        try std.testing.expect(col_meta.len > 0);
    }
}

test "LanceFile column out of bounds" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "simple_int64");
    defer allocator.free(path);

    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const data = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(data);

    var lance_file = try LanceFile.init(allocator, data);
    defer lance_file.deinit();

    // Should fail - only 1 column exists
    const result = lance_file.getColumnMetadataBytes(99);
    try std.testing.expectError(format.lance_file.LanceFileError.ColumnOutOfBounds, result);
}

// ============================================================================
// Column Metadata Parsing Tests
// ============================================================================

test "parse column metadata from simple_int64" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "simple_int64");
    defer allocator.free(path);

    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const data = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(data);

    var lance_file = try LanceFile.init(allocator, data);
    defer lance_file.deinit();

    // Get raw column metadata bytes
    const col_meta_bytes = try lance_file.getColumnMetadataBytes(0);

    // Parse protobuf metadata
    var col_meta = try ColumnMetadata.parse(allocator, col_meta_bytes);
    defer col_meta.deinit(allocator);

    std.debug.print("\nColumn metadata for simple_int64:\n", .{});
    std.debug.print("  pages: {}\n", .{col_meta.pages.len});
    std.debug.print("  row_count: {}\n", .{col_meta.rowCount()});

    // Should have at least one page
    try std.testing.expect(col_meta.pages.len >= 1);

    // simple_int64 has 5 rows
    try std.testing.expectEqual(@as(u64, 5), col_meta.rowCount());

    // Print page info
    for (col_meta.pages, 0..) |page, i| {
        std.debug.print("  page {}: length={}, buffers={}\n", .{
            i,
            page.length,
            page.buffer_offsets.len,
        });
        for (page.buffer_offsets, 0..) |offset, j| {
            std.debug.print("    buffer {}: offset={}, size={}\n", .{
                j,
                offset,
                page.buffer_sizes[j],
            });
        }
    }
}

test "parse column metadata from large dataset" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "large");
    defer allocator.free(path);

    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const data = try file.readToEndAlloc(allocator, 10 * 1024 * 1024);
    defer allocator.free(data);

    var lance_file = try LanceFile.init(allocator, data);
    defer lance_file.deinit();

    // Parse first column metadata
    const col_meta_bytes = try lance_file.getColumnMetadataBytes(0);
    var col_meta = try ColumnMetadata.parse(allocator, col_meta_bytes);
    defer col_meta.deinit(allocator);

    std.debug.print("\nColumn metadata for large dataset:\n", .{});
    std.debug.print("  pages: {}\n", .{col_meta.pages.len});
    std.debug.print("  row_count: {}\n", .{col_meta.rowCount()});

    // Large dataset has 10000 rows
    try std.testing.expectEqual(@as(u64, 10000), col_meta.rowCount());
}

// ============================================================================
// End-to-End Value Reading Tests
// ============================================================================

test "read int64 values from simple_int64" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "simple_int64");
    defer allocator.free(path);

    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const data = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(data);

    var lance_file = try LanceFile.init(allocator, data);
    defer lance_file.deinit();

    // Parse column metadata
    const col_meta_bytes = try lance_file.getColumnMetadataBytes(0);
    var col_meta = try ColumnMetadata.parse(allocator, col_meta_bytes);
    defer col_meta.deinit(allocator);

    // Get page buffer data
    try std.testing.expect(col_meta.pages.len >= 1);
    const page = col_meta.pages[0];

    try std.testing.expect(page.buffer_offsets.len >= 1);
    const buffer_offset = page.buffer_offsets[0];
    const buffer_size = page.buffer_sizes[0];

    // Read data buffer
    const buffer_data = try lance_file.readBytes(buffer_offset, buffer_size);

    // Decode int64 values
    const decoder = PlainDecoder.init(buffer_data);
    const values = try decoder.readAllInt64(allocator);
    defer allocator.free(values);

    std.debug.print("\nRead int64 values from simple_int64:\n", .{});
    std.debug.print("  values: {any}\n", .{values});

    // Expected values: [1, 2, 3, 4, 5]
    try std.testing.expectEqual(@as(usize, 5), values.len);
    try std.testing.expectEqual(@as(i64, 1), values[0]);
    try std.testing.expectEqual(@as(i64, 2), values[1]);
    try std.testing.expectEqual(@as(i64, 3), values[2]);
    try std.testing.expectEqual(@as(i64, 4), values[3]);
    try std.testing.expectEqual(@as(i64, 5), values[4]);

    std.debug.print("  ✓ Values match expected [1, 2, 3, 4, 5]\n", .{});
}

test "read float64 values from simple_float64" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "simple_float64");
    defer allocator.free(path);

    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const data = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(data);

    var lance_file = try LanceFile.init(allocator, data);
    defer lance_file.deinit();

    // Parse column metadata
    const col_meta_bytes = try lance_file.getColumnMetadataBytes(0);
    var col_meta = try ColumnMetadata.parse(allocator, col_meta_bytes);
    defer col_meta.deinit(allocator);

    // Get page buffer data
    try std.testing.expect(col_meta.pages.len >= 1);
    const page = col_meta.pages[0];

    try std.testing.expect(page.buffer_offsets.len >= 1);
    const buffer_offset = page.buffer_offsets[0];
    const buffer_size = page.buffer_sizes[0];

    // Read data buffer
    const buffer_data = try lance_file.readBytes(buffer_offset, buffer_size);

    // Decode float64 values
    const decoder = PlainDecoder.init(buffer_data);
    const values = try decoder.readAllFloat64(allocator);
    defer allocator.free(values);

    std.debug.print("\nRead float64 values from simple_float64:\n", .{});
    std.debug.print("  values: {any}\n", .{values});

    // Expected values: [1.5, 2.5, 3.5, 4.5, 5.5]
    try std.testing.expectEqual(@as(usize, 5), values.len);
    try std.testing.expectApproxEqRel(@as(f64, 1.5), values[0], 1e-10);
    try std.testing.expectApproxEqRel(@as(f64, 2.5), values[1], 1e-10);
    try std.testing.expectApproxEqRel(@as(f64, 3.5), values[2], 1e-10);
    try std.testing.expectApproxEqRel(@as(f64, 4.5), values[3], 1e-10);
    try std.testing.expectApproxEqRel(@as(f64, 5.5), values[4], 1e-10);

    std.debug.print("  ✓ Values match expected [1.5, 2.5, 3.5, 4.5, 5.5]\n", .{});
}

// ============================================================================
// High-Level Table API Tests
// ============================================================================

test "Table API reads simple_int64" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "simple_int64");
    defer allocator.free(path);

    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const data = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(data);

    // Open with Table API
    var tbl = try Table.init(allocator, data);
    defer tbl.deinit();

    std.debug.print("\nTable API simple_int64:\n", .{});
    std.debug.print("  num_columns: {}\n", .{tbl.numColumns()});

    // Read values directly using Table API
    const values = try tbl.readInt64Column(0);
    defer allocator.free(values);

    std.debug.print("  values: {any}\n", .{values});

    // Verify
    try std.testing.expectEqual(@as(usize, 5), values.len);
    try std.testing.expectEqual(@as(i64, 1), values[0]);
    try std.testing.expectEqual(@as(i64, 5), values[4]);

    std.debug.print("  ✓ Table API works!\n", .{});
}

test "Table API with schema access" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "mixed_types");
    defer allocator.free(path);

    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const data = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(data);

    var tbl = try Table.init(allocator, data);
    defer tbl.deinit();

    std.debug.print("\nTable API mixed_types with schema:\n", .{});

    // Check schema is present
    if (tbl.getSchema()) |schema| {
        std.debug.print("  schema fields: {}\n", .{schema.fields.len});

        for (schema.fields) |field| {
            std.debug.print("    - {s} ({s})\n", .{ field.name, field.logical_type });
        }
    } else {
        std.debug.print("  no schema found\n", .{});
    }

    // Read columns by index
    const id_values = try tbl.readInt64Column(0);
    defer allocator.free(id_values);

    const value_values = try tbl.readFloat64Column(1);
    defer allocator.free(value_values);

    std.debug.print("  id column: {any}\n", .{id_values});
    std.debug.print("  value column: {any}\n", .{value_values});

    // mixed_types has 3 rows: id=[1,2,3], value=[1.5,2.5,3.5]
    try std.testing.expectEqual(@as(usize, 3), id_values.len);
    try std.testing.expectEqual(@as(i64, 1), id_values[0]);
    try std.testing.expectEqual(@as(i64, 3), id_values[2]);
    try std.testing.expectApproxEqRel(@as(f64, 1.5), value_values[0], 1e-10);
    try std.testing.expectApproxEqRel(@as(f64, 3.5), value_values[2], 1e-10);

    std.debug.print("  ✓ Schema and column access works!\n", .{});
}

// ============================================================================
// HTTP Range Request Tests (requires network)
// ============================================================================

const HttpReader = io.HttpReader;

test "HTTP reader can read remote Lance file footer" {
    const allocator = std.testing.allocator;

    const url = "https://data.metal0.dev/laion-1m/images.lance/data/110101001111011111011011ded2064282ae29b42f5d744a13.lance";

    std.debug.print("\nHTTP Reader test:\n", .{});
    std.debug.print("  URL: {s}\n", .{url});

    // Open HTTP reader
    var http = HttpReader.open(allocator, url) catch |err| {
        std.debug.print("  SKIP: Could not connect ({any})\n", .{err});
        return; // Skip if network unavailable
    };
    defer http.deinit();

    std.debug.print("  File size: {d} bytes ({d:.2} GB)\n", .{ http.file_size, @as(f64, @floatFromInt(http.file_size)) / (1024 * 1024 * 1024) });

    // Read footer (last 40 bytes)
    var footer_buf: [40]u8 = undefined;
    const footer_offset = http.file_size - 40;
    const bytes_read = try http.readAt(footer_offset, &footer_buf);

    try std.testing.expectEqual(@as(usize, 40), bytes_read);

    // Check magic
    try std.testing.expectEqualSlices(u8, "LANC", footer_buf[36..40]);
    std.debug.print("  ✓ LANC magic verified\n", .{});

    // Parse footer
    const footer = try Footer.parse(&footer_buf);
    std.debug.print("  num_columns: {}\n", .{footer.num_columns});
    std.debug.print("  version: {}.{}\n", .{ footer.major_version, footer.minor_version });
    std.debug.print("  column_meta_start: {}\n", .{footer.column_meta_start});

    // Verify expected values (from curl test)
    try std.testing.expectEqual(@as(u32, 6), footer.num_columns);
    std.debug.print("  ✓ HTTP Range request works!\n", .{});
}
