//! Integration tests using real .lance files generated by Python.
//!
//! These tests validate that our Zig implementation can correctly
//! read files created by the official Lance library.

const std = @import("std");
const lanceql = @import("lanceql");
const format = @import("lanceql.format");
const io = @import("lanceql.io");

const Footer = format.Footer;
const Version = format.Version;
const FileReader = io.FileReader;
const MemoryReader = io.MemoryReader;

// Test fixture paths (relative to repo root)
const FIXTURES_DIR = "tests/fixtures";

fn getDataFilePath(allocator: std.mem.Allocator, dataset_name: []const u8) ![]u8 {
    const dataset_dir = try std.fmt.allocPrint(allocator, "{s}/{s}.lance/data", .{ FIXTURES_DIR, dataset_name });
    defer allocator.free(dataset_dir);

    var dir = std.fs.cwd().openDir(dataset_dir, .{ .iterate = true }) catch |err| {
        std.debug.print("Failed to open {s}: {}\n", .{ dataset_dir, err });
        return err;
    };
    defer dir.close();

    var iter = dir.iterate();
    while (try iter.next()) |entry| {
        if (std.mem.endsWith(u8, entry.name, ".lance")) {
            return std.fmt.allocPrint(allocator, "{s}/{s}", .{ dataset_dir, entry.name });
        }
    }

    return error.NoLanceFileFound;
}

fn readFooterFromFile(allocator: std.mem.Allocator, path: []const u8) !Footer {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const stat = try file.stat();
    if (stat.size < lanceql.FOOTER_SIZE) {
        return error.FileTooSmall;
    }

    // Seek to footer position
    try file.seekTo(stat.size - lanceql.FOOTER_SIZE);

    var footer_buf: [lanceql.FOOTER_SIZE]u8 = undefined;
    const bytes_read = try file.readAll(&footer_buf);
    if (bytes_read < lanceql.FOOTER_SIZE) {
        return error.ReadError;
    }

    _ = allocator;
    return Footer.parse(&footer_buf);
}

// ============================================================================
// Simple Int64 Tests
// ============================================================================

test "read simple_int64 footer" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "simple_int64");
    defer allocator.free(path);

    std.debug.print("\nReading: {s}\n", .{path});

    const footer = try readFooterFromFile(allocator, path);

    std.debug.print("Footer parsed successfully!\n", .{});
    std.debug.print("  num_columns: {}\n", .{footer.num_columns});
    std.debug.print("  num_global_buffers: {}\n", .{footer.num_global_buffers});
    std.debug.print("  version: {s} (major={}, minor={})\n", .{
        footer.getVersion().toString(),
        footer.major_version,
        footer.minor_version,
    });
    std.debug.print("  column_meta_start: {}\n", .{footer.column_meta_start});

    // Validate expected values
    try std.testing.expect(footer.num_columns >= 1); // At least 1 column (id)
    try std.testing.expect(footer.isSupported()); // Should be a known version
}

// ============================================================================
// Simple Float64 Tests
// ============================================================================

test "read simple_float64 footer" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "simple_float64");
    defer allocator.free(path);

    const footer = try readFooterFromFile(allocator, path);

    try std.testing.expect(footer.num_columns >= 1);
    try std.testing.expect(footer.isSupported());
}

// ============================================================================
// Mixed Types Tests
// ============================================================================

test "read mixed_types footer" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "mixed_types");
    defer allocator.free(path);

    const footer = try readFooterFromFile(allocator, path);

    std.debug.print("\nmixed_types: {} columns, version {s}\n", .{
        footer.num_columns,
        footer.getVersion().toString(),
    });

    // mixed_types has 3 columns: id, value, name
    try std.testing.expect(footer.num_columns >= 1);
    try std.testing.expect(footer.isSupported());
}

// ============================================================================
// Large File Tests
// ============================================================================

test "read large footer" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "large");
    defer allocator.free(path);

    const footer = try readFooterFromFile(allocator, path);

    std.debug.print("\nlarge: {} columns, version {s}\n", .{
        footer.num_columns,
        footer.getVersion().toString(),
    });

    try std.testing.expect(footer.num_columns >= 1);
    try std.testing.expect(footer.isSupported());
}

// ============================================================================
// Memory Reader Tests (load full file into memory)
// ============================================================================

test "read footer using MemoryReader" {
    const allocator = std.testing.allocator;

    const path = try getDataFilePath(allocator, "simple_int64");
    defer allocator.free(path);

    // Read entire file into memory
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const data = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(data);

    // Use MemoryReader
    var mem_reader = MemoryReader.init(data);
    var reader = mem_reader.reader();

    const file_size = try reader.size();
    try std.testing.expect(file_size >= lanceql.FOOTER_SIZE);

    // Read footer using Reader interface
    var footer_buf: [lanceql.FOOTER_SIZE]u8 = undefined;
    try reader.readExact(file_size - lanceql.FOOTER_SIZE, &footer_buf);

    const footer = try Footer.parse(&footer_buf);
    try std.testing.expect(footer.isSupported());

    std.debug.print("\nMemoryReader test: {} columns, version {s}\n", .{
        footer.num_columns,
        footer.getVersion().toString(),
    });
}

// ============================================================================
// All Fixtures Test
// ============================================================================

test "validate all fixture footers" {
    const allocator = std.testing.allocator;

    const fixtures = [_][]const u8{
        "simple_int64",
        "simple_float64",
        "mixed_types",
        "with_nulls",
        "empty",
        "large",
        "multiple_batches",
    };

    std.debug.print("\n", .{});

    for (fixtures) |name| {
        const path = getDataFilePath(allocator, name) catch |err| {
            std.debug.print("  {s}: SKIP ({})\n", .{ name, err });
            continue;
        };
        defer allocator.free(path);

        const footer = readFooterFromFile(allocator, path) catch |err| {
            std.debug.print("  {s}: FAIL ({})\n", .{ name, err });
            continue;
        };

        std.debug.print("  {s}: OK - {} cols, {s}\n", .{
            name,
            footer.num_columns,
            footer.getVersion().toString(),
        });

        try std.testing.expect(footer.isSupported());
    }
}
