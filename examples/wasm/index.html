<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LanceQL - Query Lance Files in the Browser</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        body {
            margin: 0;
            padding: 0;
            background: #0f172a;
            color: #e2e8f0;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 0;
            border-bottom: 1px solid #334155;
            margin-bottom: 20px;
        }
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 24px;
            font-weight: 700;
            color: #f8fafc;
        }
        .logo svg {
            width: 32px;
            height: 32px;
        }
        .version {
            font-size: 12px;
            color: #64748b;
            font-weight: normal;
        }
        .github-link {
            color: #94a3b8;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .github-link:hover {
            color: #f8fafc;
        }

        /* File loader */
        .file-section {
            background: #1e293b;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .drop-zone {
            border: 2px dashed #475569;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
        }
        .drop-zone p {
            margin: 5px 0;
            color: #94a3b8;
        }
        .drop-zone p:first-child {
            color: #e2e8f0;
            font-size: 16px;
        }
        #file-input {
            display: none;
        }
        .divider {
            text-align: center;
            margin: 15px 0;
            color: #64748b;
            font-size: 14px;
        }
        .url-input-group {
            display: flex;
            gap: 10px;
        }
        .url-input-group input {
            flex: 1;
            padding: 12px 15px;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 8px;
            color: #e2e8f0;
            font-size: 14px;
        }
        .url-input-group input:focus {
            outline: none;
            border-color: #3b82f6;
        }
        .url-input-group input::placeholder {
            color: #64748b;
        }
        .file-info {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: #0f172a;
            border-radius: 8px;
            margin-top: 15px;
        }
        .file-info.hidden {
            display: none;
        }
        .btn-change-file {
            margin-left: auto;
            padding: 6px 12px;
            background: transparent;
            border: 1px solid #475569;
            border-radius: 6px;
            color: #94a3b8;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-change-file:hover {
            background: #1e293b;
            border-color: #64748b;
            color: #e2e8f0;
        }
        #file-loader-section {
            transition: all 0.3s ease;
        }
        #file-loader-section.collapsed {
            display: none;
        }
        .file-icon {
            width: 48px;
            height: 48px;
            background: #3b82f6;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
        }
        .file-details h3 {
            margin: 0 0 5px 0;
            color: #f8fafc;
        }
        .file-details p {
            margin: 0;
            color: #64748b;
            font-size: 14px;
        }
        .file-stats {
            display: flex;
            gap: 20px;
            margin-left: auto;
        }
        .stat {
            text-align: center;
        }
        .stat-value {
            font-size: 20px;
            font-weight: 600;
            color: #3b82f6;
        }
        .stat-label {
            font-size: 12px;
            color: #64748b;
        }

        /* Tabs */
        .tabs-container {
            background: #1e293b;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .tabs-header {
            display: flex;
            background: #0f172a;
            border-bottom: 1px solid #334155;
        }
        .tab-btn {
            flex: 1;
            padding: 15px 20px;
            background: transparent;
            border: none;
            color: #64748b;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .tab-btn:hover {
            color: #94a3b8;
            background: rgba(255,255,255,0.05);
        }
        .tab-btn.active {
            color: #3b82f6;
            background: #1e293b;
            border-bottom: 2px solid #3b82f6;
        }
        .tab-content {
            display: none;
            padding: 20px;
        }
        .tab-content.active {
            display: block;
        }

        /* SQL Editor */
        .sql-editor {
            position: relative;
        }
        .sql-editor-container {
            position: relative;
            width: 100%;
            height: 150px;
        }
        .sql-highlight, .sql-textarea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 15px;
            margin: 0;
            border: 1px solid #334155;
            border-radius: 8px;
            font: 14px/1.5 ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, 'Liberation Mono', monospace;
            letter-spacing: normal;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            box-sizing: border-box;
            overflow: auto;
            tab-size: 4;
            -moz-tab-size: 4;
        }
        .sql-highlight {
            background: #0f172a;
            pointer-events: none;
            z-index: 1;
        }
        .sql-textarea {
            background: transparent;
            border-color: transparent;
            color: transparent;
            caret-color: #e2e8f0;
            resize: none;
            z-index: 2;
            -webkit-text-fill-color: transparent;
        }
        .sql-textarea:focus {
            outline: none;
        }
        .sql-textarea:focus + .sql-highlight {
            border-color: #3b82f6;
        }
        /* SQL syntax highlighting colors */
        .sql-highlight span {
            font: inherit;
        }
        .sql-keyword { color: #c084fc; }
        .sql-function { color: #60a5fa; }
        .sql-string { color: #4ade80; }
        .sql-number { color: #fbbf24; }
        .sql-operator { color: #f472b6; }
        .sql-comment { color: #64748b; }
        .sql-identifier { color: #e2e8f0; }
        .sql-examples {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .sql-example {
            padding: 6px 12px;
            background: #334155;
            border: none;
            border-radius: 6px;
            color: #94a3b8;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .sql-example:hover {
            background: #475569;
            color: #e2e8f0;
        }
        .sql-example.copy-link-btn {
            background: #1e3a5f;
            color: #60a5fa;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .sql-example.copy-link-btn:hover {
            background: #1e40af;
            color: #93c5fd;
        }

        /* DataFrame Builder */
        .df-builder {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .df-step {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: #0f172a;
            border-radius: 8px;
        }
        .df-step-num {
            width: 28px;
            height: 28px;
            background: #3b82f6;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            flex-shrink: 0;
        }
        .df-step-label {
            width: 80px;
            color: #94a3b8;
            font-size: 14px;
            flex-shrink: 0;
        }
        .df-step select, .df-step input {
            padding: 8px 12px;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 6px;
            color: #e2e8f0;
            font-size: 14px;
        }
        .df-step select:focus, .df-step input:focus {
            outline: none;
            border-color: #3b82f6;
        }
        .df-step input[type="number"] {
            width: 100px;
        }
        /* DataFrame code editor - same overlay technique as SQL */
        .df-editor-container {
            position: relative;
            width: 100%;
            height: 200px;
        }
        .df-highlight, .df-textarea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 15px;
            margin: 0;
            border: 1px solid #334155;
            border-radius: 8px;
            font: 13px/1.5 ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, 'Liberation Mono', monospace;
            letter-spacing: normal;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            box-sizing: border-box;
            overflow: auto;
            tab-size: 4;
            -moz-tab-size: 4;
        }
        .df-highlight {
            background: #0f172a;
            pointer-events: none;
            z-index: 1;
        }
        .df-highlight span {
            font: inherit;
        }
        .df-textarea {
            background: transparent;
            border-color: transparent;
            color: transparent;
            caret-color: #e2e8f0;
            resize: none;
            z-index: 2;
            -webkit-text-fill-color: transparent;
        }
        .df-textarea:focus {
            outline: none;
        }
        .df-textarea:focus + .df-highlight {
            border-color: #3b82f6;
        }
        /* DataFrame syntax highlighting */
        .df-keyword { color: #93c5fd; }
        .df-string { color: #fcd34d; }
        .df-number { color: #86efac; }
        .df-method { color: #c4b5fd; }
        .df-comment { color: #64748b; }

        /* Run button */
        .run-section {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .btn-primary {
            background: #3b82f6;
            color: white;
            border: none;
        }
        .btn-primary:hover {
            background: #2563eb;
        }
        .btn-primary:disabled {
            background: #475569;
            cursor: not-allowed;
        }
        .btn-secondary {
            background: transparent;
            color: #94a3b8;
            border: 1px solid #475569;
        }
        .btn-secondary:hover {
            background: rgba(255,255,255,0.05);
            color: #e2e8f0;
        }

        /* Results Grid */
        .results-section {
            background: #1e293b;
            border-radius: 12px;
            overflow: hidden;
        }
        .results-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            background: #0f172a;
            border-bottom: 1px solid #334155;
        }
        .results-header h3 {
            margin: 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .results-count {
            font-size: 14px;
            color: #64748b;
        }
        .results-notice {
            color: #f59e0b;
            font-size: 12px;
            background: rgba(245, 158, 11, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            margin-left: 8px;
        }
        .dataset-hint {
            color: #94a3b8;
            font-size: 12px;
            padding: 8px 12px;
            background: rgba(148, 163, 184, 0.1);
            border-radius: 6px;
            margin-top: 10px;
            line-height: 1.4;
        }
        .dataset-hint strong {
            color: #e2e8f0;
        }
        .results-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .export-btn {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 6px 12px;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 6px;
            color: #94a3b8;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .export-btn:hover {
            background: #334155;
            color: #e2e8f0;
        }
        .export-btn svg {
            opacity: 0.7;
        }
        .results-body {
            padding: 20px;
            height: calc(100vh - 200px);
            min-height: 400px;
            overflow: auto;
        }

        /* Data Table */
        .data-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 14px;
        }
        .data-table th {
            padding: 12px;
            text-align: left;
            background: #334155;
            color: #e2e8f0;
            font-weight: 500;
            position: sticky;
            top: -20px;
            z-index: 1;
        }
        .data-table td {
            padding: 12px;
            border-bottom: 1px solid #334155;
            color: #94a3b8;
        }
        .data-table tr:hover td {
            background: rgba(255,255,255,0.02);
        }

        /* Cell formatting */
        .null-value {
            color: #64748b;
            font-style: italic;
        }
        .empty-value {
            color: #64748b;
            font-style: italic;
            font-size: 12px;
        }
        .url-link {
            color: #60a5fa;
            text-decoration: none;
            word-break: break-all;
        }
        .url-link:hover {
            text-decoration: underline;
        }
        .image-cell {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-width: 150px;
        }
        .image-cell img {
            max-width: 100px;
            max-height: 60px;
            object-fit: cover;
            border-radius: 4px;
            background: #1e293b;
        }
        .image-cell img.placeholder {
            opacity: 0.6;
        }
        .image-cell .url-text {
            font-size: 11px;
            color: #64748b;
            text-decoration: none;
            word-break: break-all;
        }
        .image-cell .url-text:hover {
            color: #60a5fa;
        }

        /* Scroll loader */
        .scroll-loader {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 20px;
            color: #64748b;
            font-size: 14px;
        }

        /* Vector and Hash badges */
        .vector-badge, .hash-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }
        .vector-badge {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }
        .hash-badge {
            background: rgba(100, 116, 139, 0.2);
            color: #94a3b8;
            border: 1px solid rgba(100, 116, 139, 0.3);
        }
        .vector-badge svg, .hash-badge svg {
            opacity: 0.8;
        }

        /* Find Similar Button */
        .find-similar-btn {
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(139, 92, 246, 0.4);
            border-radius: 4px;
            padding: 4px 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.15s ease;
        }
        .find-similar-btn:hover {
            background: rgba(139, 92, 246, 0.4);
            transform: scale(1.1);
        }
        .find-similar-btn:active {
            transform: scale(0.95);
        }

        /* Image Grid */
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
        }
        .image-card {
            background: #0f172a;
            border-radius: 8px;
            overflow: hidden;
        }
        .image-card img {
            width: 100%;
            height: 150px;
            object-fit: cover;
        }
        .image-card-info {
            padding: 10px;
        }
        .image-card-info p {
            margin: 0;
            font-size: 12px;
            color: #64748b;
        }

        /* Aggregations Bar */
        .agg-bar {
            display: flex;
            gap: 20px;
            padding: 15px 20px;
            background: #0f172a;
            border-bottom: 1px solid #334155;
            overflow-x: auto;
        }
        .agg-item {
            text-align: center;
            min-width: 80px;
        }
        .agg-value {
            font-size: 20px;
            font-weight: 600;
            color: #3b82f6;
        }
        .agg-label {
            font-size: 11px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Status messages */
        .status {
            padding: 12px 15px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
        }
        .status.show {
            display: block;
        }
        .status.success {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.3);
            color: #86efac;
        }
        .status.error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
        }
        .status.info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            color: #93c5fd;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #64748b;
        }
        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        .empty-state h3 {
            margin: 0 0 10px 0;
            color: #94a3b8;
        }
        .empty-state p {
            margin: 0;
        }

        /* Loading spinner */
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Progress bar */
        .progress-container {
            margin-top: 15px;
            display: none;
        }
        .progress-container.show {
            display: block;
        }
        .progress-bar {
            height: 6px;
            background: #334155;
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }
        .progress-text {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 12px;
            color: #64748b;
        }

        /* Network stats */
        .network-stats {
            display: flex;
            gap: 20px;
            padding: 10px 15px;
            background: #0f172a;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 12px;
        }
        .network-stats.hidden {
            display: none;
        }
        .network-stat {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #94a3b8;
        }
        .network-stat svg {
            width: 14px;
            height: 14px;
        }
        .network-stat strong {
            color: #3b82f6;
        }

        /* Column info chips */
        .column-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        .column-chip {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: #334155;
            border-radius: 12px;
            font-size: 11px;
            color: #94a3b8;
        }
        .column-chip .type {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
        }
        .column-chip .type.string { background: #065f46; color: #6ee7b7; }
        .column-chip .type.int64 { background: #1e40af; color: #93c5fd; }
        .column-chip .type.int32 { background: #1e40af; color: #93c5fd; }
        .column-chip .type.int16 { background: #1e40af; color: #93c5fd; }
        .column-chip .type.int8 { background: #1e40af; color: #93c5fd; }
        .column-chip .type.float64 { background: #7c2d12; color: #fdba74; }
        .column-chip .type.float32 { background: #7c2d12; color: #fdba74; }
        .column-chip .type.unknown { background: #374151; color: #9ca3af; }
        .column-chip .type.vector { background: #7c3aed; color: #ddd6fe; }
        .column-chip {
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            position: relative;
        }
        .column-chip:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .column-chip.loading::after {
            content: '...';
            margin-left: 4px;
        }
        .column-stats-popup {
            position: fixed;
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 8px;
            padding: 12px;
            z-index: 1000;
            min-width: 200px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            font-size: 12px;
        }
        .column-stats-popup h4 {
            margin: 0 0 8px 0;
            color: #e2e8f0;
            font-size: 13px;
            border-bottom: 1px solid #475569;
            padding-bottom: 6px;
        }
        .column-stats-popup .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            color: #94a3b8;
        }
        .column-stats-popup .stat-row .label {
            color: #64748b;
        }
        .column-stats-popup .stat-row .value {
            color: #e2e8f0;
            font-family: 'SF Mono', Monaco, monospace;
        }
        .column-stats-popup .close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #64748b;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
        }
        .column-stats-popup .close-btn:hover {
            color: #e2e8f0;
        }

        /* Vector Search */
        .vector-search {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .vector-search-input {
            display: flex;
            gap: 10px;
        }
        .vector-search-input input {
            flex: 1;
            padding: 12px 15px;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 8px;
            color: #e2e8f0;
            font-size: 14px;
        }
        .vector-search-input input:focus {
            outline: none;
            border-color: #7c3aed;
        }
        .vector-search-input input::placeholder {
            color: #64748b;
        }
        .vector-config {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .vector-config label {
            color: #94a3b8;
            font-size: 14px;
        }
        .vector-config select, .vector-config input[type="number"] {
            padding: 8px 12px;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 6px;
            color: #e2e8f0;
            font-size: 14px;
        }
        .vector-config input[type="number"] {
            width: 80px;
        }
        .search-examples {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .search-example {
            padding: 6px 12px;
            background: #334155;
            border: none;
            border-radius: 6px;
            color: #94a3b8;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .search-example:hover {
            background: #7c3aed;
            color: white;
        }
        .vector-notice {
            padding: 12px 15px;
            background: rgba(124, 58, 237, 0.1);
            border: 1px solid rgba(124, 58, 237, 0.3);
            border-radius: 8px;
            color: #a78bfa;
            font-size: 13px;
        }

        /* CLIP Text Search */
        .clip-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #334155;
        }
        .clip-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        .clip-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #e2e8f0;
        }
        .clip-title .badge {
            font-size: 10px;
            padding: 2px 6px;
            background: #22c55e;
            color: white;
            border-radius: 4px;
        }
        .clip-title .badge.loading {
            background: #f59e0b;
        }
        .clip-title .badge.error {
            background: #ef4444;
        }
        .clip-load-btn {
            padding: 6px 12px;
            background: #334155;
            border: none;
            border-radius: 6px;
            color: #94a3b8;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .clip-load-btn:hover {
            background: #475569;
            color: #e2e8f0;
        }
        .clip-load-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .clip-text-input {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .clip-text-input input {
            flex: 1;
            padding: 12px 15px;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 8px;
            color: #e2e8f0;
            font-size: 14px;
        }
        .clip-text-input input:focus {
            outline: none;
            border-color: #22c55e;
        }
        .clip-text-input input::placeholder {
            color: #64748b;
        }
        .clip-examples {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .clip-example {
            padding: 6px 12px;
            background: #334155;
            border: none;
            border-radius: 6px;
            color: #94a3b8;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .clip-example:hover {
            background: #22c55e;
            color: white;
        }
        .btn-clip-search {
            background: #22c55e !important;
        }
        .btn-clip-search:hover {
            background: #16a34a !important;
        }
        .btn-clip-search:disabled {
            background: #475569 !important;
        }
        .clip-mode-toggle {
            display: flex;
            align-items: center;
        }
        .clip-model-select {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #94a3b8;
        }
        .clip-model-select select {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 4px;
            color: #e2e8f0;
            padding: 4px 8px;
            font-size: 12px;
        }
        .toggle-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 12px;
            color: #94a3b8;
        }
        .toggle-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        .clip-note {
            margin-top: 10px;
            color: #64748b;
            font-size: 11px;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="./" class="logo" style="text-decoration: none; color: inherit;">
                <svg viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <rect width="32" height="32" rx="8" fill="#3b82f6"/>
                    <path d="M8 10h16v2H8v-2zm0 5h12v2H8v-2zm0 5h16v2H8v-2z" fill="white"/>
                </svg>
                LanceQL
                <span class="version" id="version"></span>
            </a>
            <a href="https://github.com/teamchong/lanceql" class="github-link" target="_blank">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0C5.37 0 0 5.37 0 12c0 5.3 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 21.795 24 17.295 24 12c0-6.63-5.37-12-12-12"/>
                </svg>
                GitHub
            </a>
        </header>

        <!-- File Loader -->
        <section class="file-section">
            <div id="file-loader-section">
                <div class="drop-zone" id="drop-zone">
                    <p>Drop a .lance folder here or click to select</p>
                    <p style="font-size: 12px;">Select the dataset_name.lance folder</p>
                    <input type="file" id="file-input" webkitdirectory directory>
                </div>
                <div class="divider">or load from URL</div>
                <div class="url-input-group">
                    <input type="text" id="url-input" placeholder="Enter Lance file URL (requires CORS headers)">
                    <button class="btn btn-primary" id="load-url-btn">Load URL</button>
                </div>
            </div>
            <div class="file-info hidden" id="file-info">
                <div class="file-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14,2 14,8 20,8"/>
                    </svg>
                </div>
                <div class="file-details">
                    <h3 id="file-name">filename.lance</h3>
                    <p id="file-size">0 KB</p>
                </div>
                <div class="file-stats">
                    <div class="stat">
                        <div class="stat-value" id="col-count">0</div>
                        <div class="stat-label">Columns</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="row-count">0</div>
                        <div class="stat-label">Rows</div>
                    </div>
                </div>
                <button class="btn-change-file" onclick="toggleFileLoader()" title="Load a different file">
                    Change File
                </button>
            </div>
            <div class="column-chips" id="column-chips"></div>
            <div class="network-stats hidden" id="network-stats">
                <div class="network-stat">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    <span>Downloaded: <strong id="bytes-downloaded">0 KB</strong></span>
                </div>
                <div class="network-stat">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12 6 12 12 16 14"/>
                    </svg>
                    <span>Requests: <strong id="request-count">0</strong></span>
                </div>
            </div>
            <div class="progress-container" id="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div class="progress-text">
                    <span id="progress-label">Loading...</span>
                    <span id="progress-percent">0%</span>
                </div>
            </div>
        </section>

        <!-- Query Interface -->
        <section class="tabs-container" id="query-section" style="display: none;">
            <div class="tabs-header">
                <button class="tab-btn active" data-tab="sql">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="16,18 22,12 16,6"/>
                        <polyline points="8,6 2,12 8,18"/>
                    </svg>
                    SQL Query
                </button>
                <button class="tab-btn" data-tab="dataframe">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7"/>
                        <rect x="14" y="3" width="7" height="7"/>
                        <rect x="14" y="14" width="7" height="7"/>
                        <rect x="3" y="14" width="7" height="7"/>
                    </svg>
                    DataFrame Builder
                </button>
                <button class="tab-btn" data-tab="vector">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                    </svg>
                    Vector Search
                </button>
            </div>

            <!-- SQL Tab -->
            <div class="tab-content active" id="tab-sql">
                <div class="sql-editor">
                    <div class="sql-editor-container">
                        <textarea class="sql-textarea" id="sql-input" placeholder="SELECT * FROM read_lance('https://...') LIMIT 50">SELECT * FROM read_lance('https://data.metal0.dev/laion-1m/images.lance') LIMIT 50</textarea>
                        <div class="sql-highlight" id="sql-highlight" aria-hidden="true"></div>
                    </div>
                    <div class="sql-examples">
                        <button class="sql-example" data-sql="SELECT * FROM read_lance('https://data.metal0.dev/laion-1m/images.lance') LIMIT 50">First 50</button>
                        <button class="sql-example" data-sql="SELECT * FROM read_lance('https://data.metal0.dev/laion-1m/images.lance') WHERE aesthetic > 0.5 LIMIT 50">aesthetic > 0.5</button>
                        <button class="sql-example" data-sql="SELECT COUNT(*) FROM read_lance('https://data.metal0.dev/laion-1m/images.lance')">COUNT(*)</button>
                        <button class="sql-example" data-sql="SELECT AVG(aesthetic), MIN(aesthetic), MAX(aesthetic) FROM read_lance('https://data.metal0.dev/laion-1m/images.lance') LIMIT 10000">Stats 10K</button>
                        <button class="sql-example" data-sql="SELECT * FROM read_lance('https://data.metal0.dev/laion-1m/images.lance') NEAR 'cat'">NEAR 'cat'</button>
                        <button class="sql-example" data-sql="SELECT * FROM read_lance('https://data.metal0.dev/laion-1m/images.lance', 1) LIMIT 50">Version 1</button>
                        <button class="sql-example copy-link-btn" id="copy-link-btn" title="Copy shareable link">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                            </svg>
                            Share
                        </button>
                    </div>
                    <div class="dataset-hint" id="dataset-hint" style="display: none;"></div>
                </div>
                <div class="run-section">
                    <button class="btn btn-primary" id="run-sql-btn" disabled>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <polygon points="5,3 19,12 5,21"/>
                        </svg>
                        Run Query
                    </button>
                </div>
            </div>

            <!-- DataFrame Tab -->
            <div class="tab-content" id="tab-dataframe">
                <div class="df-builder">
                    <div class="df-step">
                        <div class="df-step-num">1</div>
                        <div class="df-step-label">Search</div>
                        <input type="text" id="df-search-query" placeholder="e.g. cat, sunset beach" style="width: 150px;">
                        <select id="df-search-encoder" style="width: 200px;">
                            <option value="minilm">TEXT: MiniLM (87MB)</option>
                            <option value="clip-openai">IMAGE: CLIP OpenAI (122MB)</option>
                            <option value="clip-laion">IMAGE: CLIP LAION (290MB)</option>
                        </select>
                    </div>
                    <div class="df-step">
                        <div class="df-step-num">2</div>
                        <div class="df-step-label">Filter</div>
                        <select id="df-filter-col">
                            <option value="">No filter</option>
                        </select>
                        <select id="df-filter-op">
                            <option value=">">&gt;</option>
                            <option value=">=">&gt;=</option>
                            <option value="<">&lt;</option>
                            <option value="<=">&lt;=</option>
                            <option value="=">=</option>
                            <option value="!=">!=</option>
                        </select>
                        <input type="number" id="df-filter-value" value="0" placeholder="Value">
                    </div>
                    <div class="df-step">
                        <div class="df-step-num">3</div>
                        <div class="df-step-label">Select</div>
                        <select id="df-select-cols" multiple size="2" style="min-width: 200px;">
                        </select>
                        <span style="color: #64748b; font-size: 12px;">Cmd/Ctrl+click for multiple</span>
                    </div>
                    <div class="df-step">
                        <div class="df-step-num">4</div>
                        <div class="df-step-label">Limit</div>
                        <input type="number" id="df-limit" value="50" min="1" max="10000">
                        <span style="color: #64748b; font-size: 12px;">rows</span>
                    </div>
                    <div class="df-editor-container">
                        <textarea class="df-textarea" id="df-input" spellcheck="false"></textarea>
                        <div class="df-highlight" id="df-highlight" aria-hidden="true"></div>
                    </div>
                </div>
                <div class="run-section">
                    <button class="btn btn-primary" id="run-df-btn" disabled>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <polygon points="5,3 19,12 5,21"/>
                        </svg>
                        Execute
                    </button>
                </div>
            </div>

            <!-- Vector Search Tab -->
            <div class="tab-content" id="tab-vector">
                <div class="vector-search">
                    <div class="vector-notice">
                        <strong>Semantic Search:</strong> Find similar images by searching with a reference image's embedding.
                        Select a row index to use as query, or the search will use a random sample.
                    </div>
                    <div class="vector-config">
                        <label>Vector Column:</label>
                        <select id="vector-col">
                            <option value="">No vector columns</option>
                        </select>
                        <label>Query Row:</label>
                        <input type="number" id="query-row" value="0" min="0" placeholder="Row idx">
                        <label>Top K:</label>
                        <input type="number" id="top-k" value="20" min="1" max="100">
                    </div>
                    <div class="search-examples">
                        <button class="search-example" data-row="0">Row 0</button>
                        <button class="search-example" data-row="100">Row 100</button>
                        <button class="search-example" data-row="1000">Row 1000</button>
                        <button class="search-example" data-row="random">Random</button>
                    </div>
                </div>
                <div class="run-section">
                    <button class="btn btn-primary" id="run-vector-btn" disabled style="background: #7c3aed;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="11" cy="11" r="8"/>
                            <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                        </svg>
                        Search by Row
                    </button>
                </div>

                <!-- Text Search Section -->
                <div class="clip-section" id="clip-section">
                    <div class="clip-header">
                        <div class="clip-title">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                            </svg>
                            <span id="clip-search-title">Text Search</span>
                            <span class="badge" id="clip-status-badge">Ready</span>
                        </div>
                        <div class="clip-model-select">
                            <label for="clip-model-select">Encoder:</label>
                            <select id="clip-model-select">
                                <option value="minilm">TEXT: MiniLM (87MB)</option>
                                <option value="clip-openai">IMAGE: CLIP OpenAI (122MB)</option>
                                <option value="clip-laion">IMAGE: CLIP LAION (290MB)</option>
                            </select>
                        </div>
                    </div>
                    <div class="clip-text-input">
                        <input type="text" id="clip-text-input" placeholder="Search for text... (e.g., 'cat', 'sunset beach')">
                    </div>
                    <div class="clip-examples">
                        <button class="clip-example" data-text="ticket">ticket</button>
                        <button class="clip-example" data-text="cat">cat</button>
                        <button class="clip-example" data-text="dog">dog</button>
                        <button class="clip-example" data-text="sunset">sunset</button>
                        <button class="clip-example" data-text="food">food</button>
                        <button class="clip-example" data-text="city">city</button>
                    </div>
                    <div class="run-section">
                        <button class="btn btn-primary btn-clip-search" id="run-clip-btn">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"/>
                                <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                            </svg>
                            Search by Text
                        </button>
                    </div>
                </div>
            </div>

            <div class="status" id="query-status"></div>
        </section>

        <!-- Results -->
        <section class="results-section" id="results-section" style="display: none;">
            <div class="results-header">
                <h3>
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                        <line x1="3" y1="9" x2="21" y2="9"/>
                        <line x1="9" y1="21" x2="9" y2="9"/>
                    </svg>
                    Results
                </h3>
                <div class="results-actions">
                    <span class="results-count" id="results-count"></span>
                    <span class="results-notice" id="results-notice" style="display: none;"></span>
                    <button class="export-btn" id="export-csv" title="Export as CSV">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7 10 12 15 17 10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                        CSV
                    </button>
                    <button class="export-btn" id="export-json" title="Export as JSON">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7 10 12 15 17 10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                        JSON
                    </button>
                </div>
            </div>
            <div class="agg-bar" id="agg-bar" style="display: none;"></div>
            <div class="results-body" id="results-body">
                <div class="empty-state">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="8" x2="12" y2="12"/>
                        <line x1="12" y1="16" x2="12.01" y2="16"/>
                    </svg>
                    <h3>No results yet</h3>
                    <p>Run a query to see results here</p>
                </div>
            </div>
        </section>
    </div>

    <script type="module">
        import LanceQL, { SQLExecutor, SQLLexer, SQLParser } from './lanceql.js';

        let lanceql;
        let currentFile = null;
        window.currentFile = null; // Expose for debugging
        let columnTypes = [];
        let rowCount = 0;
        let totalBytesDownloaded = 0;
        let totalRequests = 0;

        // Store last result for export
        let lastResult = null;

        // Infinite scroll state
        let infiniteScrollState = null;
        let isLoadingMore = false;
        const PAGE_SIZE = 50;

        // Default demo dataset URL - LAION 1M images dataset
        const DEFAULT_DATASET_URL = 'https://data.metal0.dev/laion-1m/images.lance';
        const DEFAULT_QUERY = "SELECT * FROM read_lance('https://data.metal0.dev/laion-1m/images.lance') LIMIT 50";

        // Initialize
        async function init() {
            try {
                lanceql = await LanceQL.load('./lanceql.wasm');
                document.getElementById('version').textContent = `v${lanceql.getVersion()}`;
                console.log('LanceQL loaded:', lanceql.getVersion());

                // Show query section immediately - queries can load their own data via read_lance()
                document.getElementById('query-section').style.display = 'block';
                document.getElementById('run-sql-btn').disabled = false;

                // Set default URL in input for reference
                document.getElementById('url-input').value = DEFAULT_DATASET_URL;

                // Check URL hash for shared query
                const hashParams = new URLSearchParams(window.location.hash.slice(1));
                const sharedSql = hashParams.get('sql');

                if (sharedSql) {
                    // Use shared query from URL (URLSearchParams already decodes)
                    document.getElementById('sql-input').value = sharedSql;
                    showStatus('Loaded shared query from URL', 'info');
                } else {
                    // Use default query
                    document.getElementById('sql-input').value = DEFAULT_QUERY;
                }
                updateSQLHighlight();
                setTimeout(runSqlQuery, 100);
            } catch (err) {
                showStatus('Failed to load WASM: ' + err.message, 'error');
                console.error(err);
            }
        }

        // Toggle file loader visibility (make global for onclick)
        window.toggleFileLoader = function() {
            const loader = document.getElementById('file-loader-section');
            loader.classList.toggle('collapsed');
            console.log('Toggled file loader, collapsed:', loader.classList.contains('collapsed'));
        };

        // Collapse file loader when file is loaded
        function collapseFileLoader() {
            document.getElementById('file-loader-section').classList.add('collapsed');
        }

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
            });
        });

        // SQL syntax highlighting
        function highlightSQL(sql) {
            const keywords = /\b(SELECT|FROM|WHERE|AND|OR|NOT|ORDER|BY|ASC|DESC|LIMIT|OFFSET|AS|NULL|IS|IN|BETWEEN|LIKE|TRUE|FALSE|GROUP|HAVING|DISTINCT|JOIN|LEFT|RIGHT|INNER|OUTER|ON|UNION|ALL|INSERT|UPDATE|DELETE|CREATE|DROP|TABLE|INDEX|VIEW|SEARCH|USING)\b/gi;
            const functions = /\b(read_lance|COUNT|SUM|AVG|MIN|MAX|COALESCE|CAST|UPPER|LOWER|LENGTH|SUBSTRING|CONCAT|ABS|ROUND|FLOOR|CEIL|minilm|clip|clip-openai|clip-laion)\b/gi;
            const strings = /('(?:[^'\\]|\\.)*')/g;
            const numbers = /\b(\d+\.?\d*)\b/g;
            const operators = /([=<>!]+|[+\-*\/])/g;
            const comments = /(--.*$|\/\*[\s\S]*?\*\/)/gm;

            // Escape HTML first
            let html = sql.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // Apply highlighting (order matters - strings first to avoid matching keywords inside strings)
            html = html.replace(comments, '<span class="sql-comment">$1</span>');
            html = html.replace(strings, '<span class="sql-string">$1</span>');
            html = html.replace(functions, '<span class="sql-function">$1</span>');
            html = html.replace(keywords, '<span class="sql-keyword">$1</span>');
            html = html.replace(numbers, '<span class="sql-number">$1</span>');

            return html;
        }

        function updateSQLHighlight() {
            const textarea = document.getElementById('sql-input');
            const highlight = document.getElementById('sql-highlight');
            highlight.innerHTML = highlightSQL(textarea.value) + '\n'; // Extra newline for proper height
        }

        // Set up SQL editor with syntax highlighting
        const sqlInput = document.getElementById('sql-input');
        const sqlHighlight = document.getElementById('sql-highlight');

        sqlInput.addEventListener('input', () => {
            updateSQLHighlight();
            // Sync SQL changes to other tabs
            const sql = sqlInput.value.trim();
            if (sql) {
                const query = sqlToQuery(sql);
                syncQueryTabs(query, 'sql');
            }
        });
        sqlInput.addEventListener('scroll', () => {
            sqlHighlight.scrollTop = sqlInput.scrollTop;
            sqlHighlight.scrollLeft = sqlInput.scrollLeft;
        });

        // Initial highlight
        updateSQLHighlight();

        // SQL examples (skip share button which has no data-sql)
        document.querySelectorAll('.sql-example').forEach(btn => {
            if (!btn.dataset.sql) return; // Skip buttons without data-sql (like share button)
            btn.addEventListener('click', () => {
                document.getElementById('sql-input').value = btn.dataset.sql;
                updateSQLHighlight();
            });
        });

        // File handling
        function handleFile(file) {
            showStatus('Loading ' + file.name + '...', 'info');

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    processLanceFile(e.target.result, file.name);
                } catch (err) {
                    showStatus('Error: ' + err.message, 'error');
                    console.error(err);
                }
            };
            reader.onerror = () => showStatus('Failed to read file', 'error');
            reader.readAsArrayBuffer(file);
        }

        // Handle multiple files from directory selection
        async function handleLanceFiles(files) {
            showStatus('Processing lance folder...', 'info');

            // Find the data file (in data/ subfolder, ends with .lance)
            const dataFile = files.find(f => f.webkitRelativePath.includes('/data/') && f.name.endsWith('.lance'));
            // Find manifest file (in _versions/ subfolder)
            const manifestFile = files.find(f => f.webkitRelativePath.includes('/_versions/') && f.name.endsWith('.manifest'));

            if (!dataFile) {
                showStatus('No .lance data file found in data/ folder', 'error');
                return;
            }

            // Get folder name from path
            const pathParts = dataFile.webkitRelativePath.split('/');
            const folderName = pathParts[0] || 'dataset';

            // Read the data file
            const dataBuffer = await dataFile.arrayBuffer();

            // Read manifest if available (for column names)
            let columnNames = null;
            if (manifestFile) {
                try {
                    const manifestBuffer = await manifestFile.arrayBuffer();
                    columnNames = parseManifestForColumnNames(new Uint8Array(manifestBuffer));
                    console.log('Parsed column names from manifest:', columnNames);
                } catch (e) {
                    console.warn('Failed to parse manifest:', e);
                }
            }

            processLanceFile(dataBuffer, folderName, columnNames);
        }

        // Handle folder drop via webkitGetAsEntry
        async function handleLanceFolder(entry) {
            showStatus('Processing lance folder...', 'info');

            const files = await readDirectoryRecursive(entry);

            // Find the data file and manifest
            const dataFile = files.find(f => f.path.includes('/data/') && f.name.endsWith('.lance'));
            const manifestFile = files.find(f => f.path.includes('/_versions/') && f.name.endsWith('.manifest'));

            if (!dataFile) {
                showStatus('No .lance data file found in data/ folder', 'error');
                return;
            }

            const dataBuffer = await readFileAsArrayBuffer(dataFile.file);

            let columnNames = null;
            if (manifestFile) {
                try {
                    const manifestBuffer = await readFileAsArrayBuffer(manifestFile.file);
                    columnNames = parseManifestForColumnNames(new Uint8Array(manifestBuffer));
                    console.log('Parsed column names from manifest:', columnNames);
                } catch (e) {
                    console.warn('Failed to parse manifest:', e);
                }
            }

            processLanceFile(dataBuffer, entry.name, columnNames);
        }

        // Recursively read directory entries
        async function readDirectoryRecursive(dirEntry, path = '') {
            const files = [];
            const reader = dirEntry.createReader();

            const readEntries = () => new Promise((resolve, reject) => {
                reader.readEntries(resolve, reject);
            });

            let entries;
            do {
                entries = await readEntries();
                for (const entry of entries) {
                    const entryPath = path + '/' + entry.name;
                    if (entry.isFile) {
                        const file = await new Promise(resolve => entry.file(resolve));
                        files.push({ file, path: entryPath, name: entry.name });
                    } else if (entry.isDirectory) {
                        const subFiles = await readDirectoryRecursive(entry, entryPath);
                        files.push(...subFiles);
                    }
                }
            } while (entries.length > 0);

            return files;
        }

        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        // Parse manifest protobuf to extract column names
        // Manifest file format: 4-byte length prefix + protobuf Manifest message + footer
        // Manifest protobuf has: fields (repeated Field, field 1)
        // Field has: name (string, field 2), id (int32, field 3), logical_type (string, field 5)
        function parseManifestForColumnNames(data) {
            const names = [];
            // Read 4-byte length prefix (little-endian)
            const protoLen = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);
            const protoEnd = 4 + protoLen;
            let pos = 4;

            function readVarint() {
                let result = 0;
                let shift = 0;
                while (pos < data.length) {
                    const byte = data[pos++];
                    result |= (byte & 0x7f) << shift;
                    if ((byte & 0x80) === 0) break;
                    shift += 7;
                }
                return result;
            }

            function readString(len) {
                const str = new TextDecoder().decode(data.slice(pos, pos + len));
                pos += len;
                return str;
            }

            function skipField(wireType) {
                if (wireType === 0) readVarint();
                else if (wireType === 1) pos += 8;
                else if (wireType === 2) pos += readVarint();
                else if (wireType === 5) pos += 4;
            }

            // Parse top-level Manifest message (within protoLen bounds)
            while (pos < protoEnd) {
                const tag = readVarint();
                const fieldNum = tag >> 3;
                const wireType = tag & 0x7;

                if (fieldNum === 1 && wireType === 2) {
                    // fields (repeated Field)
                    const fieldLen = readVarint();
                    const fieldEnd = pos + fieldLen;

                    // Parse Field message
                    let fieldName = null;
                    while (pos < fieldEnd) {
                        const fieldTag = readVarint();
                        const fieldFieldNum = fieldTag >> 3;
                        const fieldWireType = fieldTag & 0x7;

                        if (fieldFieldNum === 2 && fieldWireType === 2) {
                            // name (string)
                            const nameLen = readVarint();
                            fieldName = readString(nameLen);
                        } else {
                            skipField(fieldWireType);
                        }
                    }

                    if (fieldName) {
                        names.push(fieldName);
                    }
                } else {
                    skipField(wireType);
                }
            }

            return names.length > 0 ? names : null;
        }

        function processLanceFile(data, filename, columnNames = null) {
            if (!lanceql.isValid(data)) {
                showStatus('Invalid Lance file - missing LANC magic bytes', 'error');
                return;
            }

            // Clear URL input when loading a local file
            document.getElementById('url-input').value = '';

            if (currentFile) currentFile.close();
            currentFile = lanceql.open(data);
            currentFile.columnNames = columnNames; // Store column names from manifest
            window.currentFile = currentFile;
            columnTypes = [];

            // Get row count from first column
            const debug = currentFile.getColumnDebugInfo(0);
            rowCount = Number(debug.rows);

            // Detect column types
            // Check vector FIRST since vectors can also be read as numeric arrays
            console.log('Detecting column types for', currentFile.numColumns, 'columns');
            for (let i = 0; i < currentFile.numColumns; i++) {
                let type = 'unknown';
                // Check vector first - dimension > 2 indicates a real vector column
                try {
                    const info = currentFile.getVectorInfo(i);
                    console.log('Column', i, 'vector info:', info);
                    if (info && info.dimension > 2) {
                        type = 'vector';
                    }
                } catch (e) { console.log('Column', i, 'not vector:', e.message); }
                if (type === 'unknown') {
                    try {
                        const strCount = currentFile.getStringCount(i);
                        if (strCount > 0) type = 'string';
                    } catch (e) { console.log('Column', i, 'not string:', e.message); }
                }
                if (type === 'unknown') {
                    try {
                        const int64Data = currentFile.readInt64Column(i);
                        if (int64Data.length > 0) type = 'int64';
                    } catch (e) { console.log('Column', i, 'not int64:', e.message); }
                }
                if (type === 'unknown') {
                    try {
                        const float64Data = currentFile.readFloat64Column(i);
                        if (float64Data.length > 0) type = 'float64';
                    } catch (e) { console.log('Column', i, 'not float64:', e.message); }
                }
                console.log('Column', i, 'detected as:', type);
                columnTypes[i] = type;
            }

            // Update UI
            document.getElementById('file-info').classList.remove('hidden');
            collapseFileLoader();
            document.getElementById('file-name').textContent = filename;
            document.getElementById('file-size').textContent = (data.byteLength / 1024).toFixed(2) + ' KB';
            document.getElementById('col-count').textContent = currentFile.numColumns;
            document.getElementById('row-count').textContent = rowCount.toLocaleString();

            // Show query section
            document.getElementById('query-section').style.display = 'block';
            document.getElementById('run-sql-btn').disabled = false;
            document.getElementById('run-df-btn').disabled = false;

            // Populate DataFrame builder selects
            const filterCol = document.getElementById('df-filter-col');
            const selectCols = document.getElementById('df-select-cols');
            filterCol.innerHTML = '<option value="">No filter</option>';
            selectCols.innerHTML = '';

            const colNames = currentFile.columnNames || [];
            for (let i = 0; i < currentFile.numColumns; i++) {
                const name = colNames[i] || `column_${i}`;
                const type = columnTypes[i];
                // Only show numeric columns in filter dropdown (not strings or vectors)
                if (type !== 'string' && type !== 'vector') {
                    filterCol.innerHTML += `<option value="${i}">${name} (${type})</option>`;
                }
                selectCols.innerHTML += `<option value="${i}" selected>${name}</option>`;
            }

            // Populate vector column dropdown for local files
            const vectorCol = document.getElementById('vector-col');
            vectorCol.innerHTML = '';
            for (let i = 0; i < currentFile.numColumns; i++) {
                if (columnTypes[i] === 'vector') {
                    try {
                        const info = currentFile.getVectorInfo(i);
                        const name = (currentFile.columnNames && currentFile.columnNames[i]) || `column_${i}`;
                        vectorCol.innerHTML += `<option value="${i}">${name} (${info.dimension}D vectors, ${info.rows} rows)</option>`;
                    } catch (e) {}
                }
            }
            // If no vector columns found, show placeholder
            if (vectorCol.options.length === 0) {
                vectorCol.innerHTML = '<option value="">No vector columns</option>';
            }

            // Show results section
            document.getElementById('results-section').style.display = 'block';

            showStatus('Loaded successfully - ' + currentFile.numColumns + ' columns, ' + rowCount.toLocaleString() + ' rows', 'success');
            // Update DataFrame preview but don't sync to SQL (preserve user's SQL)
            updateDfPreview(true);

            // Show column chips
            showColumnChips();

            // Show initial aggregations
            showAggregations();

            // Auto-select first vector column if available
            if (vectorCol.options.length > 1) {
                vectorCol.selectedIndex = 1;
            }

            // Run initial query to show sample data
            runDfQuery();
        }

        function showAggregations() {
            if (!currentFile) return;

            const aggBar = document.getElementById('agg-bar');
            aggBar.innerHTML = '';
            aggBar.style.display = 'flex';

            // Show aggregations for numeric columns
            for (let i = 0; i < Math.min(currentFile.numColumns, 3); i++) {
                const type = columnTypes[i];
                if (type === 'int64') {
                    const sum = currentFile.sumInt64(i);
                    const min = currentFile.minInt64(i);
                    const max = currentFile.maxInt64(i);

                    aggBar.innerHTML += `
                        <div class="agg-item">
                            <div class="agg-value">${rowCount.toLocaleString()}</div>
                            <div class="agg-label">COUNT</div>
                        </div>
                        <div class="agg-item">
                            <div class="agg-value">${formatNumber(sum)}</div>
                            <div class="agg-label">SUM(col_${i})</div>
                        </div>
                        <div class="agg-item">
                            <div class="agg-value">${formatNumber(min)}</div>
                            <div class="agg-label">MIN(col_${i})</div>
                        </div>
                        <div class="agg-item">
                            <div class="agg-value">${formatNumber(max)}</div>
                            <div class="agg-label">MAX(col_${i})</div>
                        </div>
                    `;
                    break; // Just show for first numeric column
                } else if (type === 'float64') {
                    const avg = currentFile.avgFloat64(i);

                    aggBar.innerHTML += `
                        <div class="agg-item">
                            <div class="agg-value">${rowCount.toLocaleString()}</div>
                            <div class="agg-label">COUNT</div>
                        </div>
                        <div class="agg-item">
                            <div class="agg-value">${avg.toFixed(4)}</div>
                            <div class="agg-label">AVG(col_${i})</div>
                        </div>
                    `;
                    break;
                }
            }
        }

        function formatNumber(n, decimals = null) {
            if (n === null || n === undefined) return 'N/A';
            // Convert BigInt to Number if needed
            const num = typeof n === 'bigint' ? Number(n) : n;
            if (decimals !== null) return num.toFixed(decimals);
            if (Math.abs(num) >= 1e9) return (num / 1e9).toFixed(1) + 'B';
            if (Math.abs(num) >= 1e6) return (num / 1e6).toFixed(1) + 'M';
            if (Math.abs(num) >= 1e3) return (num / 1e3).toFixed(1) + 'K';
            if (!Number.isInteger(num)) return num.toFixed(4);
            return num.toLocaleString();
        }

        function formatBytes(bytes) {
            if (bytes >= 1024 * 1024) return (bytes / 1024 / 1024).toFixed(2) + ' MB';
            if (bytes >= 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return bytes + ' B';
        }

        // Progress bar functions
        function showProgress(label, current, total) {
            const container = document.getElementById('progress-container');
            const fill = document.getElementById('progress-fill');
            const labelEl = document.getElementById('progress-label');
            const percentEl = document.getElementById('progress-percent');

            container.classList.add('show');
            const percent = Math.round((current / total) * 100);
            fill.style.width = percent + '%';
            labelEl.textContent = label;
            percentEl.textContent = percent + '%';
        }

        function hideProgress() {
            document.getElementById('progress-container').classList.remove('show');
        }

        // Network stats functions
        function updateNetworkStats(bytes, requests) {
            totalBytesDownloaded += bytes;
            totalRequests += requests;

            const statsEl = document.getElementById('network-stats');
            statsEl.classList.remove('hidden');
            document.getElementById('bytes-downloaded').textContent = formatBytes(totalBytesDownloaded);
            document.getElementById('request-count').textContent = totalRequests;
        }

        function resetNetworkStats() {
            totalBytesDownloaded = 0;
            totalRequests = 0;
            document.getElementById('bytes-downloaded').textContent = '0 KB';
            document.getElementById('request-count').textContent = '0';
        }

        // Column chips display
        function showColumnChips() {
            const container = document.getElementById('column-chips');
            container.innerHTML = '';

            // Get column names from schema if available
            const names = currentFile?.columnNames || [];

            for (let i = 0; i < columnTypes.length; i++) {
                const type = columnTypes[i] || 'unknown';
                const name = names[i] || `column_${i}`;
                const chip = document.createElement('div');
                chip.className = 'column-chip';
                chip.dataset.colIdx = i;
                chip.innerHTML = `${name}<span class="type ${type}">${type}</span>`;
                chip.addEventListener('click', (e) => showColumnStats(i, name, type, e));
                container.appendChild(chip);
            }
        }

        // Show column statistics popup
        async function showColumnStats(colIdx, colName, colType, event) {
            // Remove any existing popup
            document.querySelectorAll('.column-stats-popup').forEach(p => p.remove());

            const chip = event.currentTarget;
            chip.classList.add('loading');

            try {
                // Calculate stats based on column type
                let stats = { type: colType };

                if (!currentFile?._isRemote) {
                    stats.error = 'Stats only available for remote datasets';
                } else if (colType === 'vector') {
                    // For vectors, show dimension info
                    const info = await currentFile.getVectorInfo(colIdx);
                    stats.dimension = info.dimension;
                    stats.rows = info.rows;
                } else if (colType === 'string') {
                    // Sample first 100 strings for stats
                    const sample = await currentFile.readStringsAtIndices(colIdx, Array.from({length: Math.min(100, currentFile.rowCount || 100)}, (_, i) => i));
                    const lengths = sample.filter(s => s).map(s => s.length);
                    stats.sampleSize = sample.length;
                    stats.nullCount = sample.filter(s => !s).length;
                    stats.avgLength = lengths.length > 0 ? Math.round(lengths.reduce((a, b) => a + b, 0) / lengths.length) : 0;
                    stats.maxLength = lengths.length > 0 ? Math.max(...lengths) : 0;
                } else if (colType.includes('int') || colType.includes('float') || colType === 'double') {
                    // Sample first 100 values for numeric stats
                    let values;
                    if (colType.includes('int')) {
                        values = await currentFile.readInt64AtIndices(colIdx, Array.from({length: Math.min(100, currentFile.rowCount || 100)}, (_, i) => i));
                        values = Array.from(values).map(v => Number(v));
                    } else {
                        values = await currentFile.readFloat64AtIndices(colIdx, Array.from({length: Math.min(100, currentFile.rowCount || 100)}, (_, i) => i));
                        values = Array.from(values);
                    }
                    const validValues = values.filter(v => v !== null && !isNaN(v));
                    stats.sampleSize = values.length;
                    stats.nullCount = values.length - validValues.length;
                    if (validValues.length > 0) {
                        stats.min = Math.min(...validValues);
                        stats.max = Math.max(...validValues);
                        stats.avg = validValues.reduce((a, b) => a + b, 0) / validValues.length;
                    }
                }

                // Create popup
                const popup = document.createElement('div');
                popup.className = 'column-stats-popup';

                let html = `<button class="close-btn">&times;</button><h4>${colName}</h4>`;

                if (stats.error) {
                    html += `<div class="stat-row"><span class="value">${stats.error}</span></div>`;
                } else if (colType === 'vector') {
                    html += `<div class="stat-row"><span class="label">Dimension:</span><span class="value">${stats.dimension}</span></div>`;
                    html += `<div class="stat-row"><span class="label">Rows:</span><span class="value">${stats.rows?.toLocaleString()}</span></div>`;
                } else if (colType === 'string') {
                    html += `<div class="stat-row"><span class="label">Sample size:</span><span class="value">${stats.sampleSize}</span></div>`;
                    html += `<div class="stat-row"><span class="label">Null count:</span><span class="value">${stats.nullCount}</span></div>`;
                    html += `<div class="stat-row"><span class="label">Avg length:</span><span class="value">${stats.avgLength}</span></div>`;
                    html += `<div class="stat-row"><span class="label">Max length:</span><span class="value">${stats.maxLength}</span></div>`;
                } else {
                    html += `<div class="stat-row"><span class="label">Sample size:</span><span class="value">${stats.sampleSize}</span></div>`;
                    html += `<div class="stat-row"><span class="label">Null count:</span><span class="value">${stats.nullCount}</span></div>`;
                    if (stats.min !== undefined) {
                        html += `<div class="stat-row"><span class="label">Min:</span><span class="value">${formatNumber(stats.min)}</span></div>`;
                        html += `<div class="stat-row"><span class="label">Max:</span><span class="value">${formatNumber(stats.max)}</span></div>`;
                        html += `<div class="stat-row"><span class="label">Avg:</span><span class="value">${formatNumber(stats.avg)}</span></div>`;
                    }
                }

                popup.innerHTML = html;

                // Position popup near the chip
                const rect = chip.getBoundingClientRect();
                popup.style.top = (rect.bottom + 8) + 'px';
                popup.style.left = rect.left + 'px';

                document.body.appendChild(popup);

                // Close button handler
                popup.querySelector('.close-btn').addEventListener('click', () => popup.remove());

                // Close on click outside
                setTimeout(() => {
                    document.addEventListener('click', function closePopup(e) {
                        if (!popup.contains(e.target) && !chip.contains(e.target)) {
                            popup.remove();
                            document.removeEventListener('click', closePopup);
                        }
                    });
                }, 100);

            } catch (e) {
                console.error('Failed to get column stats:', e);
                showStatus(`Failed to get stats: ${e.message}`, 'error');
            } finally {
                chip.classList.remove('loading');
            }
        }

        // Generate plain Python code from UI inputs
        function generateDfCode() {
            const searchQuery = document.getElementById('df-search-query').value.trim();
            const searchEncoder = document.getElementById('df-search-encoder').value;
            const filterCol = document.getElementById('df-filter-col').value;
            const filterOp = document.getElementById('df-filter-op').value;
            const filterVal = document.getElementById('df-filter-value').value;
            const selectedCols = Array.from(document.getElementById('df-select-cols').selectedOptions).map(o => o.value);
            const limit = document.getElementById('df-limit').value;

            let code = `import lanceql\n\n`;

            if (currentFile?._isRemote && currentFile?._url) {
                const url = currentFile._url;
                const versionArg = currentFile.version ? `, version=${currentFile.version}` : '';
                code += `# Open remote dataset\n`;
                code += `dataset = lanceql.open("${url}"${versionArg})\n\n`;
            } else if (currentFile) {
                code += `# Open local file\n`;
                code += `dataset = lanceql.open("file.lance")\n\n`;
            } else {
                code += `# Load a file first\n`;
            }

            code += `# Query data\n`;
            code += `result = (\n`;
            code += `    dataset.df()\n`;

            if (searchQuery) {
                code += `    .search("${searchQuery}", encoder="${searchEncoder}", top_k=20)\n`;
            }

            if (filterCol !== '') {
                const colName = currentFile?.columnNames?.[parseInt(filterCol)] || `col_${filterCol}`;
                code += `    .filter("${colName}", "${filterOp}", ${filterVal})\n`;
            }

            if (selectedCols.length > 0 && selectedCols.length < currentFile?.numColumns) {
                const colNames = selectedCols.map(c => {
                    const name = currentFile?.columnNames?.[parseInt(c)] || `col_${c}`;
                    return `"${name}"`;
                }).join(', ');
                code += `    .select([${colNames}])\n`;
            }

            if (limit) {
                code += `    .limit(${limit})\n`;
            }
            code += `    .collect()\n`;
            code += `)`;

            return code;
        }

        /**
         * Sync all query tabs (SQL, DataFrame, Vector Search) and URL hash.
         * @param {Object} query - Normalized query object
         * @param {string} query.url - Dataset URL
         * @param {number} query.version - Version number (optional)
         * @param {string} query.search - Search query text (optional)
         * @param {string} query.encoder - Encoder name (optional, default 'minilm')
         * @param {Object} query.filter - Filter {column, op, value} (optional)
         * @param {string[]} query.select - Column names to select (optional)
         * @param {number} query.limit - Row limit (optional)
         * @param {string} source - Which tab initiated the sync ('sql', 'df', 'vector')
         */
        function syncQueryTabs(query, source) {
            const url = query.url || currentFile?._url || '';
            // Only include version if explicitly set in query, not from currentFile
            const version = query.version || null;

            // Generate SQL
            // read_lance() = current file, read_lance(24) = version 24, read_lance('url') = remote, read_lance('url', 24) = remote with version
            let sql = 'SELECT ';
            if (query.select && query.select.length > 0) {
                sql += query.select.join(', ');
            } else {
                sql += '*';
            }
            // Build read_lance args
            // read_lance(FILE) for local files, read_lance('url') for remote
            const isLocalFile = !url && !currentFile?._isRemote;
            if (isLocalFile && version) {
                sql += ` FROM read_lance(FILE, ${version})`;
            } else if (isLocalFile) {
                sql += ` FROM read_lance(FILE)`;
            } else if (url && version) {
                sql += ` FROM read_lance('${url}', ${version})`;
            } else if (url) {
                sql += ` FROM read_lance('${url}')`;
            } else {
                // Fallback: use current file URL if available
                const fallbackUrl = currentFile?._url || '';
                if (fallbackUrl && version) {
                    sql += ` FROM read_lance('${fallbackUrl}', ${version})`;
                } else if (fallbackUrl) {
                    sql += ` FROM read_lance('${fallbackUrl}')`;
                } else {
                    sql += ` FROM read_lance(FILE)`;
                }
            }
            // WHERE clause
            if (query.filter) {
                sql += ` WHERE ${query.filter.column} ${query.filter.op} ${query.filter.value}`;
            }
            // NEAR clause (after WHERE, like ORDER BY position)
            // NEAR [column] <'text'|row_num> [TOPK n]
            if (query.searchRow !== undefined && query.searchRow !== null) {
                sql += ' NEAR';
                if (query.vectorColumn) {
                    sql += ` ${query.vectorColumn}`;
                }
                sql += ` ${query.searchRow}`;
                if (query.topK && query.topK !== 20) {
                    sql += ` TOPK ${query.topK}`;
                }
            } else if (query.search) {
                sql += ' NEAR';
                if (query.vectorColumn) {
                    sql += ` ${query.vectorColumn}`;
                }
                sql += ` '${query.search}'`;
                if (query.topK && query.topK !== 20) {
                    sql += ` TOPK ${query.topK}`;
                }
            }
            if (query.limit) {
                sql += ` LIMIT ${query.limit}`;
            }

            // Generate DataFrame code
            let dfCode = `import lanceql\n\n`;
            const versionArg = version ? `, version=${version}` : '';
            dfCode += `dataset = lanceql.open("${url}"${versionArg})\n\n`;
            dfCode += `result = (\n`;
            dfCode += `    dataset.df()\n`;
            if (query.searchRow !== undefined && query.searchRow !== null) {
                const topK = query.topK || 20;
                const colArg = query.vectorColumn ? `, column="${query.vectorColumn}"` : '';
                dfCode += `    .search_by_row(${query.searchRow}${colArg}, top_k=${topK})\n`;
            } else if (query.search) {
                const encoder = query.encoder || 'minilm';
                const topK = query.topK || 20;
                const colArg = query.vectorColumn ? `, column="${query.vectorColumn}"` : '';
                dfCode += `    .search("${query.search}", encoder="${encoder}"${colArg}, top_k=${topK})\n`;
            }
            if (query.filter) {
                dfCode += `    .filter("${query.filter.column}", "${query.filter.op}", ${query.filter.value})\n`;
            }
            if (query.select && query.select.length > 0) {
                dfCode += `    .select([${query.select.map(c => `"${c}"`).join(', ')}])\n`;
            }
            if (query.limit) {
                dfCode += `    .limit(${query.limit})\n`;
            }
            dfCode += `    .collect()\n`;
            dfCode += `)`;

            // Update SQL tab (if not source)
            if (source !== 'sql') {
                document.getElementById('sql-input').value = sql;
                updateSQLHighlight();
            }

            // Update DataFrame tab (if not source)
            if (source !== 'df') {
                document.getElementById('df-input').value = dfCode;
                document.getElementById('df-input').dataset.userEdited = 'false';
                document.getElementById('df-highlight').innerHTML = highlightDfCode(dfCode) + '\n';
                // Also update DataFrame builder fields
                document.getElementById('df-search-query').value = query.search || '';
                if (query.encoder) {
                    document.getElementById('df-search-encoder').value = query.encoder;
                }
                if (query.limit) {
                    document.getElementById('df-limit').value = query.limit;
                }
            }

            // Update Vector Search tab (if not source)
            if (source !== 'vector') {
                document.getElementById('clip-text-input').value = query.search || '';
                if (query.encoder) {
                    document.getElementById('clip-model-select').value = query.encoder;
                }
                if (query.topK) {
                    document.getElementById('top-k').value = query.topK;
                }
                // Clear query-row if no searchRow (don't persist row search when cleared)
                if (query.searchRow !== undefined && query.searchRow !== null) {
                    document.getElementById('query-row').value = query.searchRow;
                } else {
                    document.getElementById('query-row').value = '';
                }
                // Update vector column dropdown if specified, reset if not
                const vectorColSelect = document.getElementById('vector-col');
                if (query.vectorColumn) {
                    for (let opt of vectorColSelect.options) {
                        if (opt.text === query.vectorColumn) {
                            vectorColSelect.value = opt.value;
                            break;
                        }
                    }
                } else if (vectorColSelect.options.length > 0) {
                    vectorColSelect.selectedIndex = 0; // Auto-select first vector column
                }
            }

            // Update URL hash (only if sql is valid)
            if (sql && !sql.includes('undefined')) {
                const newHash = `sql=${encodeURIComponent(sql)}`;
                history.replaceState(null, '', `#${newHash}`);
            }
        }

        /**
         * Parse SQL to extract query components.
         * @param {string} sql - SQL query string
         * @returns {Object} Normalized query object
         */
        function sqlToQuery(sql) {
            const query = {};

            // Extract URL and version from read_lance()
            // read_lance() = current file
            // read_lance(24) = current file, version 24
            // read_lance('url') = remote, latest
            // read_lance('url', 24) = remote, version 24
            const lanceFuncMatch = sql.match(/read_lance\s*\(\s*([^)]*)\s*\)/i);
            if (lanceFuncMatch) {
                const args = lanceFuncMatch[1].trim();
                if (args === '') {
                    // read_lance() - current file
                } else if (/^\d+$/.test(args)) {
                    // read_lance(24) - version only
                    query.version = parseInt(args);
                } else {
                    // read_lance('url') or read_lance('url', 24)
                    const urlVerMatch = args.match(/['"]([^'"]+)['"]\s*(?:,\s*(\d+))?/);
                    if (urlVerMatch) {
                        query.url = urlVerMatch[1];
                        if (urlVerMatch[2]) query.version = parseInt(urlVerMatch[2]);
                    }
                }
            }

            // Extract limit from LIMIT N
            const limitMatch = sql.match(/LIMIT\s+(\d+)/i);
            if (limitMatch) query.limit = parseInt(limitMatch[1]);

            // Extract columns from SELECT (if not *)
            const selectMatch = sql.match(/SELECT\s+(.+?)\s+FROM/i);
            if (selectMatch && selectMatch[1].trim() !== '*') {
                query.select = selectMatch[1].split(',').map(c => c.trim());
            }

            // Extract WHERE clause (simplified - just column op value)
            const whereMatch = sql.match(/WHERE\s+(\w+)\s*(>|<|>=|<=|=|!=)\s*([\d.]+)/i);
            if (whereMatch) {
                query.filter = {
                    column: whereMatch[1],
                    op: whereMatch[2],
                    value: parseFloat(whereMatch[3])
                };
            }

            // Extract NEAR clause: NEAR [column] <'text'|row_num> [TOPK n]
            // NEAR 'text' or NEAR column 'text' or NEAR 0 or NEAR column 0
            const nearMatch = sql.match(/NEAR\s+(?:(\w+)\s+)?(?:'([^']+)'|(\d+))(?:\s+TOPK\s+(\d+))?/i);
            if (nearMatch) {
                if (nearMatch[1]) query.vectorColumn = nearMatch[1];
                if (nearMatch[2]) query.search = nearMatch[2];
                if (nearMatch[3]) query.searchRow = parseInt(nearMatch[3]);
                query.topK = nearMatch[4] ? parseInt(nearMatch[4]) : 20;
            }

            return query;
        }

        // Syntax highlight Python-like DataFrame code
        function highlightDfCode(code) {
            // Use a unique marker that can't appear in user input after HTML escaping
            // We escape < to &lt; first, so \x00 (null char) is safe as internal marker
            const M = '\x00'; // Marker character

            // Escape HTML entities in user code AND strip any null chars
            let html = code
                .replace(/\x00/g, '') // Remove any null chars from input
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');

            // Highlight comments
            html = html.replace(/(#.*$)/gm, `${M}C${M}$1${M}/C${M}`);

            // Highlight strings
            html = html.replace(/("(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/g, `${M}S${M}$1${M}/S${M}`);

            // Highlight methods (.word()
            html = html.replace(/\.(\w+)\(/g, `.${M}M${M}$1${M}/M${M}(`);

            // Highlight keywords
            html = html.replace(/\b(import|from|as|def|return|if|else|elif|for|while|in|not|and|or|True|False|None|result|dataset)\b/g, `${M}K${M}$1${M}/K${M}`);

            // Highlight numbers (but not inside markers)
            html = html.replace(/\b(\d+\.?\d*)\b/g, (match, num, offset) => {
                const before = html.substring(0, offset);
                const opens = (before.match(new RegExp(`${M}[CSMK]${M}`, 'g')) || []).length;
                const closes = (before.match(new RegExp(`${M}/[CSMK]${M}`, 'g')) || []).length;
                if (opens > closes) return match;
                return `${M}N${M}${num}${M}/N${M}`;
            });

            // Convert markers to HTML spans
            html = html
                .replace(new RegExp(`${M}C${M}`, 'g'), '<span class="df-comment">')
                .replace(new RegExp(`${M}/C${M}`, 'g'), '</span>')
                .replace(new RegExp(`${M}S${M}`, 'g'), '<span class="df-string">')
                .replace(new RegExp(`${M}/S${M}`, 'g'), '</span>')
                .replace(new RegExp(`${M}M${M}`, 'g'), '<span class="df-method">')
                .replace(new RegExp(`${M}/M${M}`, 'g'), '</span>')
                .replace(new RegExp(`${M}K${M}`, 'g'), '<span class="df-keyword">')
                .replace(new RegExp(`${M}/K${M}`, 'g'), '</span>')
                .replace(new RegExp(`${M}N${M}`, 'g'), '<span class="df-number">')
                .replace(new RegExp(`${M}/N${M}`, 'g'), '</span>');

            return html;
        }

        function updateDfPreview(skipSync = false) {
            const textarea = document.getElementById('df-input');
            const highlight = document.getElementById('df-highlight');

            // Always regenerate and update DataFrame code from builder fields
            const generatedCode = generateDfCode();
            textarea.value = generatedCode;
            textarea.dataset.lastGenerated = generatedCode;
            textarea.dataset.userEdited = '';

            // Always update highlighting to match current textarea content
            highlight.innerHTML = highlightDfCode(textarea.value) + '\n';

            // Skip sync if requested (e.g., on initial load to preserve SQL from URL hash)
            if (skipSync) return;

            // Sync SQL and URL hash with current DataFrame builder state
            const searchQuery = document.getElementById('df-search-query').value.trim();
            const searchEncoder = document.getElementById('df-search-encoder').value;
            const filterCol = document.getElementById('df-filter-col').value;
            const filterOp = document.getElementById('df-filter-op').value;
            const filterVal = document.getElementById('df-filter-value').value;
            const limit = document.getElementById('df-limit').value;
            const selectCols = document.getElementById('df-select-cols');
            const selectedColumnIndices = Array.from(selectCols.selectedOptions).map(opt => opt.value);
            // Convert indices to column names
            const selectedColumns = selectedColumnIndices.map(idx =>
                currentFile?.columnNames?.[parseInt(idx)] || `col_${idx}`
            );
            // Only include select if NOT all columns selected (otherwise use *)
            const allSelected = selectedColumnIndices.length >= (currentFile?.numColumns || 0);

            const query = {
                url: currentFile?._url,
                // Don't auto-include version - only if user explicitly sets it
                search: searchQuery || null,
                encoder: searchEncoder,
                limit: limit ? parseInt(limit) : null,
                select: (!allSelected && selectedColumns.length > 0) ? selectedColumns : null
            };

            // Add filter if specified
            if (filterCol !== '' && filterVal) {
                const colName = currentFile?.columnNames?.[parseInt(filterCol)] || `col_${filterCol}`;
                query.filter = { column: colName, op: filterOp, value: parseFloat(filterVal) };
            }

            syncQueryTabs(query, 'df');
        }

        // Sync textarea scroll with highlight
        function setupDfEditorSync() {
            const textarea = document.getElementById('df-input');
            const highlight = document.getElementById('df-highlight');

            textarea.addEventListener('input', () => {
                textarea.dataset.userEdited = 'true';
                highlight.innerHTML = highlightDfCode(textarea.value) + '\n';
            });

            textarea.addEventListener('scroll', () => {
                highlight.scrollTop = textarea.scrollTop;
                highlight.scrollLeft = textarea.scrollLeft;
            });
        }

        // Parse Python-like DataFrame code to extract operations
        function parseDfCode(code) {
            const ops = {
                url: null,
                version: null,
                search: null,
                searchEncoder: null,
                filter: null,
                select: null,
                limit: null
            };

            // Extract URL and optional version from lanceql.open("...", version=N)
            const urlMatch = code.match(/lanceql\.open\s*\(\s*["']([^"']+)["'](?:\s*,\s*version\s*=\s*(\d+))?\s*\)/);
            if (urlMatch) {
                ops.url = urlMatch[1];
                if (urlMatch[2]) {
                    ops.version = parseInt(urlMatch[2]);
                }
            }

            // Extract .search("query", encoder="encoder")
            const searchMatch = code.match(/\.search\s*\(\s*["']([^"']+)["'](?:\s*,\s*encoder\s*=\s*["']([^"']+)["'])?\s*\)/);
            if (searchMatch) {
                ops.search = searchMatch[1];
                ops.searchEncoder = searchMatch[2] || 'minilm';
            }

            // Extract .filter("col", "op", value)
            const filterMatch = code.match(/\.filter\s*\(\s*["']([^"']+)["']\s*,\s*["']([^"']+)["']\s*,\s*([^\)]+)\s*\)/);
            if (filterMatch) {
                ops.filter = {
                    column: filterMatch[1],
                    op: filterMatch[2],
                    value: parseFloat(filterMatch[3])
                };
            }

            // Extract .select([...])
            const selectMatch = code.match(/\.select\s*\(\s*\[([^\]]+)\]\s*\)/);
            if (selectMatch) {
                const colsStr = selectMatch[1];
                ops.select = colsStr.match(/["']([^"']+)["']/g)?.map(s => s.replace(/["']/g, '')) || [];
            }

            // Extract .limit(n)
            const limitMatch = code.match(/\.limit\s*\(\s*(\d+)\s*\)/);
            if (limitMatch) {
                ops.limit = parseInt(limitMatch[1]);
            }

            return ops;
        }

        // Set loading state for buttons
        function setLoading(isLoading) {
            const sqlBtn = document.getElementById('run-sql-btn');
            const dfBtn = document.getElementById('run-df-btn');
            const urlBtn = document.getElementById('load-url-btn');
            const clipBtn = document.getElementById('run-clip-btn');

            sqlBtn.disabled = isLoading;
            dfBtn.disabled = isLoading;
            urlBtn.disabled = isLoading;
            clipBtn.disabled = isLoading;

            if (isLoading) {
                sqlBtn.innerHTML = '<span class="spinner"></span> Loading...';
                dfBtn.innerHTML = '<span class="spinner"></span> Loading...';
                clipBtn.innerHTML = '<span class="spinner"></span> Searching...';
            } else {
                sqlBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><polygon points="5,3 19,12 5,21"/></svg> Run Query`;
                dfBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><polygon points="5,3 19,12 5,21"/></svg> Execute`;
                clipBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg> Search by Text`;
            }
        }

        // Run SQL query
        async function runSqlQuery() {
            const sql = document.getElementById('sql-input').value.trim();
            if (!sql) {
                showStatus('Please enter a SQL query', 'error');
                return;
            }

            // Sync other tabs with this SQL query
            const query = sqlToQuery(sql);
            syncQueryTabs(query, 'sql');

            try {
                setLoading(true);

                // Pre-parse SQL to check for URL in FROM clause
                const lexer = new SQLLexer(sql);
                const tokens = lexer.tokenize();
                const parser = new SQLParser(tokens);
                const ast = parser.parse();

                // If FROM clause has URL, load dataset first
                let targetFile = currentFile;
                if (ast.from && ast.from.type === 'url') {
                    const url = ast.from.url;
                    const version = ast.from.version || null;
                    const versionMsg = version ? ` (v${version})` : '';
                    showStatus(`Loading dataset from ${url}${versionMsg}...`, 'info');

                    // Load dataset (detect if it's a dataset or single file)
                    let remoteFile;
                    if (url.endsWith('.lance') && !url.includes('/data/')) {
                        remoteFile = await lanceql.openDataset(url, { version });
                    } else {
                        remoteFile = await lanceql.openUrl(url);
                    }

                    // Update UI to show the loaded file
                    if (currentFile && currentFile.close) currentFile.close();
                    currentFile = remoteFile;
                    window.currentFile = currentFile;
                    currentFile._isRemote = true;
                    currentFile._url = url;
                    currentFile._isDataset = url.endsWith('.lance') && !url.includes('/data/');

                    // Set up network stats callback
                    currentFile.onFetch((bytes, requests) => {
                        updateNetworkStats(bytes, requests);
                    });

                    columnTypes = [];
                    rowCount = currentFile._isDataset ? currentFile.rowCount : 0;

                    // Update UI
                    document.getElementById('file-info').classList.remove('hidden');
                    collapseFileLoader();
                    const displayName = url.split('/').pop() || 'remote.lance';
                    const versionSuffix = currentFile.version ? ` v${currentFile.version}` : '';
                    document.getElementById('file-name').textContent = displayName + (currentFile._isDataset ? ` (dataset${versionSuffix})` : '');
                    document.getElementById('file-size').textContent = (currentFile.size / 1024 / 1024).toFixed(2) + ' MB';
                    document.getElementById('col-count').textContent = currentFile.numColumns;
                    document.getElementById('row-count').textContent = currentFile._isDataset ? rowCount.toLocaleString() : 'Lazy';

                    // Reset network stats
                    resetNetworkStats();
                    document.getElementById('network-stats').classList.remove('hidden');

                    // Detect column types
                    try {
                        columnTypes = await currentFile.detectColumnTypes();
                        showColumnChips();
                    } catch (e) {
                        console.warn('Could not detect column types:', e);
                    }

                    // Populate vector columns for vector search tab
                    await populateVectorColumns();

                    // Show dataset hint for default dataset
                    const hintEl = document.getElementById('dataset-hint');
                    if (url.includes('data.metal0.dev/laion-1m/images.lance')) {
                        hintEl.innerHTML = `<strong> Default dataset:</strong> 1M LAION images with <strong>text embeddings</strong> (all-MiniLM-L6-v2, 384-dim). Use <strong>MiniLM encoder</strong> for vector search.`;
                        hintEl.style.display = 'block';
                    } else {
                        hintEl.style.display = 'none';
                    }

                    // Populate DataFrame builder selects
                    document.getElementById('run-df-btn').disabled = false;
                    const filterCol = document.getElementById('df-filter-col');
                    const selectCols = document.getElementById('df-select-cols');
                    filterCol.innerHTML = '<option value="">No filter</option>';
                    selectCols.innerHTML = '';

                    const colNames = currentFile.columnNames || [];
                    for (let i = 0; i < currentFile.numColumns; i++) {
                        const name = colNames[i] || `column_${i}`;
                        const type = columnTypes[i] || 'unknown';
                        // Only show numeric columns in filter dropdown
                        if (type !== 'string' && type !== 'vector') {
                            filterCol.innerHTML += `<option value="${i}">${name} (${type})</option>`;
                        }
                        selectCols.innerHTML += `<option value="${i}" selected>${name}</option>`;
                    }

                    // Populate vector column dropdown
                    const vectorCol = document.getElementById('vector-col');
                    vectorCol.innerHTML = '';
                    for (let i = 0; i < currentFile.numColumns; i++) {
                        if (columnTypes[i] === 'vector') {
                            const name = colNames[i] || `column_${i}`;
                            vectorCol.innerHTML += `<option value="${i}">${name}</option>`;
                        }
                    }
                    // If no vector columns found, show placeholder
                    if (vectorCol.options.length === 0) {
                        vectorCol.innerHTML = '<option value="">No vector columns</option>';
                    }

                    // Update DataFrame code preview (skip sync to preserve SQL)
                    updateDfPreview(true);

                    targetFile = currentFile;
                }

                if (!targetFile) {
                    showStatus('No file loaded. Use: SELECT * FROM read_lance(\'https://...\') LIMIT 10', 'error');
                    return;
                }

                // Check if this is a vector search query
                if (ast.search) {
                    await runVectorSearchQuery(ast, targetFile);
                    return;
                }

                showStatus('Executing query...', 'info');

                // Use the new SQL executor for proper parsing
                const executor = new SQLExecutor(targetFile);
                const result = await executor.execute(sql, (msg, current, total) => {
                    showProgress(msg, current, total);
                });

                // Format the result for display
                const formattedResult = {
                    columns: result.columns,
                    rows: result.rows.map(row => row.map(cell => {
                        if (cell === null || cell === undefined) return '';
                        if (typeof cell === 'number') {
                            return Number.isInteger(cell) ? cell.toString() : cell.toFixed(4);
                        }
                        return String(cell);
                    })),
                    total: result.total,
                    aggregationStats: result.aggregationStats,
                    orderByOnSubset: result.orderByOnSubset
                };

                document.getElementById('results-section').style.display = 'block';
                displayResults(formattedResult);
                hideProgress();
                showStatus(`Query completed: ${result.rows.length} rows`, 'success');
            } catch (err) {
                showStatus('Query error: ' + err.message, 'error');
                console.error(err);
            } finally {
                setLoading(false);
            }
        }

        // Execute simple SQL-like queries
        async function executeSimpleSql(sql) {
            const upperSql = sql.toUpperCase();
            const isRemote = currentFile._isRemote;

            // Parse LIMIT
            let limit = 100;
            const limitMatch = upperSql.match(/LIMIT\s+(\d+)/);
            if (limitMatch) limit = parseInt(limitMatch[1]);

            // For remote files, we don't support WHERE filtering yet (would need full column scan)
            // Just fetch the first N rows
            if (isRemote) {
                return await executeRemoteQuery(limit);
            }

            // Parse WHERE for simple conditions (local files only)
            let filterIndices = null;
            const whereMatch = sql.match(/WHERE\s+(\w+)\s*(>|>=|<|<=|=|!=)\s*(-?\d+(?:\.\d+)?)/i);
            if (whereMatch) {
                const colMatch = whereMatch[1].match(/column_?(\d+)/i);
                if (colMatch) {
                    const colIdx = parseInt(colMatch[1]);
                    const op = whereMatch[2];
                    const value = parseFloat(whereMatch[3]);
                    const type = columnTypes[colIdx] || 'int64';

                    const df = currentFile.df().filter(colIdx, op, value, type);
                    filterIndices = df.collectIndices();
                }
            }

            // Check for aggregation query
            if (upperSql.includes('COUNT(') || upperSql.includes('SUM(') || upperSql.includes('AVG(')) {
                return executeAggregationQuery(sql, filterIndices);
            }

            // Regular SELECT
            const columns = [];
            for (let i = 0; i < currentFile.numColumns; i++) {
                columns.push(`column_${i}`);
            }

            const rows = [];
            const indices = filterIndices || Array.from({length: Math.min(rowCount, limit)}, (_, i) => i);
            const actualLimit = Math.min(indices.length, limit);

            for (let i = 0; i < actualLimit; i++) {
                const row = [];
                const idx = indices[i];
                for (let c = 0; c < currentFile.numColumns; c++) {
                    const type = columnTypes[c];
                    if (type === 'int64') {
                        const data = currentFile.readInt64AtIndices(c, new Uint32Array([idx]));
                        row.push(data[0]?.toString() || '');
                    } else if (type === 'float64') {
                        const data = currentFile.readFloat64AtIndices(c, new Uint32Array([idx]));
                        row.push(data[0]?.toFixed(4) || '');
                    } else if (type === 'string') {
                        const str = currentFile.readStringAt(c, idx);
                        row.push(str || '');
                    } else {
                        row.push('?');
                    }
                }
                rows.push(row);
            }

            return { columns, rows, total: filterIndices ? filterIndices.length : rowCount };
        }

        // Execute query for remote files via Range requests
        // Uses batched fetching - reads all indices per column in one batch
        async function executeRemoteQuery(limit, randomIndices = null) {
            // Get column names from schema if available
            const colNames = currentFile?.columnNames || [];
            const columns = [];
            for (let i = 0; i < currentFile.numColumns; i++) {
                columns.push(colNames[i] || `column_${i}`);
            }

            const indices = randomIndices || Array.from({length: limit}, (_, i) => i);
            const actualLimit = indices.length;
            const numCols = currentFile.numColumns;

            // Show progress bar
            showProgress('Fetching column data...', 0, numCols);

            // Fetch all data per column using detected types
            const columnData = [];

            for (let c = 0; c < numCols; c++) {
                showProgress(`Fetching column ${c + 1}/${numCols}`, c, numCols);

                const type = columnTypes[c] || 'unknown';
                const colName = colNames[c]?.toLowerCase() || '';
                let data = null;

                console.log(`executeRemoteQuery: column ${c} (${colNames[c]}), type=${type}`);

                try {
                    if (type === 'string') {
                        data = await currentFile.readStringsAtIndices(c, indices);
                        columnData.push({ type: 'string', data });
                        continue;
                    }

                    if (type === 'int64') {
                        data = await currentFile.readInt64AtIndices(c, indices);
                        columnData.push({ type: 'int64', data, colName });
                        continue;
                    }

                    if (type === 'float64') {
                        data = await currentFile.readFloat64AtIndices(c, indices);
                        columnData.push({ type: 'float64', data });
                        continue;
                    }

                    if (type === 'int32') {
                        data = await currentFile.readInt32AtIndices(c, indices);
                        columnData.push({ type: 'int32', data });
                        continue;
                    }

                    if (type === 'float32') {
                        data = await currentFile.readFloat32AtIndices(c, indices);
                        columnData.push({ type: 'float32', data });
                        continue;
                    }

                    if (type === 'int16') {
                        data = await currentFile.readInt16AtIndices(c, indices);
                        columnData.push({ type: 'int16', data });
                        continue;
                    }

                    if (type === 'int8') {
                        data = await currentFile.readUint8AtIndices(c, indices);
                        columnData.push({ type: 'int8', data });
                        continue;
                    }

                    if (type === 'vector') {
                        // For vectors, just show placeholder
                        try {
                            const info = await currentFile.getVectorInfo(c);
                            columnData.push({ type: 'vector', data: null, info });
                        } catch (e) {
                            columnData.push({ type: 'vector', data: null, info: { dimension: '?' } });
                        }
                        continue;
                    }

                    // Fallback for unknown: try string first
                    try {
                        data = await currentFile.readStringsAtIndices(c, indices);
                        if (data && data.some(s => s && s.length > 0)) {
                            columnData.push({ type: 'string', data });
                            continue;
                        }
                    } catch (e) {}

                    columnData.push({ type: 'unknown', data: null });
                } catch (e) {
                    console.error(`Failed to read column ${c} (${colNames[c]}) as ${type}:`, e);
                    columnData.push({ type: 'unknown', data: null });
                }
            }

            showProgress('Building results...', numCols, numCols);

            // Build rows from column data
            const rows = [];
            for (let i = 0; i < actualLimit; i++) {
                const row = [];
                for (let c = 0; c < numCols; c++) {
                    const col = columnData[c];
                    const colName = col.colName || '';

                    if (col.type === 'string') {
                        row.push(col.data[i] || '');
                    } else if (col.type === 'int64') {
                        // Check if embedding/hash column
                        if (colName.includes('embedding') || colName.includes('hash')) {
                            row.push('[hash]');
                        } else {
                            row.push(col.data[i]?.toString() || '');
                        }
                    } else if (col.type === 'float64' || col.type === 'float32') {
                        row.push(col.data[i]?.toFixed(4) || '');
                    } else if (col.type === 'int32' || col.type === 'int16' || col.type === 'int8') {
                        row.push(col.data[i]?.toString() || '');
                    } else if (col.type === 'vector') {
                        row.push(`[vector ${col.info?.dimension || '?'}d]`);
                    } else {
                        row.push('?');
                    }
                }
                rows.push(row);
            }

            hideProgress();

            // Get total row count from first column
            const totalRows = await currentFile.getRowCount(0);

            return { columns, rows, total: totalRows };
        }

        function executeAggregationQuery(sql, filterIndices) {
            const results = {};

            // COUNT(*)
            if (sql.toUpperCase().includes('COUNT(*)')) {
                results['COUNT(*)'] = filterIndices ? filterIndices.length : rowCount;
            }

            // SUM, AVG for columns
            const sumMatch = sql.match(/SUM\(column_?(\d+)\)/i);
            if (sumMatch) {
                const colIdx = parseInt(sumMatch[1]);
                const type = columnTypes[colIdx];
                if (type === 'int64') {
                    results[`SUM(column_${colIdx})`] = currentFile.sumInt64(colIdx);
                } else if (type === 'float64') {
                    results[`SUM(column_${colIdx})`] = currentFile.sumFloat64(colIdx).toFixed(4);
                }
            }

            const avgMatch = sql.match(/AVG\(column_?(\d+)\)/i);
            if (avgMatch) {
                const colIdx = parseInt(avgMatch[1]);
                results[`AVG(column_${colIdx})`] = currentFile.avgFloat64(colIdx).toFixed(4);
            }

            return {
                columns: Object.keys(results),
                rows: [Object.values(results).map(v => v.toString())],
                total: 1
            };
        }

        // Run DataFrame vector search
        async function runDfVectorSearch(query, encoder, selectedCols, limit) {
            showStatus(`Encoding "${query}" with ${encoder}...`, 'info');
            showSearchLoading();

            // Get query vector
            let queryVec;
            const isClipModel = encoder.startsWith('clip');

            if (isClipModel) {
                const clipModelUrl = encoder === 'clip-openai'
                    ? 'https://data.metal0.dev/models/clip-vit-b32-openai.gguf'
                    : 'https://data.metal0.dev/models/clip-vit-b32.gguf';

                if (clipModelLoaded && window._loadedClipModelUrl !== clipModelUrl) {
                    clipModelLoaded = false;
                }
                window._loadedClipModelUrl = clipModelUrl;
                window._clipModelUrlOverride = clipModelUrl;

                if (!clipModelLoaded) {
                    const loaded = await ensureClipModelLoaded();
                    if (!loaded) {
                        setLoading(false);
                        return;
                    }
                }
                queryVec = encodeTextWithClip(query);
            } else {
                if (!minilmModelLoaded) {
                    const loaded = await ensureMinilmModelLoaded();
                    if (!loaded) {
                        setLoading(false);
                        return;
                    }
                }
                queryVec = encodeTextWithMinilm(query);
            }

            if (!queryVec) {
                showStatus(`Failed to encode text`, 'error');
                setLoading(false);
                return;
            }

            // Find vector column
            let vectorColIdx = -1;
            for (let i = 0; i < columnTypes.length; i++) {
                if (columnTypes[i] === 'vector') {
                    vectorColIdx = i;
                    break;
                }
            }
            if (vectorColIdx === -1) {
                showStatus('No vector column found', 'error');
                setLoading(false);
                return;
            }

            showStatus('Searching vectors...', 'info');

            const results = await currentFile.vectorSearch(
                vectorColIdx,
                queryVec,
                limit,
                (current, total) => {
                    showProgress('Scanning vectors...', current, total);
                }
            );

            hideProgress();

            // Fetch column data
            const colNames = currentFile.columnNames || [];
            const cols = selectedCols.length > 0 ? selectedCols : Array.from({length: currentFile.numColumns}, (_, i) => i);
            const columns = ['score', ...cols.map(c => colNames[c] || `column_${c}`)];
            const columnData = {};

            for (const c of cols) {
                const type = columnTypes[c];
                if (type === 'string') {
                    columnData[c] = await currentFile.readStringsAtIndices(c, results.indices);
                } else if (type === 'int64' || type === 'int32') {
                    columnData[c] = await currentFile.readInt64AtIndices(c, results.indices);
                } else if (type === 'float64' || type === 'float32' || type === 'double') {
                    columnData[c] = await currentFile.readFloat64AtIndices(c, results.indices);
                } else if (type === 'vector') {
                    columnData[c] = results.indices.map(() => '[vector]');
                } else {
                    columnData[c] = results.indices.map(() => '');
                }
            }

            const rows = [];
            for (let i = 0; i < results.indices.length; i++) {
                const row = [results.scores[i].toFixed(4)];
                for (const c of cols) {
                    const val = columnData[c][i];
                    if (val === null || val === undefined) {
                        row.push('');
                    } else if (typeof val === 'number') {
                        row.push(Number.isInteger(val) ? val.toString() : val.toFixed(4));
                    } else {
                        row.push(val);
                    }
                }
                rows.push(row);
            }

            document.getElementById('results-section').style.display = 'block';
            displayResults({ columns, rows, total: results.indices.length });
            showStatus(`Found ${results.indices.length} results for "${query}"`, 'success');
            setLoading(false);
        }

        // Run DataFrame query
        async function runDfQuery() {
            try {
                setLoading(true);
                showStatus('Executing query...', 'info');

                // Parse code from editor
                const code = document.getElementById('df-input').value;
                const ops = parseDfCode(code);

                console.log('Parsed DataFrame ops:', ops);

                // Sync other tabs with this DataFrame query
                const query = {
                    url: ops.url,
                    version: ops.version,
                    search: ops.search,
                    encoder: ops.searchEncoder,
                    filter: ops.filter ? { column: ops.filter.column, op: ops.filter.op, value: ops.filter.value } : null,
                    select: ops.select,
                    limit: ops.limit
                };
                syncQueryTabs(query, 'df');

                // If URL specified in code and different from current file (or version changed), load it
                const needsReload = ops.url && (!currentFile || currentFile._url !== ops.url ||
                    (ops.version && currentFile.version !== ops.version));
                if (needsReload) {
                    const versionMsg = ops.version ? ` (v${ops.version})` : '';
                    showStatus(`Loading dataset from ${ops.url}${versionMsg}...`, 'info');
                    if (ops.url.endsWith('.lance') && !ops.url.includes('/data/')) {
                        const remoteFile = await lanceql.openDataset(ops.url, { version: ops.version });
                        if (currentFile && currentFile.close) currentFile.close();
                        currentFile = remoteFile;
                        window.currentFile = currentFile;
                        currentFile._isRemote = true;
                        currentFile._url = ops.url;
                        currentFile._isDataset = true;
                        columnTypes = await currentFile.detectColumnTypes();
                    } else {
                        await loadFromUrl(ops.url);
                    }
                }

                if (!currentFile) {
                    showStatus('No dataset loaded. Add lanceql.open("url") to your code.', 'error');
                    setLoading(false);
                    return;
                }

                // Convert column names to indices
                const colNames = currentFile?.columnNames || [];
                let selectedCols = [];
                if (ops.select && ops.select.length > 0) {
                    selectedCols = ops.select.map(name => colNames.indexOf(name)).filter(i => i >= 0);
                }

                const limit = ops.limit || 50; // Default to 50 to align with SQL

                // If search query is specified, run vector search instead
                if (ops.search) {
                    await runDfVectorSearch(ops.search, ops.searchEncoder || 'minilm', selectedCols, limit);
                    return;
                }

                // Convert filter column name to index
                let filterColIdx = -1;
                let filterOp = null;
                let filterVal = NaN;
                if (ops.filter) {
                    filterColIdx = colNames.indexOf(ops.filter.column);
                    filterOp = ops.filter.op;
                    filterVal = ops.filter.value;
                }

                console.log('runDfQuery called:', {
                    isRemote: currentFile._isRemote,
                    numColumns: currentFile.numColumns,
                    selectedCols,
                    limit,
                    columnTypes
                });

                // Get columns to fetch
                const cols = selectedCols.length > 0 ? selectedCols : Array.from({length: currentFile.numColumns}, (_, i) => i);
                const columns = cols.map(c => colNames[c] || `column_${c}`);

                console.log('cols to fetch:', cols, 'columns:', columns);

                // For remote files, use async methods
                if (currentFile._isRemote) {
                    console.log('Using remote file path');

                    let indices;

                    // Apply filter if specified
                    if (filterColIdx >= 0 && !isNaN(filterVal)) {
                        const filterType = columnTypes[filterColIdx];
                        console.log(`Applying filter: column ${filterColIdx} ${filterOp} ${filterVal} (type: ${filterType})`);

                        showProgress('Applying filter...', 0, 1);

                        // Fetch filter column data in batches and filter
                        const totalRows = await currentFile.getRowCount(0);
                        const matchingIndices = [];
                        const batchSize = 1000;

                        for (let batchStart = 0; batchStart < totalRows && matchingIndices.length < limit * 10; batchStart += batchSize) {
                            const batchEnd = Math.min(batchStart + batchSize, totalRows);
                            const batchIndices = Array.from({length: batchEnd - batchStart}, (_, i) => batchStart + i);

                            let batchData;
                            if (filterType === 'int64') {
                                const rawData = await currentFile.readInt64AtIndices(filterColIdx, batchIndices);
                                batchData = Array.from(rawData, v => Number(v));
                            } else if (filterType === 'float64') {
                                const rawData = await currentFile.readFloat64AtIndices(filterColIdx, batchIndices);
                                batchData = Array.from(rawData);
                            } else if (filterType === 'int32') {
                                const rawData = await currentFile.readInt32AtIndices(filterColIdx, batchIndices);
                                batchData = Array.from(rawData);
                            } else if (filterType === 'float32') {
                                const rawData = await currentFile.readFloat32AtIndices(filterColIdx, batchIndices);
                                batchData = Array.from(rawData);
                            } else {
                                console.warn(`Filter not supported for type ${filterType}`);
                                break;
                            }

                            // Apply filter condition
                            for (let i = 0; i < batchData.length; i++) {
                                const val = batchData[i];
                                let matches = false;
                                switch (filterOp) {
                                    case '>': matches = val > filterVal; break;
                                    case '>=': matches = val >= filterVal; break;
                                    case '<': matches = val < filterVal; break;
                                    case '<=': matches = val <= filterVal; break;
                                    case '=': matches = val === filterVal; break;
                                    case '!=': matches = val !== filterVal; break;
                                }
                                if (matches) {
                                    matchingIndices.push(batchIndices[i]);
                                }
                            }

                            showProgress(`Filtering... found ${matchingIndices.length} matches`, batchStart, totalRows);
                        }

                        indices = matchingIndices.slice(0, limit);
                        console.log(`Filter matched ${matchingIndices.length} rows, using first ${indices.length}`);
                    } else {
                        // No filter, just take first N rows
                        indices = Array.from({length: limit}, (_, i) => i);
                    }

                    const numCols = cols.length;

                    // Show progress bar
                    showProgress('Fetching column data...', 0, numCols);

                    // Fetch data for selected columns
                    const columnData = [];
                    for (let i = 0; i < cols.length; i++) {
                        const c = cols[i];
                        showProgress(`Fetching column ${i + 1}/${numCols}`, i, numCols);

                        const type = columnTypes[c];
                        let data = null;

                        console.log(`Reading column ${c} (${columns[i]}): detected type = ${type}`);

                        // Read based on detected type
                        try {
                            if (type === 'string') {
                                data = await currentFile.readStringsAtIndices(c, indices);
                                columnData.push({ type: 'string', data });
                                console.log(`Column ${c}: read ${data.length} strings`);
                                continue;
                            }

                            if (type === 'int64') {
                                data = await currentFile.readInt64AtIndices(c, indices);
                                columnData.push({ type: 'int64', data });
                                console.log(`Column ${c}: read ${data.length} int64s, sample:`, data[0]);
                                continue;
                            }

                            if (type === 'float64') {
                                data = await currentFile.readFloat64AtIndices(c, indices);
                                columnData.push({ type: 'float64', data });
                                console.log(`Column ${c}: read ${data.length} float64s, sample:`, data[0]);
                                continue;
                            }

                            if (type === 'int32') {
                                data = await currentFile.readInt32AtIndices(c, indices);
                                columnData.push({ type: 'int32', data });
                                console.log(`Column ${c}: read ${data.length} int32s, sample:`, data[0]);
                                continue;
                            }

                            if (type === 'float32') {
                                data = await currentFile.readFloat32AtIndices(c, indices);
                                columnData.push({ type: 'float32', data });
                                console.log(`Column ${c}: read ${data.length} float32s, sample:`, data[0]);
                                continue;
                            }

                            if (type === 'int16') {
                                data = await currentFile.readInt16AtIndices(c, indices);
                                columnData.push({ type: 'int16', data });
                                console.log(`Column ${c}: read ${data.length} int16s, sample:`, data[0]);
                                continue;
                            }

                            if (type === 'int8') {
                                data = await currentFile.readUint8AtIndices(c, indices);
                                columnData.push({ type: 'int8', data });
                                console.log(`Column ${c}: read ${data.length} int8s, sample:`, data[0]);
                                continue;
                            }
                        } catch (e) {
                            console.error(`Column ${c} (${columns[i]}) read failed for type ${type}:`, e);
                        }

                        if (type === 'vector') {
                            // For vectors, show dimension info instead of raw data
                            try {
                                const info = await currentFile.getVectorInfo(c);
                                columnData.push({ type: 'vector', data: null, info });
                                continue;
                            } catch (e) {}
                        }

                        // Fallback: try all types
                        try {
                            data = await currentFile.readStringsAtIndices(c, indices);
                            if (data && data.some(s => s && s.length > 0)) {
                                columnData.push({ type: 'string', data });
                                continue;
                            }
                        } catch (e) {}

                        try {
                            data = await currentFile.readInt64AtIndices(c, indices);
                            if (data && data.length > 0) {
                                columnData.push({ type: 'int64', data });
                                continue;
                            }
                        } catch (e) {}

                        try {
                            data = await currentFile.readFloat64AtIndices(c, indices);
                            if (data && data.length > 0) {
                                columnData.push({ type: 'float64', data });
                                continue;
                            }
                        } catch (e) {}

                        columnData.push({ type: 'unknown', data: null });
                    }

                    hideProgress();

                    // Build rows
                    const rows = [];
                    for (let i = 0; i < indices.length; i++) {
                        const row = [];
                        for (let j = 0; j < cols.length; j++) {
                            const col = columnData[j];
                            const colName = columns[j]?.toLowerCase() || '';

                            if (col.type === 'string') {
                                row.push(col.data[i] || '');
                            } else if (col.type === 'int64') {
                                // Check if this is an embedding hash column - show abbreviated
                                if (colName.includes('embedding') || colName.includes('hash')) {
                                    const val = col.data[i];
                                    if (val !== undefined && val !== null) {
                                        row.push(`[hash]`);
                                    } else {
                                        row.push('');
                                    }
                                } else {
                                    // BigInt64Array elements are BigInt, convert to Number then string
                                    const val = col.data[i];
                                    row.push(val !== undefined ? Number(val).toString() : '');
                                }
                            } else if (col.type === 'float64') {
                                const val = col.data[i];
                                row.push(val !== undefined ? Number(val).toFixed(4) : '');
                            } else if (col.type === 'int32' || col.type === 'int16' || col.type === 'int8') {
                                const val = col.data[i];
                                row.push(val !== undefined ? Number(val).toString() : '');
                            } else if (col.type === 'float32') {
                                const val = col.data[i];
                                row.push(val !== undefined ? Number(val).toFixed(4) : '');
                            } else if (col.type === 'vector') {
                                row.push(`[vector ${col.info?.dimension || '?'}d]`);
                            } else {
                                row.push('?');
                            }
                        }
                        rows.push(row);
                    }

                    const totalRows = await currentFile.getRowCount(0);
                    displayResults({ columns, rows, total: totalRows });
                    showStatus(`Query completed: ${rows.length} of ${totalRows} rows`, 'success');
                } else {
                    // Local file path
                    let df = currentFile.df();

                    // Apply filter
                    if (filterColIdx >= 0 && !isNaN(filterVal)) {
                        const type = columnTypes[filterColIdx] || 'int64';
                        df = df.filter(filterColIdx, filterOp, filterVal, type);
                    }

                    // Get indices
                    df = df.limit(limit);
                    const indices = df.collectIndices();
                    const matchCount = df.count();

                    const rows = [];
                    for (let i = 0; i < indices.length; i++) {
                        const row = [];
                        const idx = indices[i];
                        for (const c of cols) {
                            const type = columnTypes[c];
                            if (type === 'int64') {
                                const data = currentFile.readInt64AtIndices(c, new Uint32Array([idx]));
                                // BigInt64Array elements are BigInt
                                row.push(data[0] !== undefined ? Number(data[0]).toString() : '');
                            } else if (type === 'float64') {
                                const data = currentFile.readFloat64AtIndices(c, new Uint32Array([idx]));
                                row.push(data[0] !== undefined ? Number(data[0]).toFixed(4) : '');
                            } else if (type === 'string') {
                                try {
                                    const str = currentFile.readStringAt(c, idx);
                                    console.log(`String col ${c} row ${idx}:`, str);
                                    row.push(str || '');
                                } catch (e) {
                                    console.error(`String read failed col ${c} row ${idx}:`, e);
                                    row.push('');
                                }
                            } else if (type === 'vector') {
                                const info = currentFile.getVectorInfo(c);
                                row.push(`[vector ${info?.dimension || '?'}d]`);
                            } else {
                                row.push('?');
                            }
                        }
                        rows.push(row);
                    }

                    displayResults({ columns, rows, total: matchCount });
                    showStatus(`Query completed: ${rows.length} of ${matchCount} matching rows`, 'success');
                }
            } catch (err) {
                showStatus('Query error: ' + err.message, 'error');
                console.error(err);
            } finally {
                setLoading(false);
            }
        }

        // Check if a string looks like an image URL
        function isImageUrl(str) {
            if (!str || typeof str !== 'string') return false;
            const lower = str.toLowerCase();
            return (lower.startsWith('http://') || lower.startsWith('https://')) &&
                   (lower.includes('.jpg') || lower.includes('.jpeg') || lower.includes('.png') ||
                    lower.includes('.gif') || lower.includes('.webp') || lower.includes('.svg'));
        }

        // Check if a string is a URL (not necessarily an image)
        function isUrl(str) {
            if (!str || typeof str !== 'string') return false;
            return str.startsWith('http://') || str.startsWith('https://');
        }

        // Escape HTML to prevent XSS
        function escapeHtml(str) {
            if (typeof str !== 'string') return str;
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        // Format a cell value for display
        function formatCell(cell) {
            // Handle null/undefined/empty
            if (cell === null || cell === undefined) {
                return '<span class="null-value">NULL</span>';
            }
            if (cell === '') {
                return '<span class="empty-value">(empty)</span>';
            }

            // Handle image URLs - show thumbnail with fallback placeholder
            if (isImageUrl(cell)) {
                const escaped = escapeHtml(cell);
                const short = escaped.length > 40 ? escaped.substring(0, 40) + '...' : escaped;
                return `<div class="image-cell">
                    <img src="${escaped}" alt="" loading="lazy" onerror="this.onerror=null; this.src='data:image/svg+xml,${encodeURIComponent('<svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 100 60&quot;><rect fill=&quot;%23334155&quot; width=&quot;100&quot; height=&quot;60&quot;/><text x=&quot;50&quot; y=&quot;30&quot; fill=&quot;%2364748b&quot; font-size=&quot;10&quot; text-anchor=&quot;middle&quot; dominant-baseline=&quot;middle&quot; font-family=&quot;sans-serif&quot;>No Image</text></svg>')}'; this.classList.add('placeholder');">
                    <a href="${escaped}" target="_blank" class="url-text" title="${escaped}">${short}</a>
                </div>`;
            }

            // Handle other URLs - show as clickable link
            if (isUrl(cell)) {
                const escaped = escapeHtml(cell);
                const short = escaped.length > 50 ? escaped.substring(0, 50) + '...' : escaped;
                return `<a href="${escaped}" target="_blank" class="url-link" title="${escaped}">${short}</a>`;
            }

            // Handle long strings - truncate
            if (typeof cell === 'string' && cell.length > 100) {
                return `<span title="${escapeHtml(cell)}">${escapeHtml(cell.substring(0, 100))}...</span>`;
            }

            // Handle vector placeholders
            if (typeof cell === 'string' && cell.startsWith('[vector ')) {
                const match = cell.match(/\[vector (\d+)d\]/);
                const dim = match ? match[1] : '?';
                return `<span class="vector-badge" title="Vector embedding with ${dim} dimensions">
                    <svg viewBox="0 0 16 16" fill="currentColor" width="12" height="12">
                        <circle cx="3" cy="8" r="2"/><circle cx="8" cy="8" r="2"/><circle cx="13" cy="8" r="2"/>
                    </svg>
                    ${dim}d
                </span>`;
            }

            // Handle hash placeholders
            if (cell === '[hash]') {
                return `<span class="hash-badge" title="Hash/ID value">
                    <svg viewBox="0 0 16 16" fill="currentColor" width="12" height="12">
                        <path d="M5 1v3H1v2h4v4H1v2h4v3h2v-3h4v3h2v-3h3v-2h-3V6h3V4h-3V1h-2v3H7V1H5zm2 5h4v4H7V6z"/>
                    </svg>
                </span>`;
            }

            // Default: escape and display
            return escapeHtml(String(cell));
        }

        // Display results with infinite scroll support
        function displayResults(result, append = false) {
            // Store result for export (merge if appending)
            if (append && lastResult) {
                lastResult.rows = [...lastResult.rows, ...result.rows];
            } else {
                lastResult = { columns: result.columns, rows: [...result.rows] };
            }

            const body = document.getElementById('results-body');
            const loadedCount = append ? (infiniteScrollState?.loadedCount || 0) + result.rows.length : result.rows.length;
            document.getElementById('results-count').textContent = `${loadedCount.toLocaleString()} of ${result.total.toLocaleString()} rows`;

            // Show notice if ORDER BY was applied on a subset or aggregation on partial data
            const noticeEl = document.getElementById('results-notice');
            if (result.aggregationStats?.fromMetadata && !append) {
                noticeEl.textContent = ` Row count from metadata (no scan required)`;
                noticeEl.style.display = 'inline';
                noticeEl.style.color = '#22c55e';
                noticeEl.style.background = 'rgba(34, 197, 94, 0.1)';
            } else if (result.aggregationStats?.fromSearch && !append) {
                const stats = result.aggregationStats;
                noticeEl.textContent = ` Aggregated over ${stats.scannedRows.toLocaleString()} vector search results`;
                noticeEl.style.display = 'inline';
                noticeEl.style.color = '#22c55e';
                noticeEl.style.background = 'rgba(34, 197, 94, 0.1)';
            } else if (result.aggregationStats?.isPartialScan && !append) {
                const stats = result.aggregationStats;
                noticeEl.textContent = ` Aggregated over ${stats.scannedRows.toLocaleString()} of ${stats.totalRows.toLocaleString()} rows (${stats.coveragePercent}% coverage)`;
                noticeEl.style.display = 'inline';
                noticeEl.style.color = '#f59e0b';
                noticeEl.style.background = 'rgba(245, 158, 11, 0.1)';
            } else if (result.orderByOnSubset && !append) {
                noticeEl.textContent = ` Sorted within ${loadedCount} fetched rows only, not full dataset`;
                noticeEl.style.display = 'inline';
                noticeEl.style.color = '#f59e0b';
                noticeEl.style.background = 'rgba(245, 158, 11, 0.1)';
            } else if (!append) {
                noticeEl.style.display = 'none';
            }

            if (result.rows.length === 0 && !append) {
                infiniteScrollState = null;
                body.innerHTML = `
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="8" x2="12" y2="12"/>
                            <line x1="12" y1="16" x2="12.01" y2="16"/>
                        </svg>
                        <h3>No matching rows</h3>
                        <p>Try adjusting your query filters</p>
                    </div>
                `;
                return;
            }

            if (append) {
                // Append rows to existing table
                const tbody = body.querySelector('tbody');
                if (tbody) {
                    let html = '';
                    for (const row of result.rows) {
                        html += '<tr>';
                        for (const cell of row) {
                            html += `<td>${formatCell(cell)}</td>`;
                        }
                        html += '</tr>';
                    }
                    tbody.insertAdjacentHTML('beforeend', html);

                    // Update state
                    if (infiniteScrollState) {
                        infiniteScrollState.loadedCount = loadedCount;
                        infiniteScrollState.nextOffset += result.rows.length;
                    }
                }
                return;
            }

            // Find all vector columns for "Find Similar" feature
            // Only show search buttons if result contains actual data rows (not aggregations)
            const vectorCols = [];
            const colNames = currentFile?.columnNames || [];
            const resultColNames = result.columns || [];
            const isAggregationResult = resultColNames.some(c =>
                /^(COUNT|SUM|AVG|MIN|MAX)\s*\(/i.test(c)
            );
            if (!isAggregationResult) {
                columnTypes.forEach((t, idx) => {
                    if (t === 'vector') {
                        vectorCols.push({ idx, name: colNames[idx] || `col_${idx}` });
                    }
                });
            }
            const hasVectorCol = vectorCols.length > 0 && currentFile?._isRemote;

            // Build new table
            let html = '<table class="data-table" id="results-table"><thead><tr>';
            if (hasVectorCol) {
                // Add a header for each vector column's search button
                for (const vc of vectorCols) {
                    const shortName = vc.name.length > 8 ? vc.name.slice(0, 6) + '..' : vc.name;
                    html += `<th style="width: 50px;" title="Find similar using ${vc.name}"> ${shortName}</th>`;
                }
            }
            for (const col of result.columns) {
                html += `<th>${escapeHtml(col)}</th>`;
            }
            html += '</tr></thead><tbody>';

            // Track the starting row index for this result set
            const startRowIdx = result.startRowIdx || 0;

            for (let i = 0; i < result.rows.length; i++) {
                const row = result.rows[i];
                const rowIdx = result.rowIndices ? result.rowIndices[i] : (startRowIdx + i);
                html += '<tr>';
                if (hasVectorCol) {
                    // Add a search button for each vector column
                    for (const vc of vectorCols) {
                        html += `<td><button class="find-similar-btn" data-row="${rowIdx}" data-col="${vc.idx}" title="Find similar using ${vc.name}"></button></td>`;
                    }
                }
                for (const cell of row) {
                    html += `<td>${formatCell(cell)}</td>`;
                }
                html += '</tr>';
            }

            html += '</tbody></table>';

            // Add loading indicator
            html += '<div id="scroll-loader" class="scroll-loader" style="display: none;"><span class="spinner"></span> Loading more...</div>';

            body.innerHTML = html;

            // Store state for infinite scroll
            infiniteScrollState = {
                columns: result.columns,
                total: result.total,
                loadedCount: result.rows.length,
                nextOffset: result.rows.length
            };
        }

        // Load more rows for infinite scroll
        async function loadMoreRows() {
            if (!infiniteScrollState || !currentFile || !currentFile._isRemote) return;
            if (isLoadingMore) return;
            if (infiniteScrollState.loadedCount >= infiniteScrollState.total) return;

            isLoadingMore = true;
            const loader = document.getElementById('scroll-loader');
            if (loader) loader.style.display = 'flex';

            try {
                const startIdx = infiniteScrollState.nextOffset;
                const indices = Array.from({length: PAGE_SIZE}, (_, i) => startIdx + i)
                    .filter(i => i < infiniteScrollState.total);

                if (indices.length === 0) {
                    isLoadingMore = false;
                    if (loader) loader.style.display = 'none';
                    return;
                }

                const colNames = currentFile?.columnNames || [];
                const numCols = currentFile.numColumns;
                const columnData = [];

                for (let c = 0; c < numCols; c++) {
                    const type = columnTypes[c];
                    let data = null;

                    if (type === 'string') {
                        try {
                            data = await currentFile.readStringsAtIndices(c, indices);
                            columnData.push({ type: 'string', data });
                            continue;
                        } catch (e) {}
                    }

                    if (type === 'int64') {
                        try {
                            data = await currentFile.readInt64AtIndices(c, indices);
                            columnData.push({ type: 'int64', data });
                            continue;
                        } catch (e) {}
                    }

                    if (type === 'float64') {
                        try {
                            data = await currentFile.readFloat64AtIndices(c, indices);
                            columnData.push({ type: 'float64', data });
                            continue;
                        } catch (e) {}
                    }

                    if (type === 'int32' || type === 'float32') {
                        try {
                            if (type === 'int32') {
                                data = await currentFile.readInt32AtIndices(c, indices);
                            } else {
                                data = await currentFile.readFloat32AtIndices(c, indices);
                            }
                            columnData.push({ type, data });
                            continue;
                        } catch (e) {}
                    }

                    if (type === 'int16') {
                        try {
                            data = await currentFile.readInt16AtIndices(c, indices);
                            columnData.push({ type: 'int16', data });
                            continue;
                        } catch (e) {}
                    }

                    if (type === 'int8') {
                        try {
                            data = await currentFile.readUint8AtIndices(c, indices);
                            columnData.push({ type: 'int8', data });
                            continue;
                        } catch (e) {}
                    }

                    if (type === 'vector') {
                        try {
                            const info = await currentFile.getVectorInfo(c);
                            columnData.push({ type: 'vector', data: null, info });
                            continue;
                        } catch (e) {}
                    }

                    // Fallback
                    try {
                        data = await currentFile.readStringsAtIndices(c, indices);
                        if (data && data.some(s => s && s.length > 0)) {
                            columnData.push({ type: 'string', data });
                            continue;
                        }
                    } catch (e) {}

                    columnData.push({ type: 'unknown', data: null });
                }

                // Build rows
                const rows = [];
                for (let i = 0; i < indices.length; i++) {
                    const row = [];
                    for (let c = 0; c < numCols; c++) {
                        const col = columnData[c];
                        const colName = colNames[c]?.toLowerCase() || '';

                        if (col.type === 'string') {
                            row.push(col.data[i] || '');
                        } else if (col.type === 'int64') {
                            if (colName.includes('embedding') || colName.includes('hash')) {
                                row.push(col.data[i] !== undefined ? '[hash]' : '');
                            } else {
                                row.push(col.data[i]?.toString() || '');
                            }
                        } else if (col.type === 'float64') {
                            row.push(col.data[i]?.toFixed(4) || '');
                        } else if (col.type === 'int32' || col.type === 'int16' || col.type === 'int8') {
                            row.push(col.data[i]?.toString() || '');
                        } else if (col.type === 'float32') {
                            row.push(col.data[i]?.toFixed(4) || '');
                        } else if (col.type === 'vector') {
                            row.push(`[vector ${col.info?.dimension || '?'}d]`);
                        } else {
                            row.push('?');
                        }
                    }
                    rows.push(row);
                }

                displayResults({
                    columns: infiniteScrollState.columns,
                    rows,
                    total: infiniteScrollState.total
                }, true);

            } catch (err) {
                console.error('Error loading more rows:', err);
            } finally {
                isLoadingMore = false;
                const loader = document.getElementById('scroll-loader');
                if (loader) loader.style.display = 'none';
            }
        }

        // Set up scroll listener for infinite scroll
        function setupInfiniteScroll() {
            const body = document.getElementById('results-body');
            body.addEventListener('scroll', () => {
                if (!infiniteScrollState || !currentFile?._isRemote) return;

                const scrollTop = body.scrollTop;
                const scrollHeight = body.scrollHeight;
                const clientHeight = body.clientHeight;

                // Load more when within 200px of bottom
                if (scrollTop + clientHeight >= scrollHeight - 200) {
                    loadMoreRows();
                }
            });
        }

        function showStatus(message, type) {
            const status = document.getElementById('query-status');
            status.textContent = message;
            status.className = 'status show ' + type;

            if (type === 'success') {
                setTimeout(() => status.classList.remove('show'), 3000);
            }
        }

        // Load from URL using HTTP Range requests (lazy loading)
        async function loadFromUrl(url) {
            showStatus('Loading metadata via Range requests...', 'info');
            setLoading(true);

            try {
                let remoteFile;
                let isDataset = false;

                // Check if URL is a dataset base (ends with .lance but not in /data/)
                // Dataset URL: https://host/path/dataset.lance
                // File URL: https://host/path/dataset.lance/data/file.lance
                if (url.endsWith('.lance') && !url.includes('/data/')) {
                    // Load as full dataset with all fragments
                    showStatus('Loading dataset manifest...', 'info');
                    remoteFile = await lanceql.openDataset(url);
                    isDataset = true;
                } else {
                    // Load as single file
                    remoteFile = await lanceql.openUrl(url);
                }

                // Store as current file with remote flag
                if (currentFile && currentFile.close) currentFile.close();
                currentFile = remoteFile;
                window.currentFile = currentFile;
                currentFile._isRemote = true;
                currentFile._url = url;
                currentFile._isDataset = isDataset;

                // Set up network stats callback
                currentFile.onFetch((bytes, requests) => {
                    updateNetworkStats(bytes, requests);
                });

                columnTypes = [];
                rowCount = isDataset ? remoteFile.rowCount : 0;

                // Clear cached column types to force re-detection
                if (remoteFile._columnTypes) {
                    remoteFile._columnTypes = null;
                }

                // Update UI
                document.getElementById('file-info').classList.remove('hidden');
                collapseFileLoader();
                const displayName = isDataset ? url.split('/').pop() : (url.split('/').pop() || 'remote.lance');
                document.getElementById('file-name').textContent = displayName + (isDataset ? ' (dataset)' : '');
                document.getElementById('file-size').textContent = (remoteFile.size / 1024 / 1024).toFixed(2) + ' MB';
                document.getElementById('col-count').textContent = remoteFile.numColumns;
                document.getElementById('row-count').textContent = isDataset ? rowCount.toLocaleString() : 'Lazy';

                // Reset network stats for new file
                resetNetworkStats();

                // Show network stats
                document.getElementById('network-stats').classList.remove('hidden');

                // Detect column types
                showStatus('Detecting column types...', 'info');
                try {
                    columnTypes = await remoteFile.detectColumnTypes();
                    showColumnChips();
                } catch (e) {
                    columnTypes = Array(remoteFile.numColumns).fill('unknown');
                }

                // Populate vector columns for vector search
                await populateVectorColumns();

                // Show query section
                document.getElementById('query-section').style.display = 'block';
                document.getElementById('run-sql-btn').disabled = false;
                document.getElementById('run-df-btn').disabled = false;

                // Populate DataFrame builder selects with type info
                const filterCol = document.getElementById('df-filter-col');
                const selectCols = document.getElementById('df-select-cols');
                filterCol.innerHTML = '<option value="">No filter</option>';
                selectCols.innerHTML = '';

                // Get column names from schema if available
                const colNames = remoteFile.columnNames || [];

                for (let i = 0; i < remoteFile.numColumns; i++) {
                    const type = columnTypes[i] || 'unknown';
                    const name = colNames[i] || `column_${i}`;
                    // Only show numeric columns in filter dropdown
                    if (type !== 'string' && type !== 'vector') {
                        filterCol.innerHTML += `<option value="${i}">${name} (${type})</option>`;
                    }
                    selectCols.innerHTML += `<option value="${i}" selected>${name}</option>`;
                }

                // Show results section
                document.getElementById('results-section').style.display = 'block';

                // Hide aggregation bar for remote files (would need full scan)
                document.getElementById('agg-bar').style.display = 'none';

                const statusMsg = isDataset
                    ? `Dataset loaded! ${remoteFile.numColumns} columns, ${rowCount.toLocaleString()} rows across ${remoteFile.fragments.length} fragments (parallel Range requests)`
                    : `Connected! ${remoteFile.numColumns} columns, ${(remoteFile.size / 1024 / 1024).toFixed(1)}MB file (lazy loading via Range requests)`;
                showStatus(statusMsg, 'success');
                // Update DataFrame preview (skip sync to preserve SQL)
                updateDfPreview(true);

                // Show dataset hint for default dataset
                const hintEl = document.getElementById('dataset-hint');
                if (url.includes('data.metal0.dev/laion-1m/images.lance')) {
                    hintEl.innerHTML = `<strong> Default dataset:</strong> 1M LAION images with <strong>text embeddings</strong> (all-MiniLM-L6-v2, 384-dim). Use <strong>MiniLM encoder</strong> for vector search. CLIP encoder won't match these embeddings.`;
                    hintEl.style.display = 'block';
                } else {
                    hintEl.style.display = 'none';
                }

            } catch (err) {
                showStatus('Failed to load URL: ' + err.message, 'error');
                console.error(err);
            } finally {
                setLoading(false);
            }
        }

        // Event listeners
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const urlInput = document.getElementById('url-input');
        const loadUrlBtn = document.getElementById('load-url-btn');

        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            // Handle folder drop via DataTransferItemList
            if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
                const item = e.dataTransfer.items[0];
                if (item.webkitGetAsEntry) {
                    const entry = item.webkitGetAsEntry();
                    if (entry && entry.isDirectory) {
                        await handleLanceFolder(entry);
                        return;
                    }
                }
            }
            // Fallback to single file
            if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
        });
        fileInput.addEventListener('change', () => {
            // With webkitdirectory, files contains all files in the folder
            if (fileInput.files && fileInput.files.length > 0) {
                handleLanceFiles(Array.from(fileInput.files));
            }
        });

        loadUrlBtn.addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (url) loadFromUrl(url);
        });
        urlInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const url = urlInput.value.trim();
                if (url) loadFromUrl(url);
            }
        });

        document.getElementById('run-sql-btn').addEventListener('click', runSqlQuery);
        document.getElementById('run-df-btn').addEventListener('click', runDfQuery);

        // Share button - copy link to clipboard
        document.getElementById('copy-link-btn').addEventListener('click', async () => {
            const sql = document.getElementById('sql-input').value.trim();
            if (!sql) {
                showStatus('No query to share', 'error');
                return;
            }
            const shareUrl = `${window.location.origin}${window.location.pathname}#sql=${encodeURIComponent(sql)}`;
            try {
                await navigator.clipboard.writeText(shareUrl);
                showStatus('Link copied to clipboard!', 'success');
            } catch (e) {
                // Fallback for older browsers
                prompt('Copy this link:', shareUrl);
            }
        });

        // Export buttons
        document.getElementById('export-csv').addEventListener('click', () => {
            if (!lastResult || lastResult.rows.length === 0) {
                showStatus('No data to export', 'error');
                return;
            }
            exportAsCSV(lastResult);
        });

        document.getElementById('export-json').addEventListener('click', () => {
            if (!lastResult || lastResult.rows.length === 0) {
                showStatus('No data to export', 'error');
                return;
            }
            exportAsJSON(lastResult);
        });

        function exportAsCSV(result) {
            const escapeCSV = (val) => {
                if (val === null || val === undefined) return '';
                const str = String(val);
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            };

            const header = result.columns.map(escapeCSV).join(',');
            const rows = result.rows.map(row => row.map(escapeCSV).join(','));
            const csv = [header, ...rows].join('\n');

            downloadFile(csv, 'results.csv', 'text/csv');
            showStatus(`Exported ${result.rows.length} rows as CSV`, 'success');
        }

        function exportAsJSON(result) {
            const data = result.rows.map(row => {
                const obj = {};
                result.columns.forEach((col, i) => {
                    obj[col] = row[i];
                });
                return obj;
            });

            const json = JSON.stringify(data, null, 2);
            downloadFile(json, 'results.json', 'application/json');
            showStatus(`Exported ${result.rows.length} rows as JSON`, 'success');
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Random sample button (only if element exists)
        document.getElementById('random-sample-btn')?.addEventListener('click', async () => {
            if (!currentFile) return;

            try {
                setLoading(true);
                showStatus('Generating random sample...', 'info');

                // Get total row count
                const totalRows = currentFile._isRemote
                    ? await currentFile.getRowCount(0)
                    : rowCount;

                // Generate 20 random indices
                const sampleSize = 20;
                const randomIndices = [];
                const seen = new Set();
                while (randomIndices.length < sampleSize && randomIndices.length < totalRows) {
                    const idx = Math.floor(Math.random() * totalRows);
                    if (!seen.has(idx)) {
                        seen.add(idx);
                        randomIndices.push(idx);
                    }
                }
                randomIndices.sort((a, b) => a - b);

                let result;
                if (currentFile._isRemote) {
                    result = await executeRemoteQuery(sampleSize, randomIndices);
                } else {
                    // For local files, read at random indices
                    const columns = [];
                    for (let i = 0; i < currentFile.numColumns; i++) {
                        columns.push(`column_${i}`);
                    }
                    const rows = [];
                    for (const idx of randomIndices) {
                        const row = [];
                        for (let c = 0; c < currentFile.numColumns; c++) {
                            const type = columnTypes[c];
                            if (type === 'int64') {
                                const data = currentFile.readInt64AtIndices(c, new Uint32Array([idx]));
                                row.push(data[0]?.toString() || '');
                            } else if (type === 'float64') {
                                const data = currentFile.readFloat64AtIndices(c, new Uint32Array([idx]));
                                row.push(data[0]?.toFixed(4) || '');
                            } else if (type === 'string') {
                                const str = currentFile.readStringAt(c, idx);
                                row.push(str || '');
                            } else {
                                row.push('?');
                            }
                        }
                        rows.push(row);
                    }
                    result = { columns, rows, total: totalRows };
                }

                displayResults(result);
                showStatus(`Random sample: ${result.rows.length} rows`, 'success');
            } catch (err) {
                showStatus('Error: ' + err.message, 'error');
                console.error(err);
            } finally {
                setLoading(false);
            }
        });

        // DataFrame preview updates
        ['df-search-query', 'df-search-encoder', 'df-filter-col', 'df-filter-op', 'df-filter-value', 'df-limit'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('change', () => updateDfPreview(false));
                el.addEventListener('input', () => updateDfPreview(false));
            }
        });
        // Multi-select needs special handling - use setTimeout to ensure selection is complete
        const dfSelectCols = document.getElementById('df-select-cols');
        if (dfSelectCols) {
            const handleSelectChange = () => {
                // Reset userEdited flag so DataFrame code updates
                document.getElementById('df-input').dataset.userEdited = '';
                setTimeout(() => updateDfPreview(false), 0);
            };
            dfSelectCols.addEventListener('change', handleSelectChange);
            dfSelectCols.addEventListener('mouseup', handleSelectChange);
            dfSelectCols.addEventListener('keyup', handleSelectChange);
        }

        // Vector Search
        document.getElementById('run-vector-btn').addEventListener('click', runVectorSearch);

        // Vector Search field sync - update SQL/DataFrame when fields change
        function updateVectorSearchSync() {
            const searchText = document.getElementById('clip-text-input').value.trim();
            const encoder = document.getElementById('clip-model-select').value;
            const topK = document.getElementById('top-k').value;
            const vectorColSelect = document.getElementById('vector-col');
            const vectorColText = vectorColSelect.selectedOptions[0]?.text || null;
            // Extract just the column name (before the parenthesis)
            const vectorCol = vectorColText ? vectorColText.split(' (')[0] : null;
            // Don't include query-row if there's text search
            const queryRowVal = document.getElementById('query-row').value;
            // Preserve limit from DataFrame
            const limit = document.getElementById('df-limit').value;

            const query = {
                url: currentFile?._url,
                // Don't auto-include version
                encoder: encoder,
                topK: topK ? parseInt(topK) : 20,
                vectorColumn: vectorCol && !vectorCol.includes('No vector') ? vectorCol : null,
                limit: limit ? parseInt(limit) : null
            };

            // Text search takes priority over row search
            if (searchText) {
                query.search = searchText;
            } else if (queryRowVal !== '') {
                query.searchRow = parseInt(queryRowVal);
            }

            syncQueryTabs(query, 'vector');
        }

        // Text search clears query row when changed
        document.getElementById('clip-text-input').addEventListener('input', () => {
            const searchText = document.getElementById('clip-text-input').value.trim();
            if (searchText) {
                document.getElementById('query-row').value = '';
            }
            updateVectorSearchSync();
        });

        // Query row clears text search when changed
        document.getElementById('query-row').addEventListener('input', () => {
            const queryRowVal = document.getElementById('query-row').value;
            if (queryRowVal !== '') {
                document.getElementById('clip-text-input').value = '';
            }
            updateVectorSearchSync();
        });

        // Add event listeners for other Vector Search fields
        ['clip-model-select', 'top-k', 'vector-col'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('change', updateVectorSearchSync);
                el.addEventListener('input', updateVectorSearchSync);
            }
        });

        // Search example buttons
        document.querySelectorAll('.search-example').forEach(btn => {
            btn.addEventListener('click', () => {
                const row = btn.dataset.row;
                if (row === 'random') {
                    // Generate random row
                    const totalRows = currentFile?._isRemote
                        ? currentFile._numColumns > 0 ? 100000 : 0  // Estimate for remote
                        : rowCount;
                    document.getElementById('query-row').value = Math.floor(Math.random() * totalRows);
                } else {
                    document.getElementById('query-row').value = row;
                }
            });
        });

        async function runVectorSearch() {
            if (!currentFile || !currentFile._isRemote) {
                showStatus('Vector search requires a remote file', 'error');
                return;
            }

            const vectorColIdx = parseInt(document.getElementById('vector-col').value);
            const queryRowIdx = parseInt(document.getElementById('query-row').value);
            const topK = parseInt(document.getElementById('top-k').value) || 20;

            if (isNaN(vectorColIdx)) {
                showStatus('Please select a vector column', 'error');
                return;
            }

            try {
                setLoading(true);
                showStatus('Reading query vector...', 'info');

                // Get query vector from the specified row
                const queryVec = await currentFile.readVectorAt(vectorColIdx, queryRowIdx);

                if (queryVec.length === 0) {
                    showStatus('Failed to read query vector', 'error');
                    setLoading(false);
                    return;
                }

                const hasIndex = currentFile.hasIndex?.() || false;
                const searchMode = hasIndex ? 'ANN (IVF index)' : 'brute-force';
                showStatus(`Searching with ${queryVec.length}-dim vector from row ${queryRowIdx} [${searchMode}]...`, 'info');

                // Run vector search
                const results = await currentFile.vectorSearch(
                    vectorColIdx,
                    queryVec,
                    topK,
                    (current, total) => {
                        showProgress(`Scanning vectors...`, current, total);
                    }
                );

                hideProgress();

                // Get the image URLs (assuming column 0 is URL)
                const urlColIdx = 0;  // Assuming first column has URLs
                const urls = await currentFile.readStringsAtIndices(urlColIdx, results.indices);

                // Build results
                const columns = ['rank', 'row_idx', 'similarity', 'image'];
                const rows = results.indices.map((idx, i) => [
                    (i + 1).toString(),
                    idx.toString(),
                    results.scores[i].toFixed(4),
                    urls[i] || ''
                ]);

                // Display results
                displayResults({
                    columns,
                    rows,
                    total: results.indices.length
                });

                showStatus(`Found ${results.indices.length} similar images (query: row ${queryRowIdx})`, 'success');
            } catch (err) {
                showStatus('Vector search error: ' + err.message, 'error');
                console.error(err);
            } finally {
                setLoading(false);
            }
        }

        // Populate vector column select when remote file loads
        async function populateVectorColumns() {
            const vectorCol = document.getElementById('vector-col');
            vectorCol.innerHTML = '';

            if (!currentFile || !currentFile._isRemote) return;

            const colNames = currentFile.columnNames || [];

            // Check each column for vector data
            // Only consider it a vector if dimension > 2 (to exclude scalar types)
            for (let i = 0; i < currentFile.numColumns; i++) {
                try {
                    const type = columnTypes[i];
                    // Skip if we already know the type and it's not a vector
                    if (type && type !== 'vector' && type !== 'unknown') continue;

                    const info = await currentFile.getVectorInfo(i);
                    if (info.dimension > 2) {
                        const name = colNames[i] || `column_${i}`;
                        vectorCol.innerHTML += `<option value="${i}">${name} (${info.dimension}D vectors, ${info.rows.toLocaleString()} rows)</option>`;
                    }
                } catch (e) {
                    // Not a vector column
                }
            }

            // Enable vector search button if we have vector columns
            const hasVectorCols = vectorCol.options.length > 0;
            document.getElementById('run-vector-btn').disabled = !hasVectorCols;

            // If no vector columns found, show placeholder
            if (!hasVectorCols) {
                vectorCol.innerHTML = '<option value="">No vector columns</option>';
            }
        }

        // Handle "Find Similar" button clicks (event delegation)
        document.getElementById('results-body').addEventListener('click', async (e) => {
            const btn = e.target.closest('.find-similar-btn');
            if (!btn) return;

            const rowIdx = parseInt(btn.dataset.row);
            const colIdx = parseInt(btn.dataset.col);

            if (isNaN(rowIdx) || isNaN(colIdx)) return;

            // Update the vector search UI and run search
            document.getElementById('vector-col').value = colIdx;
            document.getElementById('query-row').value = rowIdx;
            // Clear text search since we're doing row-based search
            document.getElementById('clip-text-input').value = '';
            // Sync to SQL/DataFrame
            updateVectorSearchSync();

            // Switch to vector search tab
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.querySelector('[data-tab="vector"]').classList.add('active');
            document.getElementById('tab-vector').classList.add('active');

            // Run the search
            await runVectorSearch();
        });

        // =============================================
        // CLIP Text-to-Image Search Integration
        // =============================================
        let clipWasm = null;
        let clipModelLoaded = false;
        let clipModelLoading = false;
        let currentClipModel = null; // Track which model is loaded

        async function initClipWasm() {
            try {
                // CLIP functions are now in combined lanceql.wasm
                // Wait for lanceql to be loaded first
                if (!lanceql || !lanceql.wasm) {
                    // lanceql not loaded yet, wait for it
                    await new Promise(r => setTimeout(r, 100));
                    if (!lanceql || !lanceql.wasm) {
                        throw new Error('LanceQL WASM not loaded');
                    }
                }

                // Use the combined WASM which has both Lance and CLIP functions
                clipWasm = lanceql.wasm;

                // Initialize CLIP
                const initResult = clipWasm.clip_init();
                if (initResult === 0) {
                    console.log('CLIP WASM initialized (combined with LanceQL)');
                    updateClipStatus('Ready', '');
                } else {
                    console.error('CLIP init failed:', initResult);
                    updateClipStatus('Init Failed', 'error');
                }
            } catch (e) {
                console.error('Failed to load CLIP WASM:', e);
                updateClipStatus('WASM Error', 'error');
            }
        }

        function updateClipStatus(text, state = '') {
            const badge = document.getElementById('clip-status-badge');
            if (badge) {
                badge.textContent = text;
                badge.className = 'badge' + (state ? ' ' + state : '');
            }
        }

        async function ensureClipModelLoaded() {
            // Use override URL if set, otherwise default to OpenAI model
            const selectedModel = window._clipModelUrlOverride || 'https://data.metal0.dev/models/clip-vit-b32-openai.gguf';

            // Check if we need to reload (different model selected)
            if (clipModelLoaded && currentClipModel === selectedModel) {
                return true;
            }

            // If different model selected, need to reinitialize
            if (clipModelLoaded && currentClipModel !== selectedModel) {
                clipModelLoaded = false;
                clipWasm.clip_init(); // Reset CLIP state
            }

            // Currently loading - wait
            if (clipModelLoading) {
                while (clipModelLoading) {
                    await new Promise(r => setTimeout(r, 100));
                }
                return clipModelLoaded;
            }

            // Need to load
            clipModelLoading = true;
            updateClipStatus('Downloading...', 'loading');

            const modelSize = selectedModel.includes('openai') ? '128MB' : '304MB';
            try {
                showStatus(`Downloading CLIP model (${modelSize}, one-time)...`, 'info');

                const response = await fetch(selectedModel);
                if (!response.ok) {
                    throw new Error(`${selectedModel} not found in examples/wasm/`);
                }

                const modelData = await response.arrayBuffer();
                console.log('Model downloaded:', modelData.byteLength, 'bytes');
                showStatus(`Downloaded ${(modelData.byteLength / 1024 / 1024).toFixed(0)}MB, allocating memory...`, 'info');

                // Allocate and copy to WASM
                console.log('Allocating WASM buffer...');
                const bufPtr = clipWasm.clip_alloc_model_buffer(modelData.byteLength);
                console.log('Buffer pointer:', bufPtr);
                if (bufPtr === 0) {
                    throw new Error('Failed to allocate WASM memory');
                }

                console.log('Copying model data to WASM...');
                showStatus('Copying model to WASM memory...', 'info');
                const wasmMem = new Uint8Array(clipWasm.memory.buffer);
                wasmMem.set(new Uint8Array(modelData), bufPtr);
                console.log('Model data copied');

                // Parse and load - use setTimeout to allow UI update
                updateClipStatus('Parsing...', 'loading');
                showStatus('Parsing GGUF and loading weights (this may take 10-30 seconds)...', 'info');

                // Allow UI to update before blocking call
                await new Promise(r => setTimeout(r, 100));

                const loadResult = clipWasm.clip_load_model(modelData.byteLength);

                if (loadResult === 0) {
                    clipModelLoaded = true;
                    currentClipModel = selectedModel;
                    const modelName = selectedModel.includes('openai') ? 'OpenAI' : 'LAION';
                    updateClipStatus(`${modelName}`, '');
                    showStatus(`CLIP model (${modelName}) ready!`, 'success');
                    return true;
                } else {
                    const errors = {'-2': 'GGUF parse', '-3': 'Vocab', '-4': 'Vocab load', '-6': 'Weights'};
                    throw new Error(errors[loadResult] || `Error ${loadResult}`);
                }
            } catch (e) {
                console.error('CLIP load error:', e);
                updateClipStatus('Error', 'error');
                showStatus('CLIP load error: ' + e.message, 'error');
                return false;
            } finally {
                clipModelLoading = false;
            }
        }

        function encodeTextWithClip(text) {
            if (!clipWasm || !clipModelLoaded) return null;

            const textBuf = clipWasm.clip_get_text_buffer();
            const textBytes = new TextEncoder().encode(text);
            // Re-create memory view in case WASM memory grew
            const memory = new Uint8Array(clipWasm.memory.buffer);
            memory.set(textBytes, textBuf);

            console.log('Encoding text:', text, 'length:', textBytes.length);
            const result = clipWasm.clip_encode_text(textBytes.length);
            console.log('Encode result:', result);
            if (result !== 0) {
                console.error('CLIP encode error:', result);
                return null;
            }

            const outputBuf = clipWasm.clip_get_output_buffer();
            const outputDim = clipWasm.clip_get_output_dim();
            return new Float32Array(clipWasm.memory.buffer, outputBuf, outputDim).slice();
        }

        function showSearchLoading() {
            const body = document.getElementById('results-body');
            document.getElementById('results-count').textContent = 'Searching...';
            body.innerHTML = `
                <div class="empty-state">
                    <svg class="spin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="animation: spin 1s linear infinite;">
                        <circle cx="12" cy="12" r="10" stroke-dasharray="32" stroke-dashoffset="12"/>
                    </svg>
                    <h3>Searching...</h3>
                    <p>Finding similar items using IVF index</p>
                </div>
            `;
        }

        // Run vector search from SQL SEARCH clause
        async function runVectorSearchQuery(ast, targetFile) {
            const { query, encoder, column } = ast.search;
            const topK = ast.limit || 20;

            // Check if this is an aggregation query (COUNT, SUM, etc. with SEARCH)
            const isAggregation = ast.columns.some(col =>
                col.type === 'expr' && col.expr.type === 'call' &&
                ['COUNT', 'SUM', 'AVG', 'MIN', 'MAX'].includes(col.expr.name.toUpperCase())
            );

            showStatus(`Encoding "${query}" with ${encoder.toUpperCase()}...`, 'info');
            showSearchLoading();

            // Get query vector using appropriate encoder
            let queryVec;
            if (encoder === 'clip' || encoder === 'clip-openai' || encoder === 'clip-laion') {
                // Select CLIP model URL based on encoder
                const clipModelSelect = document.getElementById('clip-model-select');
                if (encoder === 'clip-openai') {
                    clipModelSelect.value = 'https://data.metal0.dev/models/clip-vit-b32-openai.gguf';
                } else if (encoder === 'clip-laion') {
                    clipModelSelect.value = 'https://data.metal0.dev/models/clip-vit-b32.gguf';
                }

                if (!clipModelLoaded) {
                    const loaded = await ensureClipModelLoaded();
                    if (!loaded) {
                        setLoading(false);
                        return;
                    }
                }
                queryVec = encodeTextWithClip(query);
            } else {
                // Default: minilm
                if (!minilmModelLoaded) {
                    const loaded = await ensureMinilmModelLoaded();
                    if (!loaded) {
                        setLoading(false);
                        return;
                    }
                }
                queryVec = encodeTextWithMinilm(query);
            }

            if (!queryVec) {
                showStatus(`Failed to encode text with ${encoder}`, 'error');
                setLoading(false);
                return;
            }

            // Find vector column (by name or auto-detect)
            let vectorColIdx = -1;
            const colNames = targetFile.columnNames || [];
            if (column) {
                vectorColIdx = colNames.findIndex(n => n.toLowerCase() === column.toLowerCase());
                if (vectorColIdx === -1) {
                    showStatus(`Column "${column}" not found`, 'error');
                    setLoading(false);
                    return;
                }
            } else {
                // Auto-detect first vector column
                for (let i = 0; i < columnTypes.length; i++) {
                    if (columnTypes[i] === 'vector') {
                        vectorColIdx = i;
                        break;
                    }
                }
                if (vectorColIdx === -1) {
                    showStatus('No vector column found. Use ON column_name to specify.', 'error');
                    setLoading(false);
                    return;
                }
            }

            showStatus(`Searching vectors...`, 'info');

            // Run vector search
            const results = await targetFile.vectorSearch(
                vectorColIdx,
                queryVec,
                topK,
                (current, total) => {
                    showProgress(`Scanning vectors...`, current, total);
                }
            );

            hideProgress();

            // Get all columns for results
            const columns = ['score', ...colNames];
            const rows = [];

            // Fetch data for all result indices at once (batch for efficiency)
            const columnData = {};
            for (let c = 0; c < colNames.length; c++) {
                const type = columnTypes[c];
                if (type === 'string') {
                    columnData[c] = await targetFile.readStringsAtIndices(c, results.indices);
                } else if (type === 'int64' || type === 'int32') {
                    columnData[c] = await targetFile.readInt64AtIndices(c, results.indices);
                } else if (type === 'float64' || type === 'float32' || type === 'double') {
                    columnData[c] = await targetFile.readFloat64AtIndices(c, results.indices);
                } else if (type === 'vector') {
                    columnData[c] = results.indices.map(() => '[vector]');
                } else {
                    columnData[c] = results.indices.map(() => '');
                }
            }

            // Build rows from column data
            for (let i = 0; i < results.indices.length; i++) {
                const score = results.scores[i];
                const row = [score.toFixed(4)];

                for (let c = 0; c < colNames.length; c++) {
                    const val = columnData[c][i];
                    if (val === null || val === undefined) {
                        row.push('');
                    } else if (typeof val === 'number') {
                        row.push(Number.isInteger(val) ? val.toString() : val.toFixed(4));
                    } else {
                        row.push(val);
                    }
                }
                rows.push(row);
            }

            // Handle aggregation queries (COUNT, SUM, etc. after SEARCH)
            if (isAggregation) {
                const aggResults = computeAggregationsOnSearchResults(ast, columnData, results);
                document.getElementById('results-section').style.display = 'block';
                displayResults({
                    columns: aggResults.columns,
                    rows: aggResults.rows,
                    total: 1,
                    aggregationStats: {
                        scannedRows: results.indices.length,
                        totalRows: targetFile.rowCount || results.indices.length,
                        coveragePercent: '100.00',
                        isPartialScan: false,
                        fromSearch: true
                    }
                });
                showStatus(`Aggregation over ${results.indices.length} search results for "${query}"`, 'success');
                setLoading(false);
                return;
            }

            document.getElementById('results-section').style.display = 'block';
            displayResults({ columns, rows, total: results.indices.length });
            showStatus(`Found ${results.indices.length} similar items for "${query}"`, 'success');
            setLoading(false);
        }

        // Compute aggregations over search results
        function computeAggregationsOnSearchResults(ast, columnData, results) {
            const aggColumns = [];
            const aggValues = [];

            for (const col of ast.columns) {
                if (col.type !== 'expr' || col.expr.type !== 'call') continue;

                const funcName = col.expr.name.toUpperCase();
                const alias = col.alias || `${funcName}(${col.expr.args?.[0]?.name || '*'})`;
                aggColumns.push(alias);

                const arg = col.expr.args?.[0];
                let values = [];

                if (arg?.type === 'star' || !arg) {
                    // COUNT(*) - just count results
                    if (funcName === 'COUNT') {
                        aggValues.push(results.indices.length);
                        continue;
                    }
                } else if (arg?.type === 'column') {
                    // Get column data
                    const colName = arg.name.toLowerCase();
                    const colNames = Object.keys(columnData).map(k => parseInt(k));
                    for (const [idx, data] of Object.entries(columnData)) {
                        // Match column by name
                        const fileColNames = currentFile?.columnNames || [];
                        if (fileColNames[parseInt(idx)]?.toLowerCase() === colName) {
                            values = Array.isArray(data) ? data : [];
                            break;
                        }
                    }
                }

                // Compute aggregation
                const numericValues = values.filter(v => typeof v === 'number' && !isNaN(v));
                switch (funcName) {
                    case 'COUNT':
                        aggValues.push(values.length);
                        break;
                    case 'SUM':
                        aggValues.push(numericValues.reduce((a, b) => a + b, 0));
                        break;
                    case 'AVG':
                        aggValues.push(numericValues.length > 0 ? numericValues.reduce((a, b) => a + b, 0) / numericValues.length : null);
                        break;
                    case 'MIN':
                        aggValues.push(numericValues.length > 0 ? Math.min(...numericValues) : null);
                        break;
                    case 'MAX':
                        aggValues.push(numericValues.length > 0 ? Math.max(...numericValues) : null);
                        break;
                    default:
                        aggValues.push(null);
                }
            }

            return {
                columns: aggColumns,
                rows: [aggValues.map(v => v === null ? '' : (typeof v === 'number' ? (Number.isInteger(v) ? v.toString() : v.toFixed(4)) : String(v)))]
            };
        }

        async function runClipSearch() {
            const text = document.getElementById('clip-text-input').value.trim();
            if (!text) {
                showStatus('Enter a text description', 'error');
                return;
            }

            const vectorColIdx = parseInt(document.getElementById('vector-col').value);
            if (isNaN(vectorColIdx)) {
                showStatus('Select a vector column first', 'error');
                return;
            }

            const topK = parseInt(document.getElementById('top-k').value) || 20;
            const encoder = document.getElementById('clip-model-select').value;

            // Sync other tabs with this vector search query
            const query = {
                url: currentFile?._url,
                version: currentFile?.version,
                search: text,
                encoder: encoder,
                limit: topK
            };
            syncQueryTabs(query, 'vector');

            try {
                setLoading(true);
                showSearchLoading();

                let queryVec;
                const isClipModel = encoder.startsWith('clip');
                const modelName = encoder === 'minilm' ? 'MiniLM' : encoder === 'clip-openai' ? 'CLIP OpenAI' : 'CLIP LAION';

                if (isClipModel) {
                    // Set the correct CLIP model URL
                    const clipModelUrl = encoder === 'clip-openai'
                        ? 'https://data.metal0.dev/models/clip-vit-b32-openai.gguf'
                        : 'https://data.metal0.dev/models/clip-vit-b32.gguf';

                    // Force reload if different model selected
                    if (clipModelLoaded && window._loadedClipModelUrl !== clipModelUrl) {
                        clipModelLoaded = false;
                    }
                    window._loadedClipModelUrl = clipModelUrl;
                    window._clipModelUrlOverride = clipModelUrl;

                    if (!clipModelLoaded) {
                        const loaded = await ensureClipModelLoaded();
                        if (!loaded) {
                            setLoading(false);
                            return;
                        }
                    }
                    showStatus(`Encoding "${text}" with ${modelName}...`, 'info');
                    queryVec = encodeTextWithClip(text);
                } else {
                    // MiniLM
                    if (!minilmModelLoaded) {
                        const loaded = await ensureMinilmModelLoaded();
                        if (!loaded) {
                            setLoading(false);
                            return;
                        }
                    }
                    showStatus(`Encoding "${text}" with MiniLM...`, 'info');
                    queryVec = encodeTextWithMinilm(text);
                }

                if (!queryVec) {
                    showStatus(`Failed to encode text with ${modelName}`, 'error');
                    setLoading(false);
                    return;
                }

                console.log(`${modelName} query embedding (first 8):`, Array.from(queryVec.slice(0, 8)).map(v => v.toFixed(4)));
                console.log('Query embedding L2 norm:', Math.sqrt(queryVec.reduce((sum, v) => sum + v*v, 0)).toFixed(4));
                showStatus(`Searching embeddings...`, 'info');

                // Run vector search
                const results = await currentFile.vectorSearch(
                    vectorColIdx,
                    queryVec,
                    topK,
                    (current, total) => {
                        showProgress(`Scanning vectors...`, current, total);
                    }
                );

                hideProgress();

                // Fetch all columns for results
                const colNames = currentFile.columnNames || [];
                const columns = ['score', ...colNames];
                const columnData = {};

                for (let c = 0; c < colNames.length; c++) {
                    const type = columnTypes[c];
                    if (type === 'string') {
                        columnData[c] = await currentFile.readStringsAtIndices(c, results.indices);
                    } else if (type === 'int64' || type === 'int32') {
                        columnData[c] = await currentFile.readInt64AtIndices(c, results.indices);
                    } else if (type === 'float64' || type === 'float32' || type === 'double') {
                        columnData[c] = await currentFile.readFloat64AtIndices(c, results.indices);
                    } else if (type === 'vector') {
                        columnData[c] = results.indices.map(() => '[vector]');
                    } else {
                        columnData[c] = results.indices.map(() => '');
                    }
                }

                // Build rows from column data
                const rows = [];
                for (let i = 0; i < results.indices.length; i++) {
                    const score = results.scores[i];
                    const row = [score.toFixed(4)];

                    for (let c = 0; c < colNames.length; c++) {
                        const val = columnData[c][i];
                        if (val === null || val === undefined) {
                            row.push('');
                        } else if (typeof val === 'number') {
                            row.push(Number.isInteger(val) ? val.toString() : val.toFixed(4));
                        } else {
                            row.push(val);
                        }
                    }
                    rows.push(row);
                }

                console.log('Search results - top scores:', results.scores.slice(0, 5));
                displayResults({ columns, rows, total: results.indices.length });
                showStatus(`Found ${results.indices.length} results for "${text}" (top score: ${results.scores[0]?.toFixed(4) || 'N/A'})`, 'success');
            } catch (err) {
                showStatus('Text search error: ' + err.message, 'error');
                console.error(err);
            } finally {
                setLoading(false);
            }
        }

        // =============================================
        // MiniLM Text-to-Text Search Integration
        // =============================================
        let minilmModelLoaded = false;
        let minilmModelLoading = false;
        const MINILM_MODEL_URL = 'https://data.metal0.dev/models/minilm-l6-v2.gguf';

        async function initMinilmWasm() {
            if (!lanceql || !lanceql.wasm) {
                return;
            }
            const wasm = lanceql.wasm;
            if (wasm.minilm_init) {
                const result = wasm.minilm_init();
                console.log('MiniLM WASM initialized:', result);
            }
        }

        async function ensureMinilmModelLoaded() {
            if (minilmModelLoaded) return true;
            if (minilmModelLoading) {
                while (minilmModelLoading) {
                    await new Promise(r => setTimeout(r, 100));
                }
                return minilmModelLoaded;
            }

            minilmModelLoading = true;
            updateClipStatus('Loading MiniLM...', 'loading');

            try {
                const wasm = lanceql.wasm;

                // Initialize MiniLM first
                if (wasm.minilm_init) {
                    const initResult = wasm.minilm_init();
                    console.log('MiniLM init result:', initResult);
                }

                showStatus('Downloading MiniLM model (~87MB, one-time)...', 'info');
                const response = await fetch(MINILM_MODEL_URL);
                if (!response.ok) {
                    throw new Error('MiniLM model not found');
                }

                const modelData = await response.arrayBuffer();
                console.log('MiniLM downloaded:', modelData.byteLength, 'bytes');
                showStatus(`Downloaded ${(modelData.byteLength / 1024 / 1024).toFixed(0)}MB, allocating memory...`, 'info');
                const bufPtr = wasm.minilm_alloc_model_buffer(modelData.byteLength);
                if (bufPtr === 0) {
                    throw new Error('Failed to allocate WASM memory');
                }

                showStatus('Copying model to WASM memory...', 'info');
                const wasmMem = new Uint8Array(wasm.memory.buffer);
                wasmMem.set(new Uint8Array(modelData), bufPtr);

                updateClipStatus('Parsing...', 'loading');
                showStatus('Parsing GGUF and loading MiniLM weights...', 'info');
                await new Promise(r => setTimeout(r, 100));

                const loadResult = wasm.minilm_load_model(modelData.byteLength);
                if (loadResult === 0) {
                    minilmModelLoaded = true;
                    updateClipStatus('MiniLM', '');
                    showStatus('MiniLM model ready!', 'success');
                    return true;
                } else {
                    throw new Error(`MiniLM load error: ${loadResult}`);
                }
            } catch (e) {
                console.error('MiniLM load error:', e);
                updateClipStatus('Error', 'error');
                showStatus('MiniLM load error: ' + e.message, 'error');
                return false;
            } finally {
                minilmModelLoading = false;
            }
        }

        function encodeTextWithMinilm(text) {
            const wasm = lanceql.wasm;
            if (!wasm || !minilmModelLoaded) return null;

            const textBuf = wasm.minilm_get_text_buffer();
            const textBytes = new TextEncoder().encode(text);
            const memory = new Uint8Array(wasm.memory.buffer);
            memory.set(textBytes, textBuf);

            console.log('MiniLM encoding text:', text, 'length:', textBytes.length);
            const result = wasm.minilm_encode_text(textBytes.length);
            console.log('MiniLM encode result:', result);
            if (result !== 0) {
                console.error('MiniLM encode error:', result);
                return null;
            }

            const outputBuf = wasm.minilm_get_output_buffer();
            const outputDim = wasm.minilm_get_output_dim();
            return new Float32Array(wasm.memory.buffer, outputBuf, outputDim).slice();
        }

        // CLIP event listeners
        document.getElementById('run-clip-btn').addEventListener('click', runClipSearch);

        document.getElementById('clip-text-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                runClipSearch();
            }
        });

        document.querySelectorAll('.clip-example').forEach(btn => {
            btn.addEventListener('click', () => {
                document.getElementById('clip-text-input').value = btn.dataset.text;
                runClipSearch();
            });
        });

        // Initialize CLIP WASM on page load
        initClipWasm();
        initMinilmWasm();

        // Initialize
        init();
        setupInfiniteScroll();
        setupDfEditorSync();
    </script>
</body>
</html>
