var Y=new Map;async function fe(u){return crypto.subtle.importKey("raw",new Uint8Array(u),{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function ue(u,t){let n=crypto.getRandomValues(new Uint8Array(12)),e=new TextEncoder().encode(JSON.stringify(u)),o=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},t,e),l=new Uint8Array(12+o.byteLength);return l.set(n,0),l.set(new Uint8Array(o),12),l}async function he(u,t){let n=u.slice(0,12),r=u.slice(12),e=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},t,r),o=new TextDecoder;return JSON.parse(o.decode(e))}var G=null,ie=null,be=new Map;function rt(u){G=u}function ot(u){ie=u}var de=class{constructor(t,n={}){this.name=t,this.options=n,this._root=null,this._ready=!1,this._embedder=null,this._encryptionKeyId=null}async open(t=null){if(this._ready)return this;if(t){let{keyId:n,keyBytes:r}=t;if(!Y.has(n)){let e=await fe(r);Y.set(n,e)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle(`lanceql-${this.name}`,{create:!0}),this._ready=!0}catch(n){throw console.error("[WorkerStore] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?Y.get(this._encryptionKeyId):null}async get(t){await this._ensureOpen();try{let n=this._getCryptoKey(),r=n?".enc":".json",o=await(await this._root.getFileHandle(`${t}${r}`)).getFile();if(n){let l=await o.arrayBuffer();return he(new Uint8Array(l),n)}else{let l=await o.text();return JSON.parse(l)}}catch(n){if(n.name==="NotFoundError")return;throw n}}async set(t,n){await this._ensureOpen();let r=this._getCryptoKey(),e=r?".enc":".json",l=await(await this._root.getFileHandle(`${t}${e}`,{create:!0})).createWritable();if(r){let s=await ue(n,r);await l.write(s)}else await l.write(JSON.stringify(n));await l.close()}async delete(t){await this._ensureOpen();let r=this._getCryptoKey()?".enc":".json";try{await this._root.removeEntry(`${t}${r}`)}catch(e){if(e.name!=="NotFoundError")throw e}}async keys(){await this._ensureOpen();let n=this._getCryptoKey()?".enc":".json",r=[];for await(let[e]of this._root.entries())e.endsWith(n)&&r.push(e.slice(0,-n.length));return r}async clear(){await this._ensureOpen();let t=[];for await(let[n]of this._root.entries())t.push(n);for(let n of t)await this._root.removeEntry(n)}async filter(t,n){let r=await this.get(t);if(!Array.isArray(r))throw new Error(`Key '${t}' is not a collection`);return r.filter(e=>this._matchQuery(e,n))}async find(t,n){let r=await this.get(t);if(!Array.isArray(r))throw new Error(`Key '${t}' is not a collection`);return r.find(e=>this._matchQuery(e,n))}async search(t,n,r=10){let e=await this.get(t);if(!Array.isArray(e))throw new Error(`Key '${t}' is not a collection`);if(e.length===0)return[];if(this._embedder)return this._semanticSearch(e,t,n,r);let o=n.toLowerCase();return e.map(s=>{let a=this._extractText(s).toLowerCase(),i=o.split(/\s+/),c=i.filter(f=>a.includes(f)).length;return{item:s,score:c/i.length}}).filter(s=>s.score>0).sort((s,a)=>a.score-s.score).slice(0,r)}async _semanticSearch(t,n,r,e){let o=await this._embedder.embed(r),l=[],s=[],a=[];for(let i=0;i<t.length;i++){let c=t[i],f=this._extractText(c),h=`${this.name}:${n}:${f}`;if(be.has(h)){let p=be.get(h),m=this._cosineSimilarity(o,p);l.push({item:c,score:m})}else s.push(f),a.push(i)}if(s.length>0){let i;s.length>1&&this._embedder.embedBatch?i=await this._embedder.embedBatch(s):i=await Promise.all(s.map(c=>this._embedder.embed(c)));for(let c=0;c<i.length;c++){let f=a[c],h=t[f],p=s[c],m=i[c],d=`${this.name}:${n}:${p}`;be.set(d,m);let g=this._cosineSimilarity(o,m);l.push({item:h,score:g})}}return l.sort((i,c)=>c.score-i.score).slice(0,e)}async enableSemanticSearch(t={}){let{model:n="minilm",onProgress:r}=t;if(G||(ie||(ie=this._initGPUTransformer(),ot(ie)),G=await ie,rt(G)),!G)return null;let e=await G.loadModel(n,r);return this._embedder={model:n,dimensions:e.hiddenSize,embed:async o=>G.encodeText(o,n),embedBatch:async o=>G.encodeTextBatch(o,n)},{model:n,dimensions:e.hiddenSize,type:e.modelType||"text"}}async _initGPUTransformer(){try{let t=await import("./webgpu/index.js");if(!t.isWebGPUAvailable())return console.log("[WorkerStore] WebGPU not available"),null;let n=t.getGPUTransformer();return await n.init()?(console.log("[WorkerStore] WebGPU initialized"),n):(console.log("[WorkerStore] WebGPU init failed"),null)}catch(t){return console.error("[WorkerStore] WebGPU init error:",t),null}}disableSemanticSearch(){this._embedder&&G&&(G.unloadModel(this._embedder.model),this._embedder=null)}hasSemanticSearch(){return this._embedder!==null}async count(t,n=null){let r=await this.get(t);if(!Array.isArray(r))throw new Error(`Key '${t}' is not a collection`);return n?r.filter(e=>this._matchQuery(e,n)).length:r.length}async _ensureOpen(){this._ready||await this.open()}_matchQuery(t,n){for(let[r,e]of Object.entries(n)){let o=t[r];if(typeof e=="object"&&e!==null)for(let[l,s]of Object.entries(e))switch(l){case"$eq":if(o!==s)return!1;break;case"$ne":if(o===s)return!1;break;case"$lt":if(!(o<s))return!1;break;case"$lte":if(!(o<=s))return!1;break;case"$gt":if(!(o>s))return!1;break;case"$gte":if(!(o>=s))return!1;break;case"$in":if(!Array.isArray(s)||!s.includes(o))return!1;break;case"$nin":if(Array.isArray(s)&&s.includes(o))return!1;break;case"$contains":if(typeof o!="string"||!o.includes(s))return!1;break;case"$regex":if(typeof o!="string"||!new RegExp(s).test(o))return!1;break}else if(o!==e)return!1}return!0}_extractText(t){if(typeof t=="string")return t;let n=[];for(let[r,e]of Object.entries(t))typeof e=="string"&&n.push(e);return n.join(" ")}_cosineSimilarity(t,n){let r=0,e=0,o=0;for(let l=0;l<t.length;l++)r+=t[l]*n[l],e+=t[l]*t[l],o+=n[l]*n[l];return r/(Math.sqrt(e)*Math.sqrt(o))}};var _e=class{constructor(t="lanceql"){this.rootDir=t,this.root=null}async getRoot(){if(this.root)return this.root;if(typeof navigator>"u"||!navigator.storage?.getDirectory)throw new Error("OPFS not available");let t=await navigator.storage.getDirectory();return this.root=await t.getDirectoryHandle(this.rootDir,{create:!0}),this.root}async open(){return await this.getRoot(),this}async getDir(t){let n=await this.getRoot(),r=t.split("/").filter(o=>o),e=n;for(let o of r)e=await e.getDirectoryHandle(o,{create:!0});return e}async save(t,n){let r=t.split("/"),e=r.pop(),o=r.join("/"),s=await(o?await this.getDir(o):await this.getRoot()).getFileHandle(e,{create:!0});if(s.createSyncAccessHandle)try{let i=await s.createSyncAccessHandle();return i.truncate(0),i.write(n,{at:0}),i.flush(),i.close(),{path:t,size:n.byteLength}}catch{}let a=await s.createWritable();return await a.write(n),await a.close(),{path:t,size:n.byteLength}}async load(t){try{let n=t.split("/"),r=n.pop(),e=n.join("/"),a=await(await(await(e?await this.getDir(e):await this.getRoot()).getFileHandle(r)).getFile()).arrayBuffer();return new Uint8Array(a)}catch(n){if(n.name==="NotFoundError")return null;throw n}}async delete(t){try{let n=t.split("/"),r=n.pop(),e=n.join("/");return await(e?await this.getDir(e):await this.getRoot()).removeEntry(r),!0}catch(n){if(n.name==="NotFoundError")return!1;throw n}}async list(t=""){try{let n=t?await this.getDir(t):await this.getRoot(),r=[];for await(let[e,o]of n.entries())r.push({name:e,type:o.kind});return r}catch{return[]}}async exists(t){try{let n=t.split("/"),r=n.pop(),e=n.join("/");return await(e?await this.getDir(e):await this.getRoot()).getFileHandle(r),!0}catch{return!1}}async deleteDir(t){try{let n=t.split("/"),r=n.pop(),e=n.join("/");return await(e?await this.getDir(e):await this.getRoot()).removeEntry(r,{recursive:!0}),!0}catch{return!1}}},U=new _e;var q=new TextEncoder,ee=new TextDecoder,De={INT64:"int64",INT32:"int32",FLOAT64:"float64",FLOAT32:"float32",STRING:"string",BOOL:"bool",VECTOR:"vector"},Pe=1,He=2,je=3,Ke=4,Ae=5,Se=6;function Ve(u){switch(u){case"int32":case"integer":return Int32Array;case"int64":return BigInt64Array;case"float32":case"real":return Float32Array;case"float64":case"double":return Float64Array;default:return null}}function st(u){switch(u){case"int32":case"integer":return Pe;case"int64":return He;case"float32":case"real":return je;case"float64":case"double":return Ke;case"string":case"text":return Ae;case"bool":case"boolean":return Se;default:return Ae}}var ge=class{constructor(t){this.schema=t,this.columns=new Map,this.rowCount=0,this._useBinary=!0}addRows(t){if(t.length!==0){if(this.rowCount===0)for(let n of this.schema){let r=Ve(n.dataType);r?this.columns.set(n.name,{type:"typed",dataType:n.dataType,data:new r(Math.max(t.length,1024)),length:0}):this.columns.set(n.name,{type:"array",dataType:n.dataType,data:[],length:0})}for(let n of this.schema){let r=this.columns.get(n.name);if(r.type==="typed"){let e=r.length+t.length;if(e>r.data.length){let o=Math.max(e,r.data.length*2),l=new r.data.constructor(o);l.set(r.data),r.data=l}for(let o=0;o<t.length;o++){let l=t[o][n.name];r.data[r.length+o]=l??0}r.length+=t.length}else{for(let e=0;e<t.length;e++)r.data.push(t[e][n.name]??null);r.length+=t.length}}this.rowCount+=t.length}}buildBinary(){let t=[],n=16,r=[];for(let a of this.schema){let i=this.columns.get(a.name),c=q.encode(a.name),f=st(a.dataType),h;if(i.type==="typed"){let d=i.data.subarray(0,i.length);h=new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}else h=q.encode(JSON.stringify(i.data));r.push({nameBytes:c,typeCode:f,dataBytes:h,dataType:a.dataType});let m=(8-(n+4+c.length+1+4)%8)%8;n+=4+c.length+1+m+4+h.length}let e=new ArrayBuffer(n),o=new DataView(e),l=new Uint8Array(e),s=0;o.setUint32(s,1279348291,!1),s+=4,o.setUint32(s,2,!1),s+=4,o.setUint32(s,this.schema.length,!1),s+=4,o.setUint32(s,this.rowCount,!1),s+=4;for(let a of r){o.setUint32(s,a.nameBytes.length,!1),s+=4,l.set(a.nameBytes,s),s+=a.nameBytes.length,o.setUint8(s,a.typeCode),s+=1;let i=(8-(s+4)%8)%8;for(let c=0;c<i;c++)o.setUint8(s+c,0);s+=i,o.setUint32(s,a.dataBytes.length,!1),s+=4,l.set(a.dataBytes,s),s+=a.dataBytes.length}return new Uint8Array(e)}setColumnarData(t){let n=Object.keys(t)[0];this.rowCount=t[n]?.length||0;for(let r of this.schema){let e=t[r.name];if(!e)continue;let o=Ve(r.dataType);if(o&&ArrayBuffer.isView(e))this.columns.set(r.name,{type:"typed",dataType:r.dataType,data:e,length:e.length});else if(o){let l=new o(e.length);for(let s=0;s<e.length;s++)l[s]=e[s]??0;this.columns.set(r.name,{type:"typed",dataType:r.dataType,data:l,length:e.length})}else this.columns.set(r.name,{type:"array",dataType:r.dataType,data:Array.isArray(e)?e:Array.from(e),length:e.length})}}build(){if(this._useBinary&&this.rowCount>0)try{return this.buildBinary()}catch(n){console.warn("[LanceFileWriter] Binary build failed, falling back to JSON:",n)}let t={format:"json",schema:this.schema,columns:{},rowCount:this.rowCount};for(let[n,r]of this.columns)r.type==="typed"?t.columns[n]=Array.from(r.data.subarray(0,r.length)):t.columns[n]=r.data;return q.encode(JSON.stringify(t))}};function le(u){let t=new DataView(u.buffer||u),n=new Uint8Array(u.buffer||u),r=0;if(t.getUint32(r,!1)!==1279348291)return null;r+=4;let o=t.getUint32(r,!1);r+=4;let l=t.getUint32(r,!1);r+=4;let s=t.getUint32(r,!1);r+=4;let a=[],i={};for(let c=0;c<l;c++){let f=t.getUint32(r,!1);r+=4;let h=ee.decode(n.subarray(r,r+f));r+=f;let p=t.getUint8(r);r+=1;let m=(8-(r+4)%8)%8;r+=m;let d=t.getUint32(r,!1);r+=4;let g=n.subarray(r,r+d);r+=d;let w,A;try{switch(p){case Pe:A="int32",g.byteOffset%4!==0?w=new Int32Array(g.slice().buffer):w=new Int32Array(g.buffer,g.byteOffset,g.byteLength/4);break;case je:A="float32",g.byteOffset%4!==0?w=new Float32Array(g.slice().buffer):w=new Float32Array(g.buffer,g.byteOffset,g.byteLength/4);break;case Ke:A="float64",g.byteOffset%8!==0?w=new Float64Array(g.slice().buffer):w=new Float64Array(g.buffer,g.byteOffset,g.byteLength/8);break;case He:A="int64",g.byteOffset%8!==0?w=new BigInt64Array(g.slice().buffer):w=new BigInt64Array(g.buffer,g.byteOffset,g.byteLength/8);break;case Ae:case Se:default:A=p===Se?"bool":"string",w=JSON.parse(ee.decode(g));break}}catch(y){throw console.error(`[LanceQLWorker] Error parsing column '${h}' (type ${p}, len ${d}):`,y),y}a.push({name:h,dataType:A}),i[h]=w}return{schema:a,columns:i,rowCount:s,format:"binary"}}var re=class{constructor(t=512*1024*1024){this.maxBytes=t,this.currentBytes=0,this.cache=new Map,this.head=null,this.tail=null}get(t){let n=this.cache.get(t);if(n)return this._moveToHead(n),n.value}set(t,n,r=0){let e=this.cache.get(t);if(e)this.currentBytes-=e.size,this.currentBytes+=r,e.value=n,e.size=r,this._moveToHead(e);else{let o={key:t,value:n,size:r,prev:null,next:null};this.cache.set(t,o),this._addToHead(o),this.currentBytes+=r}this._evictIfNeeded()}has(t){return this.cache.has(t)}delete(t){let n=this.cache.get(t);n&&(this._removeNode(n),this.cache.delete(t),this.currentBytes-=n.size)}clear(){this.cache.clear(),this.head=null,this.tail=null,this.currentBytes=0}_moveToHead(t){t!==this.head&&(this._removeNode(t),this._addToHead(t))}_addToHead(t){t.next=this.head,t.prev=null,this.head&&(this.head.prev=t),this.head=t,this.tail||(this.tail=t)}_removeNode(t){t.prev?t.prev.next=t.next:this.head=t.next,t.next?t.next.prev=t.prev:this.tail=t.prev}_evictIfNeeded(){for(;this.currentBytes>this.maxBytes&&this.tail;){let t=this.tail;this._removeNode(t),this.cache.delete(t.key),this.currentBytes-=t.size}}static estimateSize(t){return t?t.byteLength?t.byteLength:Array.isArray(t)?t.length*100:t.buffer&&t.buffer.byteLength?t.buffer.byteLength:1e3:0}};var Te=new Map,at=1,oe=class{constructor(t,n){this.name=t,this.tables=new Map,this.version=0,this.manifestKey=`${t}/__manifest__`,this.bufferPool=n||new re,this._writeBuffer=new Map,this._flushTimer=null,this._flushInterval=2e3,this._flushThreshold=1e4,this._columnarBuffer=new Map,this._flushing=!1,this._readCache=new Map,this._columnarCache=new Map}async open(){let t=await U.load(this.manifestKey);if(t){let n=JSON.parse(ee.decode(t));this.version=n.version||0,this.tables=new Map(Object.entries(n.tables||{}));for(let[r,e]of this.tables)await this._getLatestVersion(r)===0&&e.fragments?.length>0&&await this._createVersion(r,"MIGRATE")}return this}async _saveManifest(){this.version++;let t={version:this.version,timestamp:Date.now(),tables:Object.fromEntries(this.tables)},n=q.encode(JSON.stringify(t));await U.save(this.manifestKey,n)}async _getLatestVersion(t){let n=`${this.name}/${t}/_latest`;try{let r=await U.load(n);return r?parseInt(ee.decode(r),10):0}catch{return 0}}async _setLatestVersion(t,n){let r=`${this.name}/${t}/_latest`;await U.save(r,q.encode(String(n)))}async _loadTableVersion(t,n){let r=`${this.name}/${t}/_versions/${n}.manifest`,e=await U.load(r);if(!e)throw new Error(`Version ${n} not found for table '${t}'`);return JSON.parse(ee.decode(e))}async _saveTableVersion(t,n){let r=`${this.name}/${t}/_versions/${n.version}.manifest`;await U.save(r,q.encode(JSON.stringify(n)))}async _createVersion(t,n){let r=this.tables.get(t);if(!r)return 0;let e=await this._getLatestVersion(t),o=e+1,l={version:o,timestamp:Date.now(),parentVersion:e,operation:n,schema:r.schema,fragments:[...r.fragments],deletionVector:[...r.deletionVector],rowCount:r.rowCount,nextRowId:r.nextRowId};return await this._saveTableVersion(t,l),await this._setLatestVersion(t,o),o}async listVersions(t){let n=await this._getLatestVersion(t),r=[];for(let e=1;e<=n;e++)try{let o=await this._loadTableVersion(t,e);r.push({version:o.version,timestamp:o.timestamp,operation:o.operation,rowCount:o.rowCount})}catch{}return r}async selectAtVersion(t,n,r={}){let e=await this._loadTableVersion(t,n),o=new Set(e.deletionVector),l=this.tables.get(t),s=[];for(let c of e.fragments){let f=await U.load(c);if(f){let h=this._parseFragment(f,e.schema);for(let p of h)o.has(p.__rowId)||s.push(p)}}let a=s;if(r.where&&(a=a.filter(r.where)),r.orderBy){let{column:c,desc:f}=r.orderBy;a.sort((h,p)=>{let m=h[c]<p[c]?-1:h[c]>p[c]?1:0;return f?-m:m})}r.offset&&(a=a.slice(r.offset)),r.limit&&(a=a.slice(0,r.limit));let i=r.columns&&r.columns.length>0&&r.columns[0]!=="*"?r.columns:null;return a.map(c=>{if(i){let f={};for(let h of i)f[h]=c[h];return f}else{let{__rowId:f,...h}=c;return h}})}async restoreToVersion(t,n){let r=await this._loadTableVersion(t,n),e=await this._getLatestVersion(t),o=e+1,l={...r,version:o,timestamp:Date.now(),parentVersion:e,operation:`RESTORE_FROM_${n}`};await this._saveTableVersion(t,l),await this._setLatestVersion(t,o);let s=this.tables.get(t);return s&&(s.fragments=[...r.fragments],s.deletionVector=[...r.deletionVector],s.rowCount=r.rowCount,s.nextRowId=r.nextRowId,this._columnarBuffer.delete(t),this._writeBuffer.delete(t),await this._saveManifest()),{restored:!0,newVersion:o}}async createTable(t,n,r=!1){if(this.tables.has(t)){if(r)return{success:!0,existed:!0};throw new Error(`Table '${t}' already exists`)}let e=n.map(l=>({name:l.name,type:De[(l.dataType||l.type)?.toUpperCase()]||l.dataType||l.type||"string",primaryKey:l.primaryKey||!1,vectorDim:l.vectorDim||null})),o={name:t,schema:e,fragments:[],deletionVector:[],rowCount:0,nextRowId:0,version:0,createdAt:Date.now()};return this.tables.set(t,o),await this._saveManifest(),await this._createVersion(t,"CREATE"),{success:!0,table:t}}async dropTable(t,n=!1){if(!this.tables.has(t)){if(n)return this._writeBuffer.delete(t),{success:!0,existed:!1};throw new Error(`Table '${t}' does not exist`)}let r=this.tables.get(t);this._writeBuffer.delete(t);for(let e of r.fragments)this._readCache.delete(e),await U.delete(e);return this.tables.delete(t),await this._saveManifest(),{success:!0,table:t}}async insert(t,n){if(!this.tables.has(t))throw new Error(`Table '${t}' does not exist`);let r=this.tables.get(t),e=n.length;if(!this._columnarBuffer.has(t)){let a=Math.max(1024,e*2),i={__rowId:new Float64Array(a),__length:0,__capacity:a,__schema:r.schema};for(let c of r.schema){let f=(c.dataType||c.type||"").toLowerCase();f==="text"||f==="string"||f==="varchar"?i[c.name]=new Array(a):f==="int64"||f==="bigint"?i[c.name]=new BigInt64Array(a):i[c.name]=new Float64Array(a)}this._columnarBuffer.set(t,i)}let o=this._columnarBuffer.get(t),l=o.__length,s=o.__capacity;if(l+e>s){let a=Math.max(s*2,l+e),i=new Float64Array(a);i.set(o.__rowId.subarray(0,l)),o.__rowId=i;for(let c of r.schema){let f=o[c.name];if(f instanceof Float64Array){let h=new Float64Array(a);h.set(f.subarray(0,l)),o[c.name]=h}else if(f instanceof BigInt64Array){let h=new BigInt64Array(a);h.set(f.subarray(0,l)),o[c.name]=h}else o[c.name].length=a}o.__capacity=a}for(let a=0;a<e;a++){let i=n[a];o.__rowId[l+a]=r.nextRowId++;for(let c of r.schema){let f=i[c.name];o[c.name]instanceof Float64Array?o[c.name][l+a]=f!=null?Number(f):NaN:o[c.name]instanceof BigInt64Array?o[c.name][l+a]=f!=null?BigInt(f):0n:o[c.name][l+a]=f??null}}return o.__length=l+e,r.rowCount+=e,r.version=(r.version||0)+1,this._scheduleFlush(),o.__length>=this._flushThreshold&&await this._flushTable(t),{success:!0,inserted:e}}_scheduleFlush(){this._flushTimer||(this._flushTimer=setTimeout(()=>{this._flushTimer=null,this.flush().catch(t=>console.warn("[WorkerDatabase] Flush error:",t))},this._flushInterval))}async flush(){if(!this._flushing){this._flushing=!0;try{let t=[...this._columnarBuffer.keys()];for(let n of t)await this._flushTable(n)}finally{this._flushing=!1}}}async _flushTable(t){let n=this._columnarBuffer.get(t),r=n?.__length||0;if(!n||r===0)return;let e=this.tables.get(t);if(!e)return;let o=[{name:"__rowId",type:"int64",dataType:"float64",primaryKey:!0},...e.schema.filter(c=>c.name!=="__rowId").map(c=>{let f=(c.dataType||c.type||"").toLowerCase();return f==="int64"||f==="bigint"?{...c,dataType:"int64"}:{...c,dataType:f==="float64"||f==="float32"||f==="int32"||f==="integer"||f==="real"||f==="double"?"float64":c.dataType||c.type||"float64"}})],l={};for(let c of o){let f=n[c.name];f&&(f instanceof Float64Array||f instanceof BigInt64Array?l[c.name]=f.subarray(0,r):l[c.name]=f.slice(0,r))}n.__length=0;let s=new ge(o);s.setColumnarData(l);let a=s.build(),i=`${this.name}/${t}/frag_${Date.now()}_${Math.random().toString(36).slice(2)}.lance`;await U.save(i,a),e.fragments.push(i),await this._saveManifest(),await this._createVersion(t,"INSERT")}async delete(t,n){if(!this.tables.has(t))throw new Error(`Table '${t}' does not exist`);let r=this.tables.get(t),e=0,o=this._columnarBuffer.get(t),l=o?.__length||0;if(o&&l>0){let s=r.schema.map(a=>a.name);for(let a=0;a<l;a++){let i={__rowId:o.__rowId[a]};for(let c of s){let f=o[c][a];i[c]=Number.isNaN(f)?null:f}n(i)&&(r.deletionVector.includes(o.__rowId[a])||(r.deletionVector.push(o.__rowId[a]),e++))}}for(let s of r.fragments){let a=await U.load(s);if(a){let i=this._parseFragment(a,r.schema);for(let c of i)!r.deletionVector.includes(c.__rowId)&&n(c)&&(r.deletionVector.push(c.__rowId),e++)}}return r.rowCount-=e,r.version=(r.version||0)+1,await this._saveManifest(),e>0&&await this._createVersion(t,"DELETE"),{success:!0,deleted:e}}async update(t,n,r){if(!this.tables.has(t))throw new Error(`Table '${t}' does not exist`);let e=this.tables.get(t),o=0,l=this._writeBuffer.get(t);if(l&&l.length>0)for(let a of l)r(a)&&(Object.assign(a,n),o++);let s=[];for(let a of e.fragments){let i=await U.load(a);if(i){let c=this._parseFragment(i,e.schema);for(let f of c)if(!e.deletionVector.includes(f.__rowId)&&r(f)){e.deletionVector.push(f.__rowId),e.rowCount--;let h={...f,...n};delete h.__rowId,s.push(h),o++}}}return s.length>0?await this.insert(t,s):await this._saveManifest(),o>0&&s.length===0&&await this._createVersion(t,"UPDATE"),{success:!0,updated:o}}async updateWithExpr(t,n,r,e){if(!this.tables.has(t))throw new Error(`Table '${t}' does not exist`);let o=this.tables.get(t),l=0,s=this._columnarBuffer.get(t),a=s?.__length||0;if(s&&a>0){let c=o.schema.map(f=>f.name);for(let f=0;f<a;f++){let h={__rowId:s.__rowId[f]};for(let p of c){let m=s[p][f];h[p]=Number.isNaN(m)?null:m}if(r(h)){for(let[p,m]of Object.entries(n)){let d=e(m,h);s[p]!==void 0&&(s[p][f]=d??(s[p]instanceof Float64Array?NaN:null))}o.version=(o.version||0)+1,l++}}}let i=[];for(let c of o.fragments){let f=await U.load(c);if(f){let h=this._parseFragment(f,o.schema);for(let p of h)if(!o.deletionVector.includes(p.__rowId)&&r(p)){o.deletionVector.push(p.__rowId),o.rowCount--;let m={...p};for(let[d,g]of Object.entries(n))m[d]=e(g,p);delete m.__rowId,i.push(m),l++}}}return i.length>0?await this.insert(t,i):await this._saveManifest(),l>0&&i.length===0&&await this._createVersion(t,"UPDATE"),{success:!0,updated:l}}async select(t,n={}){if(!this.tables.has(t))throw new Error(`Table '${t}' does not exist`);let r=await this._readAllRows(t);if(n.where&&(r=r.filter(n.where)),n.orderBy){let{column:l,desc:s}=n.orderBy;r.sort((a,i)=>{let c=a[l]<i[l]?-1:a[l]>i[l]?1:0;return s?-c:c})}n.offset&&(r=r.slice(n.offset)),n.limit&&(r=r.slice(0,n.limit));let e=n.columns&&n.columns.length>0&&n.columns[0]!=="*"?n.columns:null,o=new Array(r.length);for(let l=0;l<r.length;l++){let s=r[l];if(e){let a={};for(let i of e)a[i]=s[i];o[l]=a}else{let{__rowId:a,...i}=s;o[l]=i}}return o}async _readAllRows(t){let n=this.tables.get(t),r=this._columnarBuffer.get(t),o=n.deletionVector.length>0?new Set(n.deletionVector):null,l=[];for(let a of n.fragments){let i=this.bufferPool.get(a),c=null;if(!i){let f=await U.load(a);f&&(i=le(f),i?this.bufferPool.set(a,i,f.byteLength):c=this._parseFragment(f,n.schema))}if(i&&!c&&(c=this._hydrateRowsFromBinary(i,n.schema)),c=c||[],!o)l.push(...c);else for(let f of c)o.has(f.__rowId)||l.push(f)}let s=r?.__length||0;if(r&&s>0){let a=n.schema.map(i=>i.name);for(let i=0;i<s;i++){if(o&&o.has(r.__rowId[i]))continue;let c={__rowId:r.__rowId[i]};for(let f of a){let h=r[f][i];c[f]=Number.isNaN(h)?null:h}l.push(c)}}return l}_hydrateRowsFromBinary(t,n){let{columns:r,rowCount:e}=t,o=n.map(s=>s.name),l=new Array(e);for(let s=0;s<e;s++){let a={__rowId:r.__rowId[s]};for(let i of o)r[i]&&(a[i]=r[i][s]);l[s]=a}return l}_parseFragment(t,n){try{let r=le(t);if(r)return this._parseBinaryColumnar(r);let e=ee.decode(t),o=JSON.parse(e);return o.format==="json"&&o.columns?this._parseJsonColumnar(o):Array.isArray(o)?o:[o]}catch(r){return console.warn("[WorkerDatabase] Failed to parse fragment:",r),[]}}async selectColumnar(t){let n=this.tables.get(t);if(!n)return null;let r=this._columnarBuffer.get(t)?.__length||0,e=`${n.fragments.length}:${r}:${n.deletionVector.length}:${n.version||0}`,o=this._columnarCache.get(t);if(o&&o.version===e){let d={};for(let[g,w]of Object.entries(o.data.columns))ArrayBuffer.isView(w)?d[g]=new w.constructor(w.buffer,w.byteOffset,w.length):d[g]=w;return{schema:n.schema,columns:d,rowCount:o.data.rowCount}}let s=n.deletionVector.length>0?new Set(n.deletionVector):null,a={},i=n.schema.map(d=>d.name);for(let d of i)a[d]=[];a.__rowId=[];for(let d of n.fragments){let g=this.bufferPool.get(d);if(!g){let y=await U.load(d);if(!y)continue;g=le(y),g&&this.bufferPool.set(d,g,y.byteLength)}if(!g)continue;let{columns:w,rowCount:A}=g;if(s){let y=w.__rowId,b=[];for(let F=0;F<A;F++)s.has(y[F])||b.push(F);for(let F of i)if(w[F]){let S=w[F],_=new S.constructor(b.length);for(let T=0;T<b.length;T++)_[T]=S[b[T]];a[F].push(_)}}else{for(let y of i)w[y]&&a[y].push(w[y]);w.__rowId&&a.__rowId.push(w.__rowId)}}let c=this._columnarBuffer.get(t),f=c?.__length||0;if(c&&f>0)if(s){let d=[];for(let A=0;A<f;A++)s.has(c.__rowId[A])||d.push(A);let g=d.length;for(let A of n.schema){let y=c[A.name];if(y)if(y instanceof Float64Array){let b=new Float64Array(g);for(let F=0;F<g;F++)b[F]=y[d[F]];a[A.name].push(b)}else a[A.name].push(d.map(b=>y[b]))}let w=new Float64Array(g);for(let A=0;A<g;A++)w[A]=c.__rowId[d[A]];a.__rowId.push(w)}else{for(let g of n.schema){let w=c[g.name];if(w)if(w instanceof Float64Array){let A=new Float64Array(f);A.set(w.subarray(0,f)),a[g.name].push(A)}else a[g.name].push(w.slice(0,f))}let d=new Float64Array(f);d.set(c.__rowId.subarray(0,f)),a.__rowId.push(d)}let h={},p=0;for(let d of[...i,"__rowId"]){let g=a[d];if(g.length===0)h[d]=new Float64Array(0);else if(g.length===1)h[d]=g[0],p===0&&(p=g[0].length);else{let w=g.reduce((F,S)=>F+S.length,0);p===0&&(p=w);let A=g[0],y=ArrayBuffer.isView(A)?new A.constructor(w):new Array(w),b=0;for(let F of g){if(ArrayBuffer.isView(y))y.set(F,b);else for(let S=0;S<F.length;S++)y[b+S]=F[S];b+=F.length}h[d]=y}}let m={schema:n.schema,columns:h,rowCount:p};return this._columnarCache.set(t,{version:e,data:m}),m}async _readColumn(t,n){let r=this.tables.get(t);if(!r)return null;let e=this._writeBuffer.get(t),o=[];for(let i of r.fragments){let c=await U.load(i);if(!c)continue;let f=le(c);if(f&&f.columns[n]){let h=f.columns[n];h.length>0&&o.push(h)}}if(e&&e.length>0){let i=new Float64Array(e.length);for(let c=0;c<e.length;c++){let f=e[c][n];i[c]=typeof f=="number"?f:0}o.push(i)}if(o.length===0)return new Float64Array(0);if(o.length===1)return o[0];let l=o.reduce((i,c)=>i+c.length,0),s=new Float64Array(l),a=0;for(let i of o)s.set(i,a),a+=i.length;return s}_parseBinaryColumnar(t){let{schema:n,columns:r,rowCount:e}=t,o=new Array(e),l=n.map(i=>i.name),s=l.map(i=>r[i]),a=l.length;for(let i=0;i<e;i++){let c={};for(let f=0;f<a;f++)c[l[f]]=s[f][i]??null;o[i]=c}return o}_parseJsonColumnar(t){let{schema:n,columns:r,rowCount:e}=t,o=new Array(e),l=n.map(i=>i.name),s=l.map(i=>r[i]||[]),a=l.length;for(let i=0;i<e;i++){let c={};for(let f=0;f<a;f++)c[l[f]]=s[f][i]??null;o[i]=c}return o}getTable(t){return this.tables.get(t)}listTables(){return Array.from(this.tables.keys())}getFragmentPaths(t){let n=this.tables.get(t);return n?n.fragments:[]}getColumnIndex(t,n){let r=this.tables.get(t);if(!r)return-1;let e=r.schema.findIndex(o=>o.name===n);return e>=0?e+1:-1}hasBufferedData(t){let n=this._columnarBuffer.get(t);return n&&(n.__length||0)>0}async compact(){for(let[t,n]of this.tables){let r=await this._readAllRows(t);for(let e of n.fragments)await U.delete(e);if(n.fragments=[],n.deletionVector=[],n.rowCount=0,n.nextRowId=0,r.length>0){let e=r.map(({__rowId:o,...l})=>l);await this.insert(t,e)}}return{success:!0,compacted:this.tables.size}}async scanStart(t,n={}){if(!this.tables.has(t))throw new Error(`Table '${t}' does not exist`);let r=at++,e=this.tables.get(t),o=new Set(e.deletionVector),l=[];for(let a of e.fragments){let i=await U.load(a);if(i){let c=this._parseFragment(i,e.schema);for(let f of c)o.has(f.__rowId)||l.push(f)}}let s=this._writeBuffer.get(t);if(s)for(let a of s)o.has(a.__rowId)||l.push(a);return Te.set(r,{rows:l,index:0,batchSize:n.batchSize||1e4,columns:n.columns}),r}scanNext(t){let n=Te.get(t);if(!n)return{batch:[],done:!0};let r=[],e=Math.min(n.index+n.batchSize,n.rows.length);for(let l=n.index;l<e;l++){let s=n.rows[l],a;if(n.columns&&n.columns.length>0&&n.columns[0]!=="*"){a={};for(let i of n.columns)a[i]=s[i]}else{let{__rowId:i,...c}=s;a=c}r.push(a)}n.index=e;let o=n.index>=n.rows.length;return o&&Te.delete(t),{batch:r,done:o}}};var we=class{constructor(){this._root=null,this._ready=!1,this._kv={},this._encryptionKeyId=null,this._db=null}async open(t=null){if(this._ready)return this;if(t){let{keyId:n,keyBytes:r}=t;if(!Y.has(n)){let e=await fe(r);Y.set(n,e)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle("vault",{create:!0}),await this._loadKV(),this._db=new oe("vault"),await this._db.open(),this._ready=!0}catch(n){throw console.error("[WorkerVault] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?Y.get(this._encryptionKeyId):null}async _loadKV(){try{let t=this._getCryptoKey(),n=t?"_vault.json.enc":"_vault.json",e=await(await this._root.getFileHandle(n)).getFile();if(t){let o=await e.arrayBuffer();this._kv=await he(new Uint8Array(o),t)}else{let o=await e.text();this._kv=JSON.parse(o)}}catch(t){if(t.name==="NotFoundError")this._kv={};else throw t}}async _saveKV(){let t=this._getCryptoKey(),n=t?"_vault.json.enc":"_vault.json",e=await(await this._root.getFileHandle(n,{create:!0})).createWritable();if(t){let o=await ue(this._kv,t);await e.write(o)}else await e.write(JSON.stringify(this._kv));await e.close()}async get(t){return this._kv[t]}async set(t,n){this._kv[t]=n,await this._saveKV()}async delete(t){delete this._kv[t],await this._saveKV()}async keys(){return Object.keys(this._kv)}async has(t){return t in this._kv}};var it=1;var ze={INT64:0,FLOAT64:1,INT32:2,FLOAT32:3,STRING:4,LIST:5},$e=class{constructor(){this._registered=new Map}getLastError(){let t=Q();if(!t)return"WASM not loaded";let n=t.alloc(4096);console.log(`[WASM LOG] getLastError alloc ptr: ${n}`);let r=t.getLastError(n,4096);if(console.log(`[WASM LOG] getLastError len: ${r}`),r===0)return"Unknown Error";let e=new Uint8Array(j().buffer,n,r),o=new TextDecoder().decode(e);return console.log(`[WASM LOG] getLastError msg: ${o}`),o}getTableNames(t){let n=Q();if(!n)throw new Error("WASM not loaded");let r=new TextEncoder().encode(t),e=n.alloc(r.length);new Uint8Array(j().buffer,e,r.length).set(r);let o=n.getTableNames(e,r.length);if(o===0)return[];let l=new Uint8Array(j().buffer,o),s=0;for(;l[s]!==0&&s<1024;)s++;let a=new TextDecoder().decode(l.subarray(0,s));return a?a.split(",").filter(i=>i):[]}hasTable(t){let n=Q();if(!n)return!1;let r=new TextEncoder().encode(t),e=n.alloc(r.length);return new Uint8Array(j().buffer,e,r.length).set(r),n.hasTable(e,r.length)===1}registerTable(t,n,r,e=""){let o=Q();if(!o)throw new Error("WASM not loaded");let l=this._registered.get(t);if(l&&l.version===e)return;if(l){let f=new TextEncoder().encode(t);o.clearTable(f,f.length)}let s=()=>j().buffer;if(!s())throw new Error("WASM memory not available");let a=new TextEncoder().encode(t),i=o.alloc(a.length);if(i<0||i>=s().byteLength)throw new Error(`Invalid alloc result: ${i} for ${a.length} bytes`);new Uint8Array(s(),i,a.length).set(a);let c=new Set;for(let[f,h]of Object.entries(n)){if(f.startsWith("__")||Array.isArray(h)&&h.length===0)continue;let p=new TextEncoder().encode(f),m=o.alloc(p.length);if(m<0||m>=s().byteLength)throw new Error(`Invalid colName alloc: ${m}`);if(new Uint8Array(s(),m,p.length).set(p),h instanceof Float64Array){let d=o.allocFloat64Buffer(h.length);if(d===0||d<0||d>=s().byteLength)throw new Error(`Invalid Float64 alloc: ${d} for ${h.length} elements`);new Float64Array(s(),d,h.length).set(h),o.registerTableFloat64(i,a.length,m,p.length,d,h.length),c.add(f)}else if(h instanceof BigInt64Array){let d=o.allocInt64Buffer(h.length);new BigInt64Array(s(),d,h.length).set(h),o.registerTableInt64(i,a.length,m,p.length,d,h.length),c.add(f)}else if(h instanceof Int32Array){let d=new Float64Array(h.length);for(let w=0;w<h.length;w++)d[w]=h[w];let g=o.allocFloat64Buffer(d.length);new Float64Array(s(),g,d.length).set(d),o.registerTableFloat64(i,a.length,m,p.length,g,d.length),c.add(f)}else if(h instanceof Float32Array){let d=`__${f}_dim`,g=n[d]||0,w=g>0?Math.floor(h.length/g):h.length,A=o.allocFloat32Buffer?o.allocFloat32Buffer(h.length):null;A?(new Float32Array(s(),A,h.length).set(h),o.registerTableFloat32Vector?(o.registerTableFloat32Vector(i,a.length,m,p.length,A,w,g),console.log(`[Bridge] Registered vector column ${f}: ${w} rows, dim=${g}`)):console.warn(`[Bridge] No registerTableFloat32Vector, skipping ${f}`),c.add(f)):console.warn(`[Bridge] Failed to alloc Float32 buffer for ${f}`)}else if(Array.isArray(h)){let d=new Uint32Array(h.length),g=new Uint32Array(h.length),w=new TextEncoder,A=[],y=0;for(let $=0;$<h.length;$++){let B=String(h[$]||""),E=w.encode(B);A.push(E),g[$]=E.length,d[$]=y,y+=E.length}let b=new Uint8Array(y),F=0;for(let $=0;$<A.length;$++)b.set(A[$],F),F+=A[$].length;let S=o.alloc(d.byteLength);if(S<0||S>=s().byteLength)throw new Error(`Invalid offsetsPtr alloc: ${S}`);new Uint32Array(s(),S,d.length).set(d);let _=o.alloc(g.byteLength);if(_<0||_>=s().byteLength)throw new Error(`Invalid lengthsPtr alloc: ${_}`);new Uint32Array(s(),_,g.length).set(g);let T=o.alloc(b.length||1);if(T<0||T>=s().byteLength)throw new Error(`Invalid dataPtr alloc: ${T}`);new Uint8Array(s(),T,b.length).set(b),o.registerTableString(i,a.length,m,p.length,S,_,T,y,h.length),c.add(f)}}this._registered.set(t,{version:e,columns:c,rowCount:r})}aliasTable(t,n){let r=Q();if(!r)throw new Error("WASM not loaded");let e=new TextEncoder,o=e.encode(t),l=e.encode(n),s=r.alloc(o.length),a=r.alloc(l.length),i=j().buffer;new Uint8Array(i,s,o.length).set(o),new Uint8Array(i,a,l.length).set(l),r.aliasTable&&r.aliasTable(s,o.length,a,l.length);let c=this._registered.get(t);c&&this._registered.set(n,{...c,aliasOf:t})}registerTableFromFiles(t,n,r=""){let e=Q();if(!e)throw new Error("WASM not loaded");let o=this._registered.get(t);if(o&&o.version===r)return;if(o){let i=new TextEncoder().encode(t);e.clearTable(i,i.length)}let l=new TextEncoder,s=l.encode(t),a=e.alloc(s.length);new Uint8Array(j().buffer,a,s.length).set(s);for(let i of n){let c=l.encode(i),f=e.alloc(c.length);new Uint8Array(j().buffer,f,c.length).set(c);let h=e.registerTableFromOPFS(a,s.length,f,c.length);h!==0&&console.warn(`Failed to register fragment ${i} for table ${t}: error ${h}`)}this._registered.set(t,{version:r,type:"files"})}appendTableMemory(t,n,r){let e=Q();if(!e)throw new Error("WASM not loaded");let o=()=>j().buffer,l=new TextEncoder().encode(t),s=e.alloc(l.length);new Uint8Array(o(),s,l.length).set(l);for(let[a,i]of Object.entries(n)){if(a.startsWith("__"))continue;let c=new TextEncoder().encode(a),f=e.alloc(c.length);if(new Uint8Array(o(),f,c.length).set(c),i instanceof Float64Array){let h=e.allocFloat64Buffer(i.length);new Float64Array(o(),h,i.length).set(i),e.appendTableMemory(s,l.length,f,c.length,h,4,r)}else if(i instanceof BigInt64Array){let h=e.allocInt64Buffer(i.length);new BigInt64Array(o(),h,i.length).set(i),e.appendTableMemory(s,l.length,f,c.length,h,2,r)}else if(i instanceof Int32Array){let h=e.alloc(i.byteLength);new Int32Array(o(),h,i.length).set(i),e.appendTableMemory(s,l.length,f,c.length,h,1,r)}else if(i instanceof Float32Array){let h=e.alloc(i.byteLength);new Float32Array(o(),h,i.length).set(i),e.appendTableMemory(s,l.length,f,c.length,h,3,r)}}}execute(t){let n=Q();if(!n)throw new Error("WASM not loaded");if(n.setCurrentTimestamp)try{n.setCurrentTimestamp(BigInt(Date.now()))}catch(c){console.warn("setCurrentTimestamp failed:",c)}let r=n.getSqlInputBuffer(),e=n.getSqlInputBufferSize(),o=new TextEncoder().encode(t);if(o.length>e)throw new Error(`SQL too long: ${o.length} > ${e}`);new Uint8Array(j().buffer,r,o.length).set(o),n.setSqlInputLength(o.length);let l=n.executeSql();if(l===0){let c=this.getLastError();throw console.log(`[WASM LOG] execute throwing: "${c}"`),new Error(c)}let s=n.getResultSize(),a=this.getLastError();a&&a.length>0&&console.log(`[WASM DEBUG CAPTURED] ${a}`),a.length>0&&a.startsWith("DEBUG:");let i=this._parseResult(j().buffer,l,s);return n.resetResult(),i}_parseResult(t,n,r){let e=new DataView(t,n,r),o=new TextDecoder;if(r>=40){let l=r-40,s=[e.getUint8(l+36),e.getUint8(l+37),e.getUint8(l+38),e.getUint8(l+39)];if(String.fromCharCode(...s)==="LANC")return this._parseLanceResult(t,n,r,l,e,o)}if(r>=36&&e.getUint32(0,!0)===it)return this._parseLegacyResult(t,n,r);throw new Error(`Invalid result format (Size: ${r}). Not a Lance file.`)}_parseLanceResult(t,n,r,e,o,l){let s=Number(o.getBigUint64(e+8,!0)),a=o.getUint32(e+28,!0),i=[],c={},f=0;for(let h=0;h<a;h++){let p=s+h*8,d=Number(o.getBigUint64(p,!0));o.getUint8(d++);let[g,w]=this._readVarint(o,d);d+=w;let A=new Uint8Array(t,n+d,g),y=l.decode(A);d+=g,i.push(y),o.getUint8(d++);let[b,F]=this._readVarint(o,d);d+=F;let S=new Uint8Array(t,n+d,b),_=l.decode(S);d+=b,o.getUint8(d++);let[T,$]=this._readVarint(o,d);d+=$,o.getUint8(d++);let B=Number(o.getBigUint64(d,!0));d+=8,o.getUint8(d++);let[E,x]=this._readVarint(o,d);d+=x,f=E,o.getUint8(d++);let[k,H]=this._readVarint(o,d);d+=H;let V=n+B;if(_==="float64"||_==="int64"||_==="int32"||_==="float32")if(_==="float64"){let v=new Float64Array(t,V,E).slice(),O=!1;for(let I=0;I<E;I++)if(Number.isNaN(v[I])){O=!0;break}if(O){console.log(`[WASM LOG] Column ${y} has NaNs, converting to nulls`);let I=new Array(E);for(let C=0;C<E;C++){let W=v[C];I[C]=Number.isNaN(W)?null:W}c[y]=I}else c[y]=v}else if(_==="int64"){let v=new BigInt64Array(t,V,E),O=new Array(E),I=-9223372036854775808n;for(let C=0;C<E;C++){let W=v[C];O[C]=W===I?null:Number(W)}c[y]=O}else if(_==="int32"){let v=new Int32Array(t,V,E),O=new Array(E);for(let I=0;I<E;I++){let C=v[I];C===-2147483648?O[I]=null:O[I]=C}c[y]=O}else{let v=new Float32Array(t,V,E),O=new Array(E);for(let I=0;I<E;I++){let C=v[I];O[I]=isNaN(C)?null:C}c[y]=O}else if(_==="string"||_==="list"){let v=_==="list",O=(E+1)*4,I=k-O,C=new Uint8Array(t,V,I).slice(),W=new Uint32Array(t,V+I,E+1).slice();c[y]={_arrowString:!0,offsets:W,bytes:C,isList:_==="list",nullable:T===1}}}return{_format:"columnar",columns:i,rowCount:f,data:c}}_readVarint(t,n){let r=0,e=0,o=0;for(;;){let l=t.getUint8(n+o);if(o++,r|=(l&127)<<e,(l&128)===0)break;e+=7}return[r,o]}_parseLegacyResult(t,n,r){let e=new DataView(t,n,r),o=new TextDecoder,l=e.getUint32(4,!0),s=Number(e.getBigUint64(8,!0)),a=e.getUint32(24,!0),i=e.getUint32(32,!0),c=[],f={};for(let h=0;h<l;h++){let p=36+h*16,m=e.getUint32(p,!0),d=e.getUint32(p+4,!0),g=e.getUint32(p+8,!0),w=e.getUint32(p+12,!0),A=new Uint8Array(t,n+i+d,g),y=o.decode(A);c.push(y);let b=Object.keys(ze).find(S=>ze[S]===m).toLowerCase(),F=n+a+w;if(b==="float64"||b==="int64"||b==="int32"||b==="float32")b==="float64"?f[y]=new Float64Array(t,F,s).slice():b==="int64"?f[y]=new Float64Array(t,F,s).slice():b==="int32"?f[y]=new Int32Array(t,F,s).slice():b==="float32"&&(f[y]=new Float32Array(t,F,s).slice());else if(b==="string"||b==="list"){let S=new Uint32Array(s+1),_=0;S[0]=0;let T=F,$=0;for(let x=0;x<s;x++){let k=e.getUint32(T+x*8+4,!0);$+=k,S[x+1]=$}let B=F+s*8,E=new Uint8Array(t,B,$).slice();f[y]={_arrowString:!0,offsets:S,bytes:E,isList:b==="list"}}}return{_format:"columnar",columns:c,rowCount:s,data:f}}clear(){let t=Q();t&&t.clearTables(),this._registered.clear()}},Fe=null;function Le(){return Fe||(Fe=new $e),Fe}var Ee={showVersions:/^\s*SHOW\s+VERSIONS\s+FOR\s+(\w+)\s*$/i,restoreTable:/^\s*RESTORE\s+(\w+)\s+TO\s+VERSION\s+(\d+)\s*$/i,versionAsOf:/FROM\s+(\w+)\s+VERSION\s+AS\s+OF\s+(\d+)/i};function Ge(u){let t;return(t=u.match(Ee.showVersions))?{type:"SHOW_VERSIONS",table:t[1]}:(t=u.match(Ee.restoreTable))?{type:"RESTORE_TABLE",table:t[1],version:parseInt(t[2],10)}:(t=u.match(Ee.versionAsOf))?{type:"SELECT_VERSION",table:t[1],version:parseInt(t[2],10),sql:u}:null}function lt(u){let t=/^(SELECT|FROM|WHERE|JOIN|LEFT|RIGHT|INNER|OUTER|ON|AND|OR|NOT|IN|LIKE|BETWEEN|GROUP|ORDER|BY|HAVING|LIMIT|OFFSET|UNION|EXCEPT|INTERSECT|AS|NULL|TRUE|FALSE|IS|CASE|WHEN|THEN|ELSE|END|DISTINCT|ALL|ASC|DESC|CREATE|DROP|INSERT|UPDATE|DELETE|INTO|VALUES|TABLE|INDEX|VIEW|SET|WITH|RECURSIVE)$/i,n=/read_lance\s*\(\s*'([^']+)'\s*\)(?:\s+AS\s+(\w+)|\s+(\w+))?/gi,r=[],e;for(;(e=n.exec(u))!==null;){let o=e[2],l=e[3];l&&t.test(l)&&(l=null);let s=o||l||`_tbl${r.length}`,a=e[0];e[3]&&t.test(e[3])&&(a=`read_lance('${e[1]}')`),console.log(`[Worker] extractReadLanceUrls: found "${a}" -> alias "${s}"`),r.push({fullMatch:a,url:e[1],alias:s})}return console.log(`[Worker] extractReadLanceUrls: found ${r.length} URLs`),r}function ct(u,t){let n=u;for(let{fullMatch:r,alias:e}of t)console.log(`[Worker] rewriteSqlWithAliases: replacing "${r}" with "${e}"`),n=n.replace(r,e);return console.log(`[Worker] rewriteSqlWithAliases: result = "${n}"`),n}async function ft(u,t=1e4){try{console.log(`[Worker] Fetching remote Lance: ${u}`);let n=`${u}/.meta.json`,r=null,e=[],o=[];try{let i=await fetch(n);if(i.ok){let c=await i.json();r=c.schema,e=c.fragments||[],o=r.map(f=>{let h=f.type;if(h.startsWith("vector[")){let p=h.match(/vector\[(\d+)\]/);return{type:"vector",dim:p?parseInt(p[1],10):0}}return h==="float64"||h==="double"?"float64":h==="float32"?"float32":h.includes("int64")?"int64":h.includes("int")?"int32":h==="string"?"string":"unknown"}),console.log(`[Worker] Loaded sidecar: ${r.length} columns, ${e.length} fragments`)}}catch(i){console.log(`[Worker] No sidecar available: ${i.message}`)}if(!r){let i=0,c=[1,5,10,20,50,100];for(let m of c)try{(await fetch(`${u}/_versions/${m}.manifest`,{method:"HEAD"})).ok&&(i=m)}catch{}if(i>0)for(let m=i+1;m<=i+50;m++)try{if((await fetch(`${u}/_versions/${m}.manifest`,{method:"HEAD"})).ok)i=m;else break}catch{break}if(i===0)return console.error(`[Worker] No manifest found for ${u}`),null;let f=await fetch(`${u}/_versions/${i}.manifest`);if(!f.ok)return null;let h=new Uint8Array(await f.arrayBuffer()),p=ut(h);r=p.schema,e=p.fragments,o=r.map(m=>m.type||"unknown")}if(!r||r.length===0)return console.error(`[Worker] No schema found for ${u}`),null;if(e.length===0)return console.error(`[Worker] No fragments found for ${u}`),null;let l=e[0].data_files?.[0]||`${e[0].id}.lance`,s=`${u}/data/${l}`;return await gt(s,r,o,t)}catch(n){return console.error("[Worker] Failed to fetch remote Lance:",n),null}}function ut(u){let t=new DataView(u.buffer,u.byteOffset),n=[],r=[],e=t.getUint32(0,!0),o=4+e,l;if(o+4<u.length){let c=t.getUint32(o,!0);c>0&&o+4+c<=u.length?l=u.slice(o+4,o+4+c):l=u.slice(4,4+e)}else l=u.slice(4,4+e);let s=0,a=()=>{let c=0,f=0;for(;s<l.length;){let h=l[s++];if(c|=(h&127)<<f,(h&128)===0)break;f+=7}return c},i=c=>{c===0?a():c===2?s+=a():c===5?s+=4:c===1&&(s+=8)};for(;s<l.length;){let c=a(),f=c>>3,h=c&7;if(f===1&&h===2){let p=a(),m=s+p,d=null,g=null,w=null;for(;s<m;){let A=a(),y=A>>3,b=A&7;if(b===0){let F=a();y===3&&(g=F)}else if(b===2){let F=a(),S=l.slice(s,s+F);s+=F,y===2?d=new TextDecoder().decode(S):y===5&&(w=new TextDecoder().decode(S))}else i(b)}d&&n.push({name:d,id:g,type:w})}else if(f===2&&h===2){let p=a(),m=s+p,d=null,g=null,w=0;for(;s<m;){let A=a(),y=A>>3,b=A&7;if(b===0){let F=a();y===1?d=F:y===4&&(w=F)}else if(b===2){let F=a(),S=l.slice(s,s+F);if(s+=F,y===2){let _=0;for(;_<S.length;){let T=S[_++],$=T>>3,B=T&7;if(B===2){let E=0,x=0;for(;_<S.length;){let k=S[_++];if(E|=(k&127)<<x,(k&128)===0)break;x+=7}$===1&&(g=new TextDecoder().decode(S.slice(_,_+E))),_+=E}else if(B===0)for(;_<S.length&&(S[_++]&128)!==0;);else B===5?_+=4:B===1&&(_+=8)}}}else i(b)}g&&r.push({id:d,data_files:[g],num_rows:w})}else i(h)}return{schema:n,fragments:r}}async function J(u,t,n){let r=await fetch(u,{headers:{Range:`bytes=${t}-${n}`}});if(!r.ok&&r.status!==206)throw new Error(`Range request failed: HTTP ${r.status}`);return new Uint8Array(await r.arrayBuffer())}function K(u,t){let n=0,r=0,e=0;for(;t+e<u.length;){let o=u[t+e];if(e++,n|=(o&127)<<r,(o&128)===0)break;r+=7}return{value:n,bytesRead:e}}function ht(u){let t=[],n=[],r=0,e=0;for(;e<u.length;){let{value:o,bytesRead:l}=K(u,e);e+=l;let s=o>>3,a=o&7;if(s===2&&a===2){let{value:i,bytesRead:c}=K(u,e);e+=c;let f=e+i;for(;e<f;){let{value:h,bytesRead:p}=K(u,e);e+=p;let m=h>>3,d=h&7;if(m===1&&d===2){let{value:g,bytesRead:w}=K(u,e);e+=w;let A=e+g;for(;e<A;){let{value:y,bytesRead:b}=K(u,e);e+=b,t.push(y)}}else if(m===2&&d===2){let{value:g,bytesRead:w}=K(u,e);e+=w;let A=e+g;for(;e<A;){let{value:y,bytesRead:b}=K(u,e);e+=b,n.push(y)}}else if(m===3&&d===0){let{value:g,bytesRead:w}=K(u,e);e+=w,r=g}else if(d===0){let{bytesRead:g}=K(u,e);e+=g}else if(d===2){let{value:g,bytesRead:w}=K(u,e);e+=w+g}else d===5?e+=4:d===1&&(e+=8)}break}else if(a===0){let{bytesRead:i}=K(u,e);e+=i}else if(a===2){let{value:i,bytesRead:c}=K(u,e);e+=c+i}else a===5?e+=4:a===1&&(e+=8)}return{bufferOffsets:t,bufferSizes:n,length:r}}async function dt(u,t,n,r,e){let l=await J(u,e-40,e-1),s=new DataView(l.buffer),a=String.fromCharCode(l[36],l[37],l[38],l[39]);if(a!=="LANC")throw new Error(`Invalid Lance magic: ${a}`);let i=Number(s.getBigUint64(0,!0)),c=Number(s.getBigUint64(8,!0)),f=s.getUint32(28,!0);console.log(`[Worker] Range: footer parsed - ${f} columns, metaStart=${i}, offsetsStart=${c}`);let h=f*16,p=await J(u,c,c+h-1),m=new DataView(p.buffer),d=[];for(let _=0;_<f;_++){let T=Number(m.getBigUint64(_*16,!0)),$=Number(m.getBigUint64(_*16+8,!0));d.push({pos:T,len:$})}let g=d[0]?.pos||i,w=c-1,A=await J(u,g,w),y={},b=[],F=0;for(let _=0;_<t.length&&_<f;_++){let T=t[_].name,$=n[_];b.push(T);let B=d[_].pos-g,E=d[_].len,x=A.slice(B,B+E),{bufferOffsets:k,bufferSizes:H,length:V}=ht(x);_===0&&(F=V);let v=Math.min(V,r),O=typeof $=="object"?`${$.type}[${$.dim}]`:$;console.log(`[Worker] Range: column ${_} (${T}): type=${O}, rows=${V}, buffers=${k.length}`);try{if($==="string"&&k.length>=2){let I=k[0],C=H[0],W=k[1],z=H[1],D=Math.floor(C/V),M=v*D,Xe=await J(u,I,I+M-1),Oe=new DataView(Xe.buffer),ce=[];for(let ne=0;ne<v;ne++)D===4?ce.push(Oe.getInt32(ne*4,!0)):ce.push(Number(Oe.getBigInt64(ne*8,!0)));let et=ce[v-1]||0,Re=Math.min(et,z);if(Re>0){let ne=await J(u,W,W+Re-1),tt=new TextDecoder("utf-8"),Me=[],Ue=0;for(let pe=0;pe<v;pe++){let Ne=ce[pe],nt=ne.slice(Ue,Ne);Me.push(tt.decode(nt)),Ue=Ne}y[T]=Me}else y[T]=Array(v).fill("")}else if(($==="float64"||$==="double")&&k.length>=1){let I=k[0],C=v*8,W=await J(u,I,I+C-1);y[T]=new Float64Array(W.buffer).slice(0,v)}else if($==="int64"&&k.length>=1){let I=k[0],C=v*8,W=await J(u,I,I+C-1),z=new BigInt64Array(W.buffer),D=new Float64Array(v);for(let M=0;M<v;M++)D[M]=Number(z[M]);y[T]=D}else if($==="int32"&&k.length>=1){let I=k[0],C=v*4,W=await J(u,I,I+C-1),z=new Int32Array(W.buffer),D=new Float64Array(v);for(let M=0;M<v;M++)D[M]=z[M];y[T]=D}else if($==="float32"&&k.length>=1){let I=k[0],C=v*4,W=await J(u,I,I+C-1),z=new Float32Array(W.buffer),D=new Float64Array(v);for(let M=0;M<v;M++)D[M]=z[M];y[T]=D}else if(typeof $=="object"&&$.type==="vector"&&$.dim>0&&k.length>=1){let I=$.dim,C=k[0],W=v*I,z=W*4;console.log(`[Worker] Range: Reading vector ${T}: dim=${I}, rows=${v}, bytes=${z}`);let D=await J(u,C,C+z-1),M=new Float32Array(D.buffer,0,W);y[T]=M.slice(),y[`__${T}_dim`]=I}else $==="vector"||typeof $=="string"&&($.includes("list")||$.includes("vector"))?y[T]=new Float32Array(0):y[T]=new Float64Array(v).fill(0)}catch(I){console.warn(`[Worker] Range: Failed to read column ${T}: ${I.message}`),$==="string"?y[T]=Array(v).fill(""):y[T]=new Float64Array(v).fill(0)}}let S=Math.min(F,r);return console.log(`[Worker] Range: Read ${S} rows from ${b.length} columns via HTTP Range requests`),{columns:y,rowCount:S,columnNames:b}}async function gt(u,t,n,r){if(console.log(`[Worker] Fetching fragment: ${u}`),!L&&(await X(),!L))throw new Error("WASM not loaded");let e=await fetch(u,{method:"HEAD"});if(!e.ok)throw new Error(`Failed to check fragment size: HTTP ${e.status}`);let o=parseInt(e.headers.get("Content-Length")||"0",10),l=100*1024*1024;if(o>l)return console.log(`[Worker] Large fragment (${(o/1024/1024).toFixed(1)}MB) - using HTTP Range requests`),await dt(u,t,n,r,o);let s=await fetch(u);if(!s.ok)throw new Error(`Failed to fetch fragment: HTTP ${s.status}`);let a=new Uint8Array(await s.arrayBuffer());if(console.log(`[Worker] Fetched fragment: ${a.length} bytes`),a.length<40)throw new Error("Fragment too small");let i=String.fromCharCode(a[a.length-4],a[a.length-3],a[a.length-2],a[a.length-1]);if(i!=="LANC")throw new Error(`Invalid Lance magic: ${i}`);let c=L.alloc(a.length);if(!c||c<0)throw new Error("Failed to allocate WASM memory for fragment");new Uint8Array(R.buffer,c,a.length).set(a);let f=L.openFile(c,a.length);if(f!==0)throw new Error(`WASM openFile failed: ${f}`);let h=L.getNumColumns(),p=Number(L.getRowCount(0)),m=Math.min(p,r);console.log(`[Worker] Fragment has ${h} columns, ${p} rows, reading ${m}`);let d={},g=[];for(let w=0;w<t.length&&w<h;w++){let A=t[w].name,y=n[w];g.push(A);try{if(y==="float64"||y==="double"){let b=L.allocFloat64Buffer(m);if(b){let F=L.readFloat64Column(w,b,m);d[A]=new Float64Array(R.buffer,b,F).slice()}else d[A]=new Float64Array(m).fill(0)}else if(y==="int64"){let b=L.allocInt64Buffer(m);if(b){let F=L.readInt64Column(w,b,m),S=new BigInt64Array(R.buffer,b,F),_=new Float64Array(F);for(let T=0;T<F;T++)_[T]=Number(S[T]);d[A]=_}else d[A]=new Float64Array(m).fill(0)}else if(y==="int32"){let b=L.allocInt32Buffer(m);if(b){let F=L.readInt32Column(w,b,m),S=new Int32Array(R.buffer,b,F),_=new Float64Array(F);for(let T=0;T<F;T++)_[T]=S[T];d[A]=_}else d[A]=new Float64Array(m).fill(0)}else if(y==="float32"){let b=L.alloc(m*4);if(b&&b>0){let F=L.readFloat32Column(w,b,m),S=new Float32Array(R.buffer,b,F),_=new Float64Array(F);for(let T=0;T<F;T++)_[T]=S[T];d[A]=_}else d[A]=new Float64Array(m).fill(0)}else y==="string"?d[A]=Array(m).fill("(string data)"):y==="vector"?d[A]=[]:d[A]=[]}catch(b){console.warn(`[Worker] Failed to read column ${A}:`,b),d[A]=[]}}return L.closeFile(),console.log(`[Worker] Read ${m} rows from ${g.length} columns`),{columns:d,rowCount:m,columnNames:g}}async function qe(u,t=1e4){try{console.log(`[Worker] Loading OPFS Lance: ${u}`);let n=u.split("/").filter(S=>S),r=n.pop(),e=await We(n),l=await(await e.getFileHandle(r)).getFile(),s=new Uint8Array(await l.arrayBuffer()),a=null;try{let T=await(await(await e.getFileHandle(`${r}.schema`)).getFile()).text();a=JSON.parse(T),console.log(`[Worker] Loaded schema sidecar: ${a.columns?.length} columns`)}catch{}if(!s||s.length===0)return console.error(`[Worker] Empty OPFS file: ${u}`),null;if(s.length<40)return console.error(`[Worker] File too small for Lance format: ${u}`),null;let i=String.fromCharCode(s[s.length-4],s[s.length-3],s[s.length-2],s[s.length-1]);if(i!=="LANC")return console.error(`[Worker] Invalid Lance magic in ${u}: ${i}`),null;let c=new DataView(s.buffer,s.byteOffset),f=s.length-40,h=Number(c.getBigUint64(f+8,!0)),p=c.getUint32(f+28,!0),m=[],d=[];for(let S=0;S<p;S++){let _=h+S*16;if(_+16>s.length){console.log(`[Worker] OPFS column ${S}: offset out of bounds (offsetPos=${_})`);continue}let T=Number(c.getBigUint64(_,!0)),$=Number(c.getBigUint64(_+8,!0));if(T>=s.length||T+$>s.length){console.log(`[Worker] OPFS column ${S}: metadata bounds invalid (pos=${T}, len=${$})`);continue}let B=`col_${S}`,E="unknown";a?.columns?.[S]&&(B=a.columns[S].name,E=a.columns[S].type||"unknown"),m.push({name:B,type:E,metaPos:T,metaLen:$}),d.push(E),console.log(`[Worker] OPFS column ${S}: name=${B}, type=${E}, metaPos=${T}, metaLen=${$}`)}if(!L&&(await X(),!L))throw new Error("WASM not loaded");let g=L.alloc(s.length);if(!g||g<0)throw new Error("Failed to allocate WASM memory for OPFS file");if(new Uint8Array(R.buffer,g,s.length).set(s),L.openFile(g,s.length)===0)throw new Error("WASM openFile failed: invalid Lance file");let A=Number(L.getRowCount(0)),y=Math.min(A,t);console.log(`[Worker] OPFS file has ${p} columns, ${A} rows, reading ${y}`);let b={},F=[];for(let S=0;S<m.length;S++){let{name:_,type:T}=m[S];if(F.push(_),T==="float64"||T==="double"){let $=L.allocFloat64Buffer(y);if($){let B=L.readFloat64Column(S,$,y);b[_]=new Float64Array(R.buffer,$,B).slice()}else b[_]=new Float64Array(y).fill(0)}else if(T==="int64"){let $=L.allocInt64Buffer(y);if($){let B=L.readInt64Column(S,$,y),E=new BigInt64Array(R.buffer,$,B),x=new Float64Array(B);for(let k=0;k<B;k++)x[k]=Number(E[k]);b[_]=x}else b[_]=new Float64Array(y).fill(0)}else if(T==="string"){let $=L.getStringCount?Number(L.getStringCount(S)):0;if(console.log(`[Worker] OPFS column ${S} (${_}): stringCount=${$}`),$>0&&L.readStringAt&&L.allocStringBuffer){let B=[],x=L.allocStringBuffer(4096);if(x){let k=new TextDecoder("utf-8");for(let H=0;H<y;H++){let V=L.readStringAt(S,H,x,4096);if(V>0){let v=Math.min(V,4096),O=new Uint8Array(R.buffer,x,v);B.push(k.decode(O.slice()))}else B.push("")}b[_]=B,console.log(`[Worker] Read ${B.length} strings for column ${_}, first: "${B[0]}"`)}else console.warn(`[Worker] Failed to allocate string buffer for column ${_}`),b[_]=Array(y).fill("")}else console.warn(`[Worker] String column ${_}: no WASM string functions or zero count`),b[_]=Array(y).fill("")}else if(T.includes("vector")||T.includes("list")||T==="float32")if(L.getVectorInfo&&L.readVectorAt&&L.allocFloat32Buffer){let $=L.getVectorInfo(S);if($>0){let B=Number($>>32n),E=Number($&0xFFFFFFFFn),x=Math.min(y,B);if(console.log(`[Worker] OPFS vector column ${_}: dim=${E}, rows=${B}, reading ${x}`),E>0&&x>0){let k=x*E,H=L.allocFloat32Buffer(k);if(H){for(let v=0;v<x;v++){let O=v*E;L.readVectorAt(S,v,H+O,E)}let V=new Float32Array(R.buffer,H,k).slice();b[_]=V,b[`__${_}_dim`]=E}else console.warn(`[Worker] Failed to allocate vector buffer for column ${_}`),b[_]=new Float32Array(0)}else b[_]=new Float32Array(0)}else console.warn(`[Worker] getVectorInfo returned 0 for column ${_}`),b[_]=new Float32Array(0)}else console.warn(`[Worker] No WASM vector functions for column ${_}`),b[_]=new Float32Array(0);else{let $=L.allocFloat64Buffer(y);if($){let B=L.readFloat64Column(S,$,y);B>0?b[_]=new Float64Array(R.buffer,$,B).slice():b[_]=Array(y).fill("")}else b[_]=[]}}return L.closeFile(),console.log(`[Worker] OPFS read ${y} rows from ${F.length} columns: ${F.join(", ")}`),{columns:b,rowCount:y,columnNames:F}}catch(n){return console.error("[Worker] Failed to load OPFS Lance:",n),null}}async function Qe(u,t){if(!L&&(await X(),!L))throw new Error("WASM not loaded");let n=t.replace(/--[^\n]*/g,"").replace(/\/\*[\s\S]*?\*\//g,"").trim(),r=Le(),e=lt(n);for(let{url:s,alias:a}of e){let i=r.hasTable(a);if(console.log(`[Worker] Processing URL mapping: alias=${a}, url=${s.substring(0,50)}..., alreadyRegistered=${i}`),i){console.log(`[Worker] Table ${a} already registered, skipping`);continue}if(s.startsWith("opfs://")){let p=s.replace("opfs://","").replace(".lance","");if(r.hasTable(p)){console.log(`[Worker] Aliasing ${a} to existing table ${p}`),r.aliasTable(p,a);continue}}let c=null,f=null;try{if(s.startsWith("https://")||s.startsWith("http://"))console.log(`[Worker] Fetching remote Lance: ${s} as ${a}`),c=await ft(s);else if(s.startsWith("opfs://")){let h=s.replace("opfs://","");console.log(`[Worker] Loading OPFS Lance: ${h} as ${a}`),c=await qe(h)}else console.log(`[Worker] Loading OPFS Lance (no prefix): ${s} as ${a}`),c=await qe(s)}catch(h){f=h,console.error(`[Worker] Failed to load ${s}:`,h)}if(c){let h=Object.keys(c.columns),p=h.filter(d=>{let g=c.columns[d];return g&&(Array.isArray(g),g.length>0)});console.log(`[Worker] Registering table ${a} with ${c.rowCount} rows, columns: ${h.join(", ")}, non-empty: ${p.join(", ")}`);try{r.registerTable(a,c.columns,c.rowCount,s)}catch(d){throw console.error(`[Worker] Registration error for ${a}:`,d),new Error(`Failed to register table ${a}: ${d.message}`)}let m=r.hasTable(a);if(console.log(`[Worker] hasTable(${a}) = ${m}`),!m)throw new Error(`Failed to register table ${a} from ${s} - hasTable returned false`)}else{let h=f?f.message:"file may not exist or returned empty data";throw new Error(`Could not load read_lance('${s}'): ${h}`)}}let o=e.length>0?ct(n,e):n,l=r.getTableNames(o);for(let s of l){if(r.hasTable(s))continue;let i=u.tables.get(s);if(!i)continue;let c=u._columnarBuffer?.get(s),f=c?.__length||0,h=`${s}:${i.fragments?.length||0}:${f}:${i.deletionVector?.length||0}`,p=i.fragments.length>0,m=f>0;if(p){let d=[];for(let g of i.fragments){let w=await yt(g);w&&d.push(w)}if(r.registerTableFromFiles(s,i.fragments,h),m){let g={};for(let w of i.schema){let A=c[w.name];A&&ArrayBuffer.isView(A)&&(g[w.name]=A.subarray(0,f))}r.appendTableMemory(s,g,f)}}else if(m){let d=await u.selectColumnar(s);if(d){let{columns:g,rowCount:w}=d;r.registerTable(s,g,w,h)}}}return r.execute(o)}var L=null,R=null,ae=new Map,wt=1;async function We(u){let t=await navigator.storage.getDirectory();t=await t.getDirectoryHandle("lanceql",{create:!0});for(let n of u)t=await t.getDirectoryHandle(n,{create:!0});return t}function mt(){return{env:{opfs_open:(u,t)=>{try{let n=new Uint8Array(R.buffer,u,t),r=new TextDecoder().decode(n);for(let[e,o]of ae.entries())if(o._path===r)return e;return console.warn("[LanceQLWorker] WASM tried to open unregistered path:",r),0}catch(n){return console.error("[LanceQLWorker] Error:",n),0}},opfs_read:(u,t,n,r)=>{let e=ae.get(u);if(!e)return 0;try{let o=new Uint8Array(R.buffer,t,n);return e.read(o,{at:Number(r)})}catch{return 0}},opfs_size:u=>{let t=ae.get(u);if(!t)return BigInt(0);try{return BigInt(t.getSize())}catch{return BigInt(0)}},opfs_close:u=>{},__assert_fail:(u,t,n,r)=>{let o=new TextDecoder().decode(new Uint8Array(R.buffer,u).subarray(0,100));console.error(`[WASM ASSERT] ${o} at line ${n}`)},js_log:(u,t)=>{let r=new TextDecoder().decode(new Uint8Array(R.buffer,u,t));console.log(`[WASM LOG] ${r}`);for(let e of xe)e.postMessage({type:"log",message:r,marker:"__WASM_LOG_BRIDGE__"})}}}}async function yt(u){try{let t=u.split("/").filter(s=>s),n=t.pop(),o=await(await(await We(t)).getFileHandle(n)).createSyncAccessHandle(),l=wt++;return o._path=u,ae.set(l,o),l}catch(t){return console.warn("[LanceQLWorker] Failed to register OPFS file:",u,t),0}}function en(u){let t=ae.get(u);if(t){try{t.close()}catch{}ae.delete(u)}}async function X(){if(L)return L;try{let u=new URL("./lanceql.wasm",import.meta.url);u.searchParams.set("v",Date.now().toString());let n=await(await fetch(u)).arrayBuffer(),r=mt();return L=(await WebAssembly.instantiate(n,r)).instance.exports,R=L.memory,console.log("[LanceQLWorker] WASM loaded with OPFS support"),L}catch(u){return console.warn("[LanceQLWorker] WASM not available:",u.message),null}}function Q(){return L}function j(){return R}var Ie=0,Je=0,pt=1024*1024;function bt(u){if(!L)return 0;if(u<=Je&&Ie!==0)return Ie;let t=Math.max(u,pt),n=L.alloc(t);return n&&(Ie=n,Je=t),n}async function tn(u){let t=await X();if(!t)return 0;try{let n=u.split("/").filter(f=>f),r=n.pop(),l=await(await(await We(n)).getFileHandle(r)).createSyncAccessHandle(),s=l.getSize(),a=bt(s);if(!a)return l.close(),0;let i=new Uint8Array(R.buffer,a,s),c=l.read(i,{at:0});return l.close(),c!==s?0:t.openFile(a,s)}catch(n){return console.warn("[LanceQLWorker] Failed to load fragment:",u,n),0}}async function _t(u,t){let n=t.split("/").filter(e=>e),r=u;for(let e=0;e<n.length-1;e++)r=await r.getDirectoryHandle(n[e],{create:!1});return await r.getFileHandle(n[n.length-1],{create:!1})}var ve=null;async function At(u){let t=Ce.get(u);if(t)return t;ve||(ve=await navigator.storage.getDirectory());let e=await(await(await _t(ve,u)).getFile()).arrayBuffer();return t=new Uint8Array(e),t&&Ce.set(u,t,t.byteLength),t}async function nn(u,t,n){if(!await At(u))return null;let e=L;switch(n){case"sum":return e.opfsSumFloat64Column(t);case"min":return e.opfsMinFloat64Column(t);case"max":return e.opfsMaxFloat64Column(t);case"avg":return e.opfsAvgFloat64Column(t);case"count":return Number(e.opfsCountRows());default:return null}}X();var Ce=new re,Be=new Map,ke=new Map,me=null,xe=new Set,se=null,te=0,St=1024,ye=new Map,Ye=1;async function Z(u=null){return me||(me=new we),await me.open(u),me}async function P(u,t={},n=null){let r=n?.keyId||"none",e=`${u}:${r}:${JSON.stringify(t)}`;if(!Be.has(e)){let o=new de(u,t);await o.open(n),Be.set(e,o)}return Be.get(e)}async function N(u){if(!ke.has(u)){let t=new oe(u,Ce);await t.open(),ke.set(u,t)}return ke.get(u)}function Tt(u,t,n){if(n&&n._format==="wasm_binary"){u.postMessage({id:t,result:{_format:"wasm_binary",buffer:n.buffer,columns:n.columns,rowCount:n.rowCount,schema:n.schema}},[n.buffer]);return}if(n&&n._format==="columnar"&&n.data){let r=n.columns,e=n.rowCount;if(e<1e5){let p=[],m={},d=new Set;for(let g of r){let w=n.data[g];if(ArrayBuffer.isView(w)){let A=w.byteOffset!==0||w.byteLength<w.buffer.byteLength,y=d.has(w.buffer);if(A||y){let b=new w.constructor(w);m[g]=b,p.push(b.buffer)}else m[g]=w,p.push(w.buffer),d.add(w.buffer)}else w&&w._arrowString?(m[g]=w,w.offsets&&w.offsets.buffer&&!d.has(w.offsets.buffer)&&(p.push(w.offsets.buffer),d.add(w.offsets.buffer)),w.bytes&&w.bytes.buffer&&!d.has(w.bytes.buffer)&&(p.push(w.bytes.buffer),d.add(w.bytes.buffer))):m[g]=w}u.postMessage({id:t,result:{_format:"columnar",columns:r,rowCount:e,data:m}},p);return}let o=[],l=[],s=0;for(let p of r){let m=n.data[p];ArrayBuffer.isView(m)?(o.push({name:p,arr:m}),s+=m.byteLength):Array.isArray(m)&&l.push({name:p,arr:m})}let a=s>0?new ArrayBuffer(s):null,i={},c=0;if(a){let p=new Uint8Array(a);for(let{name:m,arr:d}of o){let g=new Uint8Array(d.buffer,d.byteOffset,d.byteLength);p.set(g,c),i[m]={offset:c,length:d.length,type:d.constructor.name},c+=d.byteLength}}let f={};for(let{name:p,arr:m}of l)f[p]=m;let h=[];a&&h.push(a),u.postMessage({id:t,result:{_format:"packed",columns:r,rowCount:e,packedBuffer:a,colOffsets:i,stringData:f}},h);return}if(se&&n!==void 0){let r=JSON.stringify(n);if(r.length>St){let e=q.encode(r);if(te+e.length<=se.byteLength){new Uint8Array(se,te,e.length).set(e),u.postMessage({id:t,sharedOffset:te,sharedLength:e.length}),te+=e.length,te>se.byteLength/2&&(te=0);return}}}u.postMessage({id:t,result:n})}async function Ze(u,t){if(t.type==="initSharedBuffer"){se=t.buffer,te=0,console.log("[LanceQLWorker] SharedArrayBuffer initialized:",se.byteLength,"bytes");return}let{id:n,method:r,args:e}=t;try{let o;if(r==="ping")o="pong";else if(r==="open")await P(e.name,e.options,e.encryption),o=!0;else if(r==="get")o=await(await P(e.name)).get(e.key);else if(r==="set")await(await P(e.name)).set(e.key,e.value),o=!0;else if(r==="delete")await(await P(e.name)).delete(e.key),o=!0;else if(r==="keys")o=await(await P(e.name)).keys();else if(r==="clear")await(await P(e.name)).clear(),o=!0;else if(r==="filter")o=await(await P(e.name)).filter(e.key,e.query);else if(r==="find")o=await(await P(e.name)).find(e.key,e.query);else if(r==="search")o=await(await P(e.name)).search(e.key,e.text,e.limit);else if(r==="count")o=await(await P(e.name)).count(e.key,e.query);else if(r==="enableSemanticSearch")o=await(await P(e.name)).enableSemanticSearch(e.options);else if(r==="disableSemanticSearch")(await P(e.name)).disableSemanticSearch(),o=!0;else if(r==="hasSemanticSearch")o=(await P(e.name)).hasSemanticSearch();else if(r==="db:open")console.log(`[LanceQLWorker] db:open ${e.name}`),await N(e.name),o=!0;else if(r==="db:createTable")console.log(`[LanceQLWorker] db:createTable ${e.tableName}`),o=await(await N(e.db)).createTable(e.tableName,e.columns,e.ifNotExists),console.log(`[LanceQLWorker] db:createTable ${e.tableName} done`);else if(r==="db:dropTable"){console.log(`[LanceQLWorker] db:dropTable ${e.tableName}`),o=await(await N(e.db)).dropTable(e.tableName,e.ifExists);let s=q.encode(e.tableName);Le().clearTable(s,s.length)}else if(r==="db:insert")console.log(`[LanceQLWorker] db:insert into ${e.tableName}, rows: ${e.rows?.length}`),o=await(await N(e.db)).insert(e.tableName,e.rows),console.log("[LanceQLWorker] db:insert done");else if(r==="db:delete"){let l=await N(e.db),s=e.where?a=>evalWhere(e.where,a):()=>!0;o=await l.delete(e.tableName,s)}else if(r==="db:update"){let l=await N(e.db),s=e.where?a=>evalWhere(e.where,a):()=>!0;o=await l.update(e.tableName,e.updates,s)}else if(r==="db:select"){let l=await N(e.db),s={...e.options};e.where&&(s.where=a=>evalWhere(e.where,a)),o=await l.select(e.tableName,s)}else if(r==="db:exec"){let l=await N(e.db),s=Ge(e.sql);if(s?.type==="SHOW_VERSIONS"){let a=await l.listVersions(s.table);o={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:a.length,data:{version:new Float64Array(a.map(i=>i.version)),timestamp:a.map(i=>new Date(i.timestamp).toISOString()),operation:a.map(i=>i.operation),rowCount:new Float64Array(a.map(i=>i.rowCount))}}}else if(s?.type==="RESTORE_TABLE"){let a=await l.restoreToVersion(s.table,s.version);o={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([a.newVersion])}}}else if(s?.type==="SELECT_VERSION"){let a=await l.selectAtVersion(s.table,s.version,{});if(a.length>0){let i=Object.keys(a[0]),c={};for(let f of i)c[f]=a.map(h=>h[f]);o={_format:"columnar",columns:i,rowCount:a.length,data:c}}else o={_format:"columnar",columns:[],rowCount:0,data:{}}}else o=await Qe(l,e.sql);if(o&&o._format==="columnar"&&o.rowCount>=1e5){let a=Ye++;ye.set(a,o),o={_format:"cursor",cursorId:a,columns:o.columns,rowCount:o.rowCount}}}else if(r==="cursor:fetch"){let l=ye.get(e.cursorId);if(!l)throw new Error("Cursor not found");o=l,ye.delete(e.cursorId)}else if(r==="db:flush")console.log(`[LanceQLWorker] db:flush ${e.db}`),await(await N(e.db)).flush(),console.log(`[LanceQLWorker] db:flush ${e.db} done`),o=!0;else if(r==="db:compact")o=await(await N(e.db)).compact();else if(r==="db:listTables")o=(await N(e.db)).listTables();else if(r==="db:getTable")o=(await N(e.db)).getTable(e.tableName);else if(r==="db:scanStart")o=await(await N(e.db)).scanStart(e.tableName,e.options);else if(r==="db:scanNext")o=(await N(e.db)).scanNext(e.streamId);else if(r==="db:listVersions")o=await(await N(e.db)).listVersions(e.tableName);else if(r==="db:selectAtVersion"){let l=await N(e.db),s={...e.options};e.where&&(s.where=a=>evalWhere(e.where,a)),o=await l.selectAtVersion(e.tableName,e.version,s)}else if(r==="db:restoreTable")o=await(await N(e.db)).restoreToVersion(e.tableName,e.version);else if(r==="vault:open")await Z(e.encryption),o=!0;else if(r==="vault:get")o=await(await Z()).get(e.key);else if(r==="vault:set")await(await Z()).set(e.key,e.value),o=!0;else if(r==="vault:delete")await(await Z()).delete(e.key),o=!0;else if(r==="vault:keys")o=await(await Z()).keys();else if(r==="vault:has")o=await(await Z()).has(e.key);else if(r==="vault:tables"){let l=await Z();o=l._db?l._db.listTables():[]}else if(r==="vault:exec"){let s=(await Z())._db,a=Ge(e.sql);if(a?.type==="SHOW_VERSIONS"){let i=await s.listVersions(a.table);o={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:i.length,data:{version:new Float64Array(i.map(c=>c.version)),timestamp:i.map(c=>new Date(c.timestamp).toISOString()),operation:i.map(c=>c.operation),rowCount:new Float64Array(i.map(c=>c.rowCount))}}}else if(a?.type==="RESTORE_TABLE"){let i=await s.restoreToVersion(a.table,a.version);o={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([i.newVersion])}}}else if(a?.type==="SELECT_VERSION"){let i=await s.selectAtVersion(a.table,a.version,{});if(i.length>0){let c=Object.keys(i[0]),f={};for(let h of c)f[h]=i.map(p=>p[h]);o={_format:"columnar",columns:c,rowCount:i.length,data:f}}else o={_format:"columnar",columns:[],rowCount:0,data:{}}}else o=await Qe(s,e.sql);if(o&&o._format==="columnar"&&o.rowCount>=1e5){let i=Ye++;ye.set(i,o),o={_format:"cursor",cursorId:i,columns:o.columns,rowCount:o.rowCount}}}else if(r==="loadMinilmModel"){if(L||await X(),!L)throw new Error("WASM not loaded");if(L.minilm_weights_loaded&&L.minilm_weights_loaded()===1)o={loaded:!0,cached:!0};else{L.minilm_init&&L.minilm_init();let l=e.url||"https://data.metal0.dev/models/minilm-l6-v2.gguf";console.log("[Worker] Downloading MiniLM model...");let s=await fetch(l);if(!s.ok)throw new Error("MiniLM model download failed");let a=await s.arrayBuffer();console.log("[Worker] MiniLM downloaded:",a.byteLength,"bytes");let i=L.minilm_alloc_model_buffer(a.byteLength);if(i===0)throw new Error("Failed to allocate WASM memory for MiniLM");new Uint8Array(R.buffer).set(new Uint8Array(a),i);let f=L.minilm_load_model(a.byteLength);if(f!==0)throw new Error(`MiniLM load error: ${f}`);console.log("[Worker] MiniLM model loaded successfully"),o={loaded:!0,cached:!1,size:a.byteLength}}}else throw new Error(`Unknown method: ${r}`);Tt(u,n,o)}catch(o){let l=o.stack||o.message;l.includes("TableDoesNotExist")?l="Table does not exist":l.includes("ColumnDoesNotExist")?l="Column does not exist":l.includes("UnknownEmbeddingModel")&&(l="Unknown embedding model"),u.postMessage({id:n,error:l})}}var Ft=typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope;Ft?self.onconnect=u=>{let t=u.ports[0];xe.add(t),t.onmessage=n=>{Ze(t,n.data)},t.onmessageerror=n=>{console.error("[LanceQLWorker] Message error:",n)},X().then(()=>{t.postMessage({type:"ready"})}).catch(n=>{console.error("[LanceQLWorker] Failed to load WASM:",n),t.postMessage({type:"ready",error:"WASM load failed"})}),t.start(),console.log("[LanceQLWorker] New connection, total ports:",xe.size)}:(self.onmessage=u=>{Ze(self,u.data)},X().then(()=>{self.postMessage({type:"ready"})}).catch(u=>{console.error("[LanceQLWorker] Failed to load WASM:",u),self.postMessage({type:"ready",error:"WASM load failed"})}));console.log("[LanceQLWorker] Initialized");export{en as closeOPFSFile,Q as getWasm,j as getWasmMemory,tn as loadFragmentToWasm,yt as registerOPFSFile,nn as wasmAggregate};
//# sourceMappingURL=lanceql-worker.js.map
