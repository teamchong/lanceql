var H=new Map;async function re(u){return crypto.subtle.importKey("raw",new Uint8Array(u),{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function se(u,e){let n=crypto.getRandomValues(new Uint8Array(12)),t=new TextEncoder().encode(JSON.stringify(u)),s=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},e,t),l=new Uint8Array(12+s.byteLength);return l.set(n,0),l.set(new Uint8Array(s),12),l}async function oe(u,e){let n=u.slice(0,12),r=u.slice(12),t=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},e,r),s=new TextDecoder;return JSON.parse(s.decode(t))}var D=null,te=null,ue=new Map;function Me(u){D=u}function Pe(u){te=u}var ae=class{constructor(e,n={}){this.name=e,this.options=n,this._root=null,this._ready=!1,this._embedder=null,this._encryptionKeyId=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:n,keyBytes:r}=e;if(!H.has(n)){let t=await re(r);H.set(n,t)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle(`lanceql-${this.name}`,{create:!0}),this._ready=!0}catch(n){throw console.error("[WorkerStore] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?H.get(this._encryptionKeyId):null}async get(e){await this._ensureOpen();try{let n=this._getCryptoKey(),r=n?".enc":".json",s=await(await this._root.getFileHandle(`${e}${r}`)).getFile();if(n){let l=await s.arrayBuffer();return oe(new Uint8Array(l),n)}else{let l=await s.text();return JSON.parse(l)}}catch(n){if(n.name==="NotFoundError")return;throw n}}async set(e,n){await this._ensureOpen();let r=this._getCryptoKey(),t=r?".enc":".json",l=await(await this._root.getFileHandle(`${e}${t}`,{create:!0})).createWritable();if(r){let o=await se(n,r);await l.write(o)}else await l.write(JSON.stringify(n));await l.close()}async delete(e){await this._ensureOpen();let r=this._getCryptoKey()?".enc":".json";try{await this._root.removeEntry(`${e}${r}`)}catch(t){if(t.name!=="NotFoundError")throw t}}async keys(){await this._ensureOpen();let n=this._getCryptoKey()?".enc":".json",r=[];for await(let[t]of this._root.entries())t.endsWith(n)&&r.push(t.slice(0,-n.length));return r}async clear(){await this._ensureOpen();let e=[];for await(let[n]of this._root.entries())e.push(n);for(let n of e)await this._root.removeEntry(n)}async filter(e,n){let r=await this.get(e);if(!Array.isArray(r))throw new Error(`Key '${e}' is not a collection`);return r.filter(t=>this._matchQuery(t,n))}async find(e,n){let r=await this.get(e);if(!Array.isArray(r))throw new Error(`Key '${e}' is not a collection`);return r.find(t=>this._matchQuery(t,n))}async search(e,n,r=10){let t=await this.get(e);if(!Array.isArray(t))throw new Error(`Key '${e}' is not a collection`);if(t.length===0)return[];if(this._embedder)return this._semanticSearch(t,e,n,r);let s=n.toLowerCase();return t.map(o=>{let i=this._extractText(o).toLowerCase(),a=s.split(/\s+/),c=a.filter(f=>i.includes(f)).length;return{item:o,score:c/a.length}}).filter(o=>o.score>0).sort((o,i)=>i.score-o.score).slice(0,r)}async _semanticSearch(e,n,r,t){let s=await this._embedder.embed(r),l=[],o=[],i=[];for(let a=0;a<e.length;a++){let c=e[a],f=this._extractText(c),d=`${this.name}:${n}:${f}`;if(ue.has(d)){let p=ue.get(d),m=this._cosineSimilarity(s,p);l.push({item:c,score:m})}else o.push(f),i.push(a)}if(o.length>0){let a;o.length>1&&this._embedder.embedBatch?a=await this._embedder.embedBatch(o):a=await Promise.all(o.map(c=>this._embedder.embed(c)));for(let c=0;c<a.length;c++){let f=i[c],d=e[f],p=o[c],m=a[c],h=`${this.name}:${n}:${p}`;ue.set(h,m);let g=this._cosineSimilarity(s,m);l.push({item:d,score:g})}}return l.sort((a,c)=>c.score-a.score).slice(0,t)}async enableSemanticSearch(e={}){let{model:n="minilm",onProgress:r}=e;if(D||(te||(te=this._initGPUTransformer(),Pe(te)),D=await te,Me(D)),!D)return null;let t=await D.loadModel(n,r);return this._embedder={model:n,dimensions:t.hiddenSize,embed:async s=>D.encodeText(s,n),embedBatch:async s=>D.encodeTextBatch(s,n)},{model:n,dimensions:t.hiddenSize,type:t.modelType||"text"}}async _initGPUTransformer(){try{let e=await import("./webgpu/index.js");if(!e.isWebGPUAvailable())return console.log("[WorkerStore] WebGPU not available"),null;let n=e.getGPUTransformer();return await n.init()?(console.log("[WorkerStore] WebGPU initialized"),n):(console.log("[WorkerStore] WebGPU init failed"),null)}catch(e){return console.error("[WorkerStore] WebGPU init error:",e),null}}disableSemanticSearch(){this._embedder&&D&&(D.unloadModel(this._embedder.model),this._embedder=null)}hasSemanticSearch(){return this._embedder!==null}async count(e,n=null){let r=await this.get(e);if(!Array.isArray(r))throw new Error(`Key '${e}' is not a collection`);return n?r.filter(t=>this._matchQuery(t,n)).length:r.length}async _ensureOpen(){this._ready||await this.open()}_matchQuery(e,n){for(let[r,t]of Object.entries(n)){let s=e[r];if(typeof t=="object"&&t!==null)for(let[l,o]of Object.entries(t))switch(l){case"$eq":if(s!==o)return!1;break;case"$ne":if(s===o)return!1;break;case"$lt":if(!(s<o))return!1;break;case"$lte":if(!(s<=o))return!1;break;case"$gt":if(!(s>o))return!1;break;case"$gte":if(!(s>=o))return!1;break;case"$in":if(!Array.isArray(o)||!o.includes(s))return!1;break;case"$nin":if(Array.isArray(o)&&o.includes(s))return!1;break;case"$contains":if(typeof s!="string"||!s.includes(o))return!1;break;case"$regex":if(typeof s!="string"||!new RegExp(o).test(s))return!1;break}else if(s!==t)return!1}return!0}_extractText(e){if(typeof e=="string")return e;let n=[];for(let[r,t]of Object.entries(e))typeof t=="string"&&n.push(t);return n.join(" ")}_cosineSimilarity(e,n){let r=0,t=0,s=0;for(let l=0;l<e.length;l++)r+=e[l]*n[l],t+=e[l]*e[l],s+=n[l]*n[l];return r/(Math.sqrt(t)*Math.sqrt(s))}};var he=class{constructor(e="lanceql"){this.rootDir=e,this.root=null}async getRoot(){if(this.root)return this.root;if(typeof navigator>"u"||!navigator.storage?.getDirectory)throw new Error("OPFS not available");let e=await navigator.storage.getDirectory();return this.root=await e.getDirectoryHandle(this.rootDir,{create:!0}),this.root}async open(){return await this.getRoot(),this}async getDir(e){let n=await this.getRoot(),r=e.split("/").filter(s=>s),t=n;for(let s of r)t=await t.getDirectoryHandle(s,{create:!0});return t}async save(e,n){let r=e.split("/"),t=r.pop(),s=r.join("/"),o=await(s?await this.getDir(s):await this.getRoot()).getFileHandle(t,{create:!0});if(o.createSyncAccessHandle)try{let a=await o.createSyncAccessHandle();return a.truncate(0),a.write(n,{at:0}),a.flush(),a.close(),{path:e,size:n.byteLength}}catch{}let i=await o.createWritable();return await i.write(n),await i.close(),{path:e,size:n.byteLength}}async load(e){try{let n=e.split("/"),r=n.pop(),t=n.join("/"),i=await(await(await(t?await this.getDir(t):await this.getRoot()).getFileHandle(r)).getFile()).arrayBuffer();return new Uint8Array(i)}catch(n){if(n.name==="NotFoundError")return null;throw n}}async delete(e){try{let n=e.split("/"),r=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(r),!0}catch(n){if(n.name==="NotFoundError")return!1;throw n}}async list(e=""){try{let n=e?await this.getDir(e):await this.getRoot(),r=[];for await(let[t,s]of n.entries())r.push({name:t,type:s.kind});return r}catch{return[]}}async exists(e){try{let n=e.split("/"),r=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).getFileHandle(r),!0}catch{return!1}}async deleteDir(e){try{let n=e.split("/"),r=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(r,{recursive:!0}),!0}catch{return!1}}},B=new he;var N=new TextEncoder,G=new TextDecoder,xe={INT64:"int64",INT32:"int32",FLOAT64:"float64",FLOAT32:"float32",STRING:"string",BOOL:"bool",VECTOR:"vector"},Ce=1,Be=2,ve=3,$e=4,de=5,we=6;function Fe(u){switch(u){case"int32":case"integer":return Int32Array;case"int64":return BigInt64Array;case"float32":case"real":return Float32Array;case"float64":case"double":return Float64Array;default:return null}}function He(u){switch(u){case"int32":case"integer":return Ce;case"int64":return Be;case"float32":case"real":return ve;case"float64":case"double":return $e;case"string":case"text":return de;case"bool":case"boolean":return we;default:return de}}var ie=class{constructor(e){this.schema=e,this.columns=new Map,this.rowCount=0,this._useBinary=!0}addRows(e){if(e.length!==0){if(this.rowCount===0)for(let n of this.schema){let r=Fe(n.dataType);r?this.columns.set(n.name,{type:"typed",dataType:n.dataType,data:new r(Math.max(e.length,1024)),length:0}):this.columns.set(n.name,{type:"array",dataType:n.dataType,data:[],length:0})}for(let n of this.schema){let r=this.columns.get(n.name);if(r.type==="typed"){let t=r.length+e.length;if(t>r.data.length){let s=Math.max(t,r.data.length*2),l=new r.data.constructor(s);l.set(r.data),r.data=l}for(let s=0;s<e.length;s++){let l=e[s][n.name];r.data[r.length+s]=l??0}r.length+=e.length}else{for(let t=0;t<e.length;t++)r.data.push(e[t][n.name]??null);r.length+=e.length}}this.rowCount+=e.length}}buildBinary(){let e=[],n=16,r=[];for(let i of this.schema){let a=this.columns.get(i.name),c=N.encode(i.name),f=He(i.dataType),d;if(a.type==="typed"){let h=a.data.subarray(0,a.length);d=new Uint8Array(h.buffer,h.byteOffset,h.byteLength)}else d=N.encode(JSON.stringify(a.data));r.push({nameBytes:c,typeCode:f,dataBytes:d,dataType:i.dataType});let m=(8-(n+4+c.length+1+4)%8)%8;n+=4+c.length+1+m+4+d.length}let t=new ArrayBuffer(n),s=new DataView(t),l=new Uint8Array(t),o=0;s.setUint32(o,1279348291,!1),o+=4,s.setUint32(o,2,!1),o+=4,s.setUint32(o,this.schema.length,!1),o+=4,s.setUint32(o,this.rowCount,!1),o+=4;for(let i of r){s.setUint32(o,i.nameBytes.length,!1),o+=4,l.set(i.nameBytes,o),o+=i.nameBytes.length,s.setUint8(o,i.typeCode),o+=1;let a=(8-(o+4)%8)%8;for(let c=0;c<a;c++)s.setUint8(o+c,0);o+=a,s.setUint32(o,i.dataBytes.length,!1),o+=4,l.set(i.dataBytes,o),o+=i.dataBytes.length}return new Uint8Array(t)}setColumnarData(e){let n=Object.keys(e)[0];this.rowCount=e[n]?.length||0;for(let r of this.schema){let t=e[r.name];if(!t)continue;let s=Fe(r.dataType);if(s&&ArrayBuffer.isView(t))this.columns.set(r.name,{type:"typed",dataType:r.dataType,data:t,length:t.length});else if(s){let l=new s(t.length);for(let o=0;o<t.length;o++)l[o]=t[o]??0;this.columns.set(r.name,{type:"typed",dataType:r.dataType,data:l,length:t.length})}else this.columns.set(r.name,{type:"array",dataType:r.dataType,data:Array.isArray(t)?t:Array.from(t),length:t.length})}}build(){if(this._useBinary&&this.rowCount>0)try{return this.buildBinary()}catch(n){console.warn("[LanceFileWriter] Binary build failed, falling back to JSON:",n)}let e={format:"json",schema:this.schema,columns:{},rowCount:this.rowCount};for(let[n,r]of this.columns)r.type==="typed"?e.columns[n]=Array.from(r.data.subarray(0,r.length)):e.columns[n]=r.data;return N.encode(JSON.stringify(e))}};function ne(u){let e=new DataView(u.buffer||u),n=new Uint8Array(u.buffer||u),r=0;if(e.getUint32(r,!1)!==1279348291)return null;r+=4;let s=e.getUint32(r,!1);r+=4;let l=e.getUint32(r,!1);r+=4;let o=e.getUint32(r,!1);r+=4;let i=[],a={};for(let c=0;c<l;c++){let f=e.getUint32(r,!1);r+=4;let d=G.decode(n.subarray(r,r+f));r+=f;let p=e.getUint8(r);r+=1;let m=(8-(r+4)%8)%8;r+=m;let h=e.getUint32(r,!1);r+=4;let g=n.subarray(r,r+h);r+=h;let w,y;try{switch(p){case Ce:y="int32",g.byteOffset%4!==0?w=new Int32Array(g.slice().buffer):w=new Int32Array(g.buffer,g.byteOffset,g.byteLength/4);break;case ve:y="float32",g.byteOffset%4!==0?w=new Float32Array(g.slice().buffer):w=new Float32Array(g.buffer,g.byteOffset,g.byteLength/4);break;case $e:y="float64",g.byteOffset%8!==0?w=new Float64Array(g.slice().buffer):w=new Float64Array(g.buffer,g.byteOffset,g.byteLength/8);break;case Be:y="int64",g.byteOffset%8!==0?w=new BigInt64Array(g.slice().buffer):w=new BigInt64Array(g.buffer,g.byteOffset,g.byteLength/8);break;case de:case we:default:y=p===we?"bool":"string",w=JSON.parse(G.decode(g));break}}catch(A){throw console.error(`[LanceQLWorker] Error parsing column '${d}' (type ${p}, len ${h}):`,A),A}i.push({name:d,dataType:y}),a[d]=w}return{schema:i,columns:a,rowCount:o,format:"binary"}}var Q=class{constructor(e=512*1024*1024){this.maxBytes=e,this.currentBytes=0,this.cache=new Map,this.head=null,this.tail=null}get(e){let n=this.cache.get(e);if(n)return this._moveToHead(n),n.value}set(e,n,r=0){let t=this.cache.get(e);if(t)this.currentBytes-=t.size,this.currentBytes+=r,t.value=n,t.size=r,this._moveToHead(t);else{let s={key:e,value:n,size:r,prev:null,next:null};this.cache.set(e,s),this._addToHead(s),this.currentBytes+=r}this._evictIfNeeded()}has(e){return this.cache.has(e)}delete(e){let n=this.cache.get(e);n&&(this._removeNode(n),this.cache.delete(e),this.currentBytes-=n.size)}clear(){this.cache.clear(),this.head=null,this.tail=null,this.currentBytes=0}_moveToHead(e){e!==this.head&&(this._removeNode(e),this._addToHead(e))}_addToHead(e){e.next=this.head,e.prev=null,this.head&&(this.head.prev=e),this.head=e,this.tail||(this.tail=e)}_removeNode(e){e.prev?e.prev.next=e.next:this.head=e.next,e.next?e.next.prev=e.prev:this.tail=e.prev}_evictIfNeeded(){for(;this.currentBytes>this.maxBytes&&this.tail;){let e=this.tail;this._removeNode(e),this.cache.delete(e.key),this.currentBytes-=e.size}}static estimateSize(e){return e?e.byteLength?e.byteLength:Array.isArray(e)?e.length*100:e.buffer&&e.buffer.byteLength?e.buffer.byteLength:1e3:0}};var ge=new Map,Ke=1,J=class{constructor(e,n){this.name=e,this.tables=new Map,this.version=0,this.manifestKey=`${e}/__manifest__`,this.bufferPool=n||new Q,this._writeBuffer=new Map,this._flushTimer=null,this._flushInterval=2e3,this._flushThreshold=1e4,this._columnarBuffer=new Map,this._flushing=!1,this._readCache=new Map,this._columnarCache=new Map}async open(){let e=await B.load(this.manifestKey);if(e){let n=JSON.parse(G.decode(e));this.version=n.version||0,this.tables=new Map(Object.entries(n.tables||{}));for(let[r,t]of this.tables)await this._getLatestVersion(r)===0&&t.fragments?.length>0&&await this._createVersion(r,"MIGRATE")}return this}async _saveManifest(){this.version++;let e={version:this.version,timestamp:Date.now(),tables:Object.fromEntries(this.tables)},n=N.encode(JSON.stringify(e));await B.save(this.manifestKey,n)}async _getLatestVersion(e){let n=`${this.name}/${e}/_latest`;try{let r=await B.load(n);return r?parseInt(G.decode(r),10):0}catch{return 0}}async _setLatestVersion(e,n){let r=`${this.name}/${e}/_latest`;await B.save(r,N.encode(String(n)))}async _loadTableVersion(e,n){let r=`${this.name}/${e}/_versions/${n}.manifest`,t=await B.load(r);if(!t)throw new Error(`Version ${n} not found for table '${e}'`);return JSON.parse(G.decode(t))}async _saveTableVersion(e,n){let r=`${this.name}/${e}/_versions/${n.version}.manifest`;await B.save(r,N.encode(JSON.stringify(n)))}async _createVersion(e,n){let r=this.tables.get(e);if(!r)return 0;let t=await this._getLatestVersion(e),s=t+1,l={version:s,timestamp:Date.now(),parentVersion:t,operation:n,schema:r.schema,fragments:[...r.fragments],deletionVector:[...r.deletionVector],rowCount:r.rowCount,nextRowId:r.nextRowId};return await this._saveTableVersion(e,l),await this._setLatestVersion(e,s),s}async listVersions(e){let n=await this._getLatestVersion(e),r=[];for(let t=1;t<=n;t++)try{let s=await this._loadTableVersion(e,t);r.push({version:s.version,timestamp:s.timestamp,operation:s.operation,rowCount:s.rowCount})}catch{}return r}async selectAtVersion(e,n,r={}){let t=await this._loadTableVersion(e,n),s=new Set(t.deletionVector),l=this.tables.get(e),o=[];for(let c of t.fragments){let f=await B.load(c);if(f){let d=this._parseFragment(f,t.schema);for(let p of d)s.has(p.__rowId)||o.push(p)}}let i=o;if(r.where&&(i=i.filter(r.where)),r.orderBy){let{column:c,desc:f}=r.orderBy;i.sort((d,p)=>{let m=d[c]<p[c]?-1:d[c]>p[c]?1:0;return f?-m:m})}r.offset&&(i=i.slice(r.offset)),r.limit&&(i=i.slice(0,r.limit));let a=r.columns&&r.columns.length>0&&r.columns[0]!=="*"?r.columns:null;return i.map(c=>{if(a){let f={};for(let d of a)f[d]=c[d];return f}else{let{__rowId:f,...d}=c;return d}})}async restoreToVersion(e,n){let r=await this._loadTableVersion(e,n),t=await this._getLatestVersion(e),s=t+1,l={...r,version:s,timestamp:Date.now(),parentVersion:t,operation:`RESTORE_FROM_${n}`};await this._saveTableVersion(e,l),await this._setLatestVersion(e,s);let o=this.tables.get(e);return o&&(o.fragments=[...r.fragments],o.deletionVector=[...r.deletionVector],o.rowCount=r.rowCount,o.nextRowId=r.nextRowId,this._columnarBuffer.delete(e),this._writeBuffer.delete(e),await this._saveManifest()),{restored:!0,newVersion:s}}async createTable(e,n,r=!1){if(this.tables.has(e)){if(r)return{success:!0,existed:!0};throw new Error(`Table '${e}' already exists`)}let t=n.map(l=>({name:l.name,type:xe[(l.dataType||l.type)?.toUpperCase()]||l.dataType||l.type||"string",primaryKey:l.primaryKey||!1,vectorDim:l.vectorDim||null})),s={name:e,schema:t,fragments:[],deletionVector:[],rowCount:0,nextRowId:0,version:0,createdAt:Date.now()};return this.tables.set(e,s),await this._saveManifest(),await this._createVersion(e,"CREATE"),{success:!0,table:e}}async dropTable(e,n=!1){if(!this.tables.has(e)){if(n)return this._writeBuffer.delete(e),{success:!0,existed:!1};throw new Error(`Table '${e}' does not exist`)}let r=this.tables.get(e);this._writeBuffer.delete(e);for(let t of r.fragments)this._readCache.delete(t),await B.delete(t);return this.tables.delete(e),await this._saveManifest(),{success:!0,table:e}}async insert(e,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=this.tables.get(e),t=n.length;if(!this._columnarBuffer.has(e)){let i=Math.max(1024,t*2),a={__rowId:new Float64Array(i),__length:0,__capacity:i,__schema:r.schema};for(let c of r.schema){let f=(c.dataType||c.type||"").toLowerCase();f==="text"||f==="string"||f==="varchar"?a[c.name]=new Array(i):f==="int64"||f==="bigint"?a[c.name]=new BigInt64Array(i):a[c.name]=new Float64Array(i)}this._columnarBuffer.set(e,a)}let s=this._columnarBuffer.get(e),l=s.__length,o=s.__capacity;if(l+t>o){let i=Math.max(o*2,l+t),a=new Float64Array(i);a.set(s.__rowId.subarray(0,l)),s.__rowId=a;for(let c of r.schema){let f=s[c.name];if(f instanceof Float64Array){let d=new Float64Array(i);d.set(f.subarray(0,l)),s[c.name]=d}else if(f instanceof BigInt64Array){let d=new BigInt64Array(i);d.set(f.subarray(0,l)),s[c.name]=d}else s[c.name].length=i}s.__capacity=i}for(let i=0;i<t;i++){let a=n[i];s.__rowId[l+i]=r.nextRowId++;for(let c of r.schema){let f=a[c.name];s[c.name]instanceof Float64Array?s[c.name][l+i]=f!=null?Number(f):NaN:s[c.name]instanceof BigInt64Array?s[c.name][l+i]=f!=null?BigInt(f):0n:s[c.name][l+i]=f??null}}return s.__length=l+t,r.rowCount+=t,r.version=(r.version||0)+1,this._scheduleFlush(),s.__length>=this._flushThreshold&&await this._flushTable(e),{success:!0,inserted:t}}_scheduleFlush(){this._flushTimer||(this._flushTimer=setTimeout(()=>{this._flushTimer=null,this.flush().catch(e=>console.warn("[WorkerDatabase] Flush error:",e))},this._flushInterval))}async flush(){if(!this._flushing){this._flushing=!0;try{let e=[...this._columnarBuffer.keys()];for(let n of e)await this._flushTable(n)}finally{this._flushing=!1}}}async _flushTable(e){let n=this._columnarBuffer.get(e),r=n?.__length||0;if(!n||r===0)return;let t=this.tables.get(e);if(!t)return;let s=[{name:"__rowId",type:"int64",dataType:"float64",primaryKey:!0},...t.schema.filter(c=>c.name!=="__rowId").map(c=>{let f=(c.dataType||c.type||"").toLowerCase();return f==="int64"||f==="bigint"?{...c,dataType:"int64"}:{...c,dataType:f==="float64"||f==="float32"||f==="int32"||f==="integer"||f==="real"||f==="double"?"float64":c.dataType||c.type||"float64"}})],l={};for(let c of s){let f=n[c.name];f&&(f instanceof Float64Array||f instanceof BigInt64Array?l[c.name]=f.subarray(0,r):l[c.name]=f.slice(0,r))}n.__length=0;let o=new ie(s);o.setColumnarData(l);let i=o.build(),a=`${this.name}/${e}/frag_${Date.now()}_${Math.random().toString(36).slice(2)}.lance`;await B.save(a,i),t.fragments.push(a),await this._saveManifest(),await this._createVersion(e,"INSERT")}async delete(e,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=this.tables.get(e),t=0,s=this._columnarBuffer.get(e),l=s?.__length||0;if(s&&l>0){let o=r.schema.map(i=>i.name);for(let i=0;i<l;i++){let a={__rowId:s.__rowId[i]};for(let c of o){let f=s[c][i];a[c]=Number.isNaN(f)?null:f}n(a)&&(r.deletionVector.includes(s.__rowId[i])||(r.deletionVector.push(s.__rowId[i]),t++))}}for(let o of r.fragments){let i=await B.load(o);if(i){let a=this._parseFragment(i,r.schema);for(let c of a)!r.deletionVector.includes(c.__rowId)&&n(c)&&(r.deletionVector.push(c.__rowId),t++)}}return r.rowCount-=t,r.version=(r.version||0)+1,await this._saveManifest(),t>0&&await this._createVersion(e,"DELETE"),{success:!0,deleted:t}}async update(e,n,r){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let t=this.tables.get(e),s=0,l=this._writeBuffer.get(e);if(l&&l.length>0)for(let i of l)r(i)&&(Object.assign(i,n),s++);let o=[];for(let i of t.fragments){let a=await B.load(i);if(a){let c=this._parseFragment(a,t.schema);for(let f of c)if(!t.deletionVector.includes(f.__rowId)&&r(f)){t.deletionVector.push(f.__rowId),t.rowCount--;let d={...f,...n};delete d.__rowId,o.push(d),s++}}}return o.length>0?await this.insert(e,o):await this._saveManifest(),s>0&&o.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:s}}async updateWithExpr(e,n,r,t){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=this.tables.get(e),l=0,o=this._columnarBuffer.get(e),i=o?.__length||0;if(o&&i>0){let c=s.schema.map(f=>f.name);for(let f=0;f<i;f++){let d={__rowId:o.__rowId[f]};for(let p of c){let m=o[p][f];d[p]=Number.isNaN(m)?null:m}if(r(d)){for(let[p,m]of Object.entries(n)){let h=t(m,d);o[p]!==void 0&&(o[p][f]=h??(o[p]instanceof Float64Array?NaN:null))}s.version=(s.version||0)+1,l++}}}let a=[];for(let c of s.fragments){let f=await B.load(c);if(f){let d=this._parseFragment(f,s.schema);for(let p of d)if(!s.deletionVector.includes(p.__rowId)&&r(p)){s.deletionVector.push(p.__rowId),s.rowCount--;let m={...p};for(let[h,g]of Object.entries(n))m[h]=t(g,p);delete m.__rowId,a.push(m),l++}}}return a.length>0?await this.insert(e,a):await this._saveManifest(),l>0&&a.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:l}}async select(e,n={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=await this._readAllRows(e);if(n.where&&(r=r.filter(n.where)),n.orderBy){let{column:l,desc:o}=n.orderBy;r.sort((i,a)=>{let c=i[l]<a[l]?-1:i[l]>a[l]?1:0;return o?-c:c})}n.offset&&(r=r.slice(n.offset)),n.limit&&(r=r.slice(0,n.limit));let t=n.columns&&n.columns.length>0&&n.columns[0]!=="*"?n.columns:null,s=new Array(r.length);for(let l=0;l<r.length;l++){let o=r[l];if(t){let i={};for(let a of t)i[a]=o[a];s[l]=i}else{let{__rowId:i,...a}=o;s[l]=a}}return s}async _readAllRows(e){let n=this.tables.get(e),r=this._columnarBuffer.get(e),s=n.deletionVector.length>0?new Set(n.deletionVector):null,l=[];for(let i of n.fragments){let a=this.bufferPool.get(i),c=null;if(!a){let f=await B.load(i);f&&(a=ne(f),a?this.bufferPool.set(i,a,f.byteLength):c=this._parseFragment(f,n.schema))}if(a&&!c&&(c=this._hydrateRowsFromBinary(a,n.schema)),c=c||[],!s)l.push(...c);else for(let f of c)s.has(f.__rowId)||l.push(f)}let o=r?.__length||0;if(r&&o>0){let i=n.schema.map(a=>a.name);for(let a=0;a<o;a++){if(s&&s.has(r.__rowId[a]))continue;let c={__rowId:r.__rowId[a]};for(let f of i){let d=r[f][a];c[f]=Number.isNaN(d)?null:d}l.push(c)}}return l}_hydrateRowsFromBinary(e,n){let{columns:r,rowCount:t}=e,s=n.map(o=>o.name),l=new Array(t);for(let o=0;o<t;o++){let i={__rowId:r.__rowId[o]};for(let a of s)r[a]&&(i[a]=r[a][o]);l[o]=i}return l}_parseFragment(e,n){try{let r=ne(e);if(r)return this._parseBinaryColumnar(r);let t=G.decode(e),s=JSON.parse(t);return s.format==="json"&&s.columns?this._parseJsonColumnar(s):Array.isArray(s)?s:[s]}catch(r){return console.warn("[WorkerDatabase] Failed to parse fragment:",r),[]}}async selectColumnar(e){let n=this.tables.get(e);if(!n)return null;let r=this._columnarBuffer.get(e)?.__length||0,t=`${n.fragments.length}:${r}:${n.deletionVector.length}:${n.version||0}`,s=this._columnarCache.get(e);if(s&&s.version===t){let h={};for(let[g,w]of Object.entries(s.data.columns))ArrayBuffer.isView(w)?h[g]=new w.constructor(w.buffer,w.byteOffset,w.length):h[g]=w;return{schema:n.schema,columns:h,rowCount:s.data.rowCount}}let o=n.deletionVector.length>0?new Set(n.deletionVector):null,i={},a=n.schema.map(h=>h.name);for(let h of a)i[h]=[];i.__rowId=[];for(let h of n.fragments){let g=this.bufferPool.get(h);if(!g){let A=await B.load(h);if(!A)continue;g=ne(A),g&&this.bufferPool.set(h,g,A.byteLength)}if(!g)continue;let{columns:w,rowCount:y}=g;if(o){let A=w.__rowId,_=[];for(let b=0;b<y;b++)o.has(A[b])||_.push(b);for(let b of a)if(w[b]){let T=w[b],S=new T.constructor(_.length);for(let L=0;L<_.length;L++)S[L]=T[_[L]];i[b].push(S)}}else{for(let A of a)w[A]&&i[A].push(w[A]);w.__rowId&&i.__rowId.push(w.__rowId)}}let c=this._columnarBuffer.get(e),f=c?.__length||0;if(c&&f>0)if(o){let h=[];for(let y=0;y<f;y++)o.has(c.__rowId[y])||h.push(y);let g=h.length;for(let y of n.schema){let A=c[y.name];if(A)if(A instanceof Float64Array){let _=new Float64Array(g);for(let b=0;b<g;b++)_[b]=A[h[b]];i[y.name].push(_)}else i[y.name].push(h.map(_=>A[_]))}let w=new Float64Array(g);for(let y=0;y<g;y++)w[y]=c.__rowId[h[y]];i.__rowId.push(w)}else{for(let g of n.schema){let w=c[g.name];if(w)if(w instanceof Float64Array){let y=new Float64Array(f);y.set(w.subarray(0,f)),i[g.name].push(y)}else i[g.name].push(w.slice(0,f))}let h=new Float64Array(f);h.set(c.__rowId.subarray(0,f)),i.__rowId.push(h)}let d={},p=0;for(let h of[...a,"__rowId"]){let g=i[h];if(g.length===0)d[h]=new Float64Array(0);else if(g.length===1)d[h]=g[0],p===0&&(p=g[0].length);else{let w=g.reduce((b,T)=>b+T.length,0);p===0&&(p=w);let y=g[0],A=ArrayBuffer.isView(y)?new y.constructor(w):new Array(w),_=0;for(let b of g){if(ArrayBuffer.isView(A))A.set(b,_);else for(let T=0;T<b.length;T++)A[_+T]=b[T];_+=b.length}d[h]=A}}let m={schema:n.schema,columns:d,rowCount:p};return this._columnarCache.set(e,{version:t,data:m}),m}async _readColumn(e,n){let r=this.tables.get(e);if(!r)return null;let t=this._writeBuffer.get(e),s=[];for(let a of r.fragments){let c=await B.load(a);if(!c)continue;let f=ne(c);if(f&&f.columns[n]){let d=f.columns[n];d.length>0&&s.push(d)}}if(t&&t.length>0){let a=new Float64Array(t.length);for(let c=0;c<t.length;c++){let f=t[c][n];a[c]=typeof f=="number"?f:0}s.push(a)}if(s.length===0)return new Float64Array(0);if(s.length===1)return s[0];let l=s.reduce((a,c)=>a+c.length,0),o=new Float64Array(l),i=0;for(let a of s)o.set(a,i),i+=a.length;return o}_parseBinaryColumnar(e){let{schema:n,columns:r,rowCount:t}=e,s=new Array(t),l=n.map(a=>a.name),o=l.map(a=>r[a]),i=l.length;for(let a=0;a<t;a++){let c={};for(let f=0;f<i;f++)c[l[f]]=o[f][a]??null;s[a]=c}return s}_parseJsonColumnar(e){let{schema:n,columns:r,rowCount:t}=e,s=new Array(t),l=n.map(a=>a.name),o=l.map(a=>r[a]||[]),i=l.length;for(let a=0;a<t;a++){let c={};for(let f=0;f<i;f++)c[l[f]]=o[f][a]??null;s[a]=c}return s}getTable(e){return this.tables.get(e)}listTables(){return Array.from(this.tables.keys())}getFragmentPaths(e){let n=this.tables.get(e);return n?n.fragments:[]}getColumnIndex(e,n){let r=this.tables.get(e);if(!r)return-1;let t=r.schema.findIndex(s=>s.name===n);return t>=0?t+1:-1}hasBufferedData(e){let n=this._columnarBuffer.get(e);return n&&(n.__length||0)>0}async compact(){for(let[e,n]of this.tables){let r=await this._readAllRows(e);for(let t of n.fragments)await B.delete(t);if(n.fragments=[],n.deletionVector=[],n.rowCount=0,n.nextRowId=0,r.length>0){let t=r.map(({__rowId:s,...l})=>l);await this.insert(e,t)}}return{success:!0,compacted:this.tables.size}}async scanStart(e,n={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=Ke++,t=this.tables.get(e),s=new Set(t.deletionVector),l=[];for(let i of t.fragments){let a=await B.load(i);if(a){let c=this._parseFragment(a,t.schema);for(let f of c)s.has(f.__rowId)||l.push(f)}}let o=this._writeBuffer.get(e);if(o)for(let i of o)s.has(i.__rowId)||l.push(i);return ge.set(r,{rows:l,index:0,batchSize:n.batchSize||1e4,columns:n.columns}),r}scanNext(e){let n=ge.get(e);if(!n)return{batch:[],done:!0};let r=[],t=Math.min(n.index+n.batchSize,n.rows.length);for(let l=n.index;l<t;l++){let o=n.rows[l],i;if(n.columns&&n.columns.length>0&&n.columns[0]!=="*"){i={};for(let a of n.columns)i[a]=o[a]}else{let{__rowId:a,...c}=o;i=c}r.push(i)}n.index=t;let s=n.index>=n.rows.length;return s&&ge.delete(e),{batch:r,done:s}}};var le=class{constructor(){this._root=null,this._ready=!1,this._kv={},this._encryptionKeyId=null,this._db=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:n,keyBytes:r}=e;if(!H.has(n)){let t=await re(r);H.set(n,t)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle("vault",{create:!0}),await this._loadKV(),this._db=new J("vault"),await this._db.open(),this._ready=!0}catch(n){throw console.error("[WorkerVault] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?H.get(this._encryptionKeyId):null}async _loadKV(){try{let e=this._getCryptoKey(),n=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(n)).getFile();if(e){let s=await t.arrayBuffer();this._kv=await oe(new Uint8Array(s),e)}else{let s=await t.text();this._kv=JSON.parse(s)}}catch(e){if(e.name==="NotFoundError")this._kv={};else throw e}}async _saveKV(){let e=this._getCryptoKey(),n=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(n,{create:!0})).createWritable();if(e){let s=await se(this._kv,e);await t.write(s)}else await t.write(JSON.stringify(this._kv));await t.close()}async get(e){return this._kv[e]}async set(e,n){this._kv[e]=n,await this._saveKV()}async delete(e){delete this._kv[e],await this._saveKV()}async keys(){return Object.keys(this._kv)}async has(e){return e in this._kv}};var je=1;var ke={INT64:0,FLOAT64:1,INT32:2,FLOAT32:3,STRING:4,LIST:5},ye=class{constructor(){this._registered=new Map}getLastError(){let e=M();if(!e)return"WASM not loaded";let n=P(),r=e.alloc(4096);console.log(`[WASM LOG] getLastError alloc ptr: ${r}`);let t=e.getLastError(r,4096);if(console.log(`[WASM LOG] getLastError len: ${t}`),t===0)return"Unknown Error";let s=new Uint8Array(n.buffer,r,t),l=new TextDecoder().decode(s);return console.log(`[WASM LOG] getLastError msg: ${l}`),l}getTableNames(e){let n=M();if(!n)throw new Error("WASM not loaded");let r=P(),t=new TextEncoder().encode(e),s=n.alloc(t.length);new Uint8Array(r.buffer,s,t.length).set(t);let l=n.getTableNames(s,t.length);if(l===0)return[];let o=new Uint8Array(r.buffer,l),i=0;for(;o[i]!==0&&i<1024;)i++;let a=new TextDecoder().decode(o.subarray(0,i));return a?a.split(",").filter(c=>c):[]}hasTable(e){let n=M();if(!n)return!1;let r=P(),t=new TextEncoder().encode(e),s=n.alloc(t.length);return new Uint8Array(r.buffer,s,t.length).set(t),n.hasTable(s,t.length)===1}registerTable(e,n,r,t=""){let s=M();if(!s)throw new Error("WASM not loaded");let l=this._registered.get(e);if(l&&l.version===t)return;if(l){let f=new TextEncoder().encode(e);s.clearTable(f,f.length)}let o=P();if(!o||!o.buffer)throw new Error("WASM memory not available");let i=new TextEncoder().encode(e),a=s.alloc(i.length);if(a<0||a>=o.buffer.byteLength)throw new Error(`Invalid alloc result: ${a} for ${i.length} bytes`);new Uint8Array(o.buffer,a,i.length).set(i);let c=new Set;for(let[f,d]of Object.entries(n)){if(f.startsWith("__")||Array.isArray(d)&&d.length===0)continue;let p=new TextEncoder().encode(f),m=s.alloc(p.length);if(m<0||m>=o.buffer.byteLength)throw new Error(`Invalid colName alloc: ${m}`);if(new Uint8Array(o.buffer,m,p.length).set(p),d instanceof Float64Array){let h=s.allocFloat64Buffer(d.length);if(h===0||h<0||h>=o.buffer.byteLength)throw new Error(`Invalid Float64 alloc: ${h} for ${d.length} elements`);new Float64Array(o.buffer,h,d.length).set(d),s.registerTableFloat64(a,i.length,m,p.length,h,d.length),c.add(f)}else if(d instanceof BigInt64Array){let h=s.allocInt64Buffer(d.length);new BigInt64Array(o.buffer,h,d.length).set(d),s.registerTableInt64(a,i.length,m,p.length,h,d.length),c.add(f)}else if(d instanceof Int32Array){let h=new Float64Array(d.length);for(let w=0;w<d.length;w++)h[w]=d[w];let g=s.allocFloat64Buffer(h.length);new Float64Array(o.buffer,g,h.length).set(h),s.registerTableFloat64(a,i.length,m,p.length,g,h.length),c.add(f)}else if(Array.isArray(d)){let h=new Uint32Array(d.length),g=new Uint32Array(d.length),w=0;for(let S=0;S<d.length;S++){let L=String(d[S]||"");g[S]=L.length,h[S]=w,w+=L.length}let y=new Uint8Array(w),A=0;for(let S=0;S<d.length;S++){let L=String(d[S]||""),C=new TextEncoder().encode(L);y.set(C,A),A+=C.length}let _=s.alloc(h.byteLength);if(_<0||_>=o.buffer.byteLength)throw new Error(`Invalid offsetsPtr alloc: ${_}`);new Uint32Array(o.buffer,_,h.length).set(h);let b=s.alloc(g.byteLength);if(b<0||b>=o.buffer.byteLength)throw new Error(`Invalid lengthsPtr alloc: ${b}`);new Uint32Array(o.buffer,b,g.length).set(g);let T=s.alloc(y.length||1);if(T<0||T>=o.buffer.byteLength)throw new Error(`Invalid dataPtr alloc: ${T}`);new Uint8Array(o.buffer,T,y.length).set(y),s.registerTableString(a,i.length,m,p.length,_,b,T,w,d.length),c.add(f)}}this._registered.set(e,{version:t,columns:c,rowCount:r})}registerTableFromFiles(e,n,r=""){let t=M();if(!t)throw new Error("WASM not loaded");let s=this._registered.get(e);if(s&&s.version===r)return;if(s){let a=new TextEncoder().encode(e);t.clearTable(a,a.length)}let l=new TextEncoder,o=l.encode(e),i=t.alloc(o.length);new Uint8Array(P().buffer,i,o.length).set(o);for(let a of n){let c=l.encode(a),f=t.alloc(c.length);new Uint8Array(P().buffer,f,c.length).set(c);let d=t.registerTableFromOPFS(i,o.length,f,c.length);d!==0&&console.warn(`Failed to register fragment ${a} for table ${e}: error ${d}`)}this._registered.set(e,{version:r,type:"files"})}appendTableMemory(e,n,r){let t=M();if(!t)throw new Error("WASM not loaded");let s=P(),l=new TextEncoder().encode(e),o=t.alloc(l.length);new Uint8Array(s.buffer,o,l.length).set(l);for(let[i,a]of Object.entries(n)){if(i.startsWith("__"))continue;let c=new TextEncoder().encode(i),f=t.alloc(c.length);if(new Uint8Array(s.buffer,f,c.length).set(c),a instanceof Float64Array){let d=t.allocFloat64Buffer(a.length);new Float64Array(s.buffer,d,a.length).set(a),t.appendTableMemory(o,l.length,f,c.length,d,4,r)}else if(a instanceof BigInt64Array){let d=t.allocInt64Buffer(a.length);new BigInt64Array(s.buffer,d,a.length).set(a),t.appendTableMemory(o,l.length,f,c.length,d,2,r)}else if(a instanceof Int32Array){let d=t.alloc(a.byteLength);new Int32Array(s.buffer,d,a.length).set(a),t.appendTableMemory(o,l.length,f,c.length,d,1,r)}else if(a instanceof Float32Array){let d=t.alloc(a.byteLength);new Float32Array(s.buffer,d,a.length).set(a),t.appendTableMemory(o,l.length,f,c.length,d,3,r)}}}execute(e){let n=M();if(!n)throw new Error("WASM not loaded");let r=P();if(n.setCurrentTimestamp)try{n.setCurrentTimestamp(BigInt(Date.now()))}catch(d){console.warn("setCurrentTimestamp failed:",d)}let t=n.getSqlInputBuffer(),s=n.getSqlInputBufferSize(),l=new TextEncoder().encode(e);if(l.length>s)throw new Error(`SQL too long: ${l.length} > ${s}`);new Uint8Array(r.buffer,t,l.length).set(l),n.setSqlInputLength(l.length);let o=n.executeSql();if(o===0){let d=this.getLastError();throw console.log(`[WASM LOG] execute throwing: "${d}"`),new Error(d)}let i=n.getResultSize(),a=this.getLastError();a&&a.length>0&&console.log(`[WASM DEBUG CAPTURED] ${a}`),a.length>0&&a.startsWith("DEBUG:");let c=n.memory.buffer,f=this._parseResult(r.buffer,o,i);return n.resetResult(),f}_parseResult(e,n,r){let t=new DataView(e,n,r),s=new TextDecoder;if(r>=40){let l=r-40,o=[t.getUint8(l+36),t.getUint8(l+37),t.getUint8(l+38),t.getUint8(l+39)];if(String.fromCharCode(...o)==="LANC")return this._parseLanceResult(e,n,r,l,t,s)}if(r>=36&&t.getUint32(0,!0)===je)return this._parseLegacyResult(e,n,r);throw new Error(`Invalid result format (Size: ${r}). Not a Lance file.`)}_parseLanceResult(e,n,r,t,s,l){let o=Number(s.getBigUint64(t+8,!0)),i=s.getUint32(t+28,!0),a=[],c={},f=0;for(let d=0;d<i;d++){let p=o+d*8,h=Number(s.getBigUint64(p,!0));s.getUint8(h++);let[g,w]=this._readVarint(s,h);h+=w;let y=new Uint8Array(e,n+h,g),A=l.decode(y);h+=g,a.push(A),s.getUint8(h++);let[_,b]=this._readVarint(s,h);h+=b;let T=new Uint8Array(e,n+h,_),S=l.decode(T);h+=_,s.getUint8(h++);let[L,C]=this._readVarint(s,h);h+=C,s.getUint8(h++);let x=Number(s.getBigUint64(h,!0));h+=8,s.getUint8(h++);let[E,k]=this._readVarint(s,h);h+=k,f=E,s.getUint8(h++);let[V,ee]=this._readVarint(s,h);h+=ee;let z=n+x;if(S==="float64"||S==="int64"||S==="int32"||S==="float32")if(S==="float64"){let R=new Float64Array(e,z,E).slice(),O=!1;for(let F=0;F<E;F++)if(Number.isNaN(R[F])){O=!0;break}if(O){console.log(`[WASM LOG] Column ${A} has NaNs, converting to nulls`);let F=new Array(E);for(let v=0;v<E;v++){let j=R[v];F[v]=Number.isNaN(j)?null:j}c[A]=F}else c[A]=R}else if(S==="int64"){let R=new BigInt64Array(e,z,E),O=new Array(E),F=-9223372036854775808n;for(let v=0;v<E;v++){let j=R[v];O[v]=j===F?null:Number(j)}c[A]=O}else if(S==="int32"){let R=new Int32Array(e,z,E),O=new Array(E);for(let F=0;F<E;F++){let v=R[F];v===-2147483648?O[F]=null:O[F]=v}c[A]=O}else{let R=new Float32Array(e,z,E),O=new Array(E);for(let F=0;F<E;F++){let v=R[F];O[F]=isNaN(v)?null:v}c[A]=O}else if(S==="string"||S==="list"){let R=S==="list",O=(E+1)*4,F=V-O,v=new Uint8Array(e,z,F).slice(),j=new Uint32Array(e,z+F,E+1).slice();c[A]={_arrowString:!0,offsets:j,bytes:v,isList:S==="list",nullable:L===1}}}return{_format:"columnar",columns:a,rowCount:f,data:c}}_readVarint(e,n){let r=0,t=0,s=0;for(;;){let l=e.getUint8(n+s);if(s++,r|=(l&127)<<t,(l&128)===0)break;t+=7}return[r,s]}_parseLegacyResult(e,n,r){let t=new DataView(e,n,r),s=new TextDecoder,l=t.getUint32(4,!0),o=Number(t.getBigUint64(8,!0)),i=t.getUint32(24,!0),a=t.getUint32(32,!0),c=[],f={};for(let d=0;d<l;d++){let p=36+d*16,m=t.getUint32(p,!0),h=t.getUint32(p+4,!0),g=t.getUint32(p+8,!0),w=t.getUint32(p+12,!0),y=new Uint8Array(e,n+a+h,g),A=s.decode(y);c.push(A);let _=Object.keys(ke).find(T=>ke[T]===m).toLowerCase(),b=n+i+w;if(_==="float64"||_==="int64"||_==="int32"||_==="float32")_==="float64"?f[A]=new Float64Array(e,b,o).slice():_==="int64"?f[A]=new Float64Array(e,b,o).slice():_==="int32"?f[A]=new Int32Array(e,b,o).slice():_==="float32"&&(f[A]=new Float32Array(e,b,o).slice());else if(_==="string"||_==="list"){let T=new Uint32Array(o+1),S=0;T[0]=0;let L=b,C=0;for(let k=0;k<o;k++){let V=t.getUint32(L+k*8+4,!0);C+=V,T[k+1]=C}let x=b+o*8,E=new Uint8Array(e,x,C).slice();f[A]={_arrowString:!0,offsets:T,bytes:E,isList:_==="list"}}}return{_format:"columnar",columns:c,rowCount:o,data:f}}clear(){let e=M();e&&e.clearTables(),this._registered.clear()}},me=null;function pe(){return me||(me=new ye),me}var be={showVersions:/^\s*SHOW\s+VERSIONS\s+FOR\s+(\w+)\s*$/i,restoreTable:/^\s*RESTORE\s+(\w+)\s+TO\s+VERSION\s+(\d+)\s*$/i,versionAsOf:/FROM\s+(\w+)\s+VERSION\s+AS\s+OF\s+(\d+)/i};function Oe(u){let e;return(e=u.match(be.showVersions))?{type:"SHOW_VERSIONS",table:e[1]}:(e=u.match(be.restoreTable))?{type:"RESTORE_TABLE",table:e[1],version:parseInt(e[2],10)}:(e=u.match(be.versionAsOf))?{type:"SELECT_VERSION",table:e[1],version:parseInt(e[2],10),sql:u}:null}function Ge(u){let e=/^(SELECT|FROM|WHERE|JOIN|LEFT|RIGHT|INNER|OUTER|ON|AND|OR|NOT|IN|LIKE|BETWEEN|GROUP|ORDER|BY|HAVING|LIMIT|OFFSET|UNION|EXCEPT|INTERSECT|AS|NULL|TRUE|FALSE|IS|CASE|WHEN|THEN|ELSE|END|DISTINCT|ALL|ASC|DESC|CREATE|DROP|INSERT|UPDATE|DELETE|INTO|VALUES|TABLE|INDEX|VIEW|SET|WITH|RECURSIVE)$/i,n=/read_lance\s*\(\s*'([^']+)'\s*\)(?:\s+AS\s+(\w+)|\s+(\w+))?/gi,r=[],t;for(;(t=n.exec(u))!==null;){let s=t[2],l=t[3];l&&e.test(l)&&(l=null);let o=s||l||`_tbl${r.length}`,i=t[0];t[3]&&e.test(t[3])&&(i=`read_lance('${t[1]}')`),console.log(`[Worker] extractReadLanceUrls: found "${i}" -> alias "${o}"`),r.push({fullMatch:i,url:t[1],alias:o})}return console.log(`[Worker] extractReadLanceUrls: found ${r.length} URLs`),r}function qe(u,e){let n=u;for(let{fullMatch:r,alias:t}of e)console.log(`[Worker] rewriteSqlWithAliases: replacing "${r}" with "${t}"`),n=n.replace(r,t);return console.log(`[Worker] rewriteSqlWithAliases: result = "${n}"`),n}async function ze(u,e=1e4){try{console.log(`[Worker] Fetching remote Lance: ${u}`);let n=`${u}/.meta.json`,r=null,t=[],s=[];try{let a=await fetch(n);if(a.ok){let c=await a.json();r=c.schema,t=c.fragments||[],s=r.map(f=>{let d=f.type;return d.startsWith("vector[")?"vector":d==="float64"||d==="double"?"float64":d==="float32"?"float32":d.includes("int64")?"int64":d.includes("int")?"int32":d==="string"?"string":"unknown"}),console.log(`[Worker] Loaded sidecar: ${r.length} columns, ${t.length} fragments`)}}catch(a){console.log(`[Worker] No sidecar available: ${a.message}`)}if(!r){let a=0,c=[1,5,10,20,50,100];for(let m of c)try{(await fetch(`${u}/_versions/${m}.manifest`,{method:"HEAD"})).ok&&(a=m)}catch{}if(a>0)for(let m=a+1;m<=a+50;m++)try{if((await fetch(`${u}/_versions/${m}.manifest`,{method:"HEAD"})).ok)a=m;else break}catch{break}if(a===0)return console.error(`[Worker] No manifest found for ${u}`),null;let f=await fetch(`${u}/_versions/${a}.manifest`);if(!f.ok)return null;let d=new Uint8Array(await f.arrayBuffer()),p=Qe(d);r=p.schema,t=p.fragments,s=r.map(m=>m.type||"unknown")}if(!r||r.length===0)return console.error(`[Worker] No schema found for ${u}`),null;if(t.length===0)return console.error(`[Worker] No fragments found for ${u}`),null;let l=t[0].data_files?.[0]||`${t[0].id}.lance`,o=`${u}/data/${l}`;return await Je(o,r,s,e)}catch(n){return console.error("[Worker] Failed to fetch remote Lance:",n),null}}function Qe(u){let e=new DataView(u.buffer,u.byteOffset),n=[],r=[],t=e.getUint32(0,!0),s=4+t,l;if(s+4<u.length){let c=e.getUint32(s,!0);c>0&&s+4+c<=u.length?l=u.slice(s+4,s+4+c):l=u.slice(4,4+t)}else l=u.slice(4,4+t);let o=0,i=()=>{let c=0,f=0;for(;o<l.length;){let d=l[o++];if(c|=(d&127)<<f,(d&128)===0)break;f+=7}return c},a=c=>{c===0?i():c===2?o+=i():c===5?o+=4:c===1&&(o+=8)};for(;o<l.length;){let c=i(),f=c>>3,d=c&7;if(f===1&&d===2){let p=i(),m=o+p,h=null,g=null,w=null;for(;o<m;){let y=i(),A=y>>3,_=y&7;if(_===0){let b=i();A===3&&(g=b)}else if(_===2){let b=i(),T=l.slice(o,o+b);o+=b,A===2?h=new TextDecoder().decode(T):A===5&&(w=new TextDecoder().decode(T))}else a(_)}h&&n.push({name:h,id:g,type:w})}else if(f===2&&d===2){let p=i(),m=o+p,h=null,g=null,w=0;for(;o<m;){let y=i(),A=y>>3,_=y&7;if(_===0){let b=i();A===1?h=b:A===4&&(w=b)}else if(_===2){let b=i(),T=l.slice(o,o+b);if(o+=b,A===2){let S=0;for(;S<T.length;){let L=T[S++],C=L>>3,x=L&7;if(x===2){let E=0,k=0;for(;S<T.length;){let V=T[S++];if(E|=(V&127)<<k,(V&128)===0)break;k+=7}C===1&&(g=new TextDecoder().decode(T.slice(S,S+E))),S+=E}else if(x===0)for(;S<T.length&&(T[S++]&128)!==0;);else x===5?S+=4:x===1&&(S+=8)}}}else a(_)}g&&r.push({id:h,data_files:[g],num_rows:w})}else a(d)}return{schema:n,fragments:r}}async function Je(u,e,n,r){if(console.log(`[Worker] Fetching fragment: ${u}`),!I&&(await Z(),!I))throw new Error("WASM not loaded");let t=await fetch(u,{method:"HEAD"});if(!t.ok)throw new Error(`Failed to check fragment size: HTTP ${t.status}`);let s=parseInt(t.headers.get("Content-Length")||"0",10),l=100*1024*1024;if(s>l){console.warn(`[Worker] Fragment too large (${(s/1024/1024).toFixed(1)}MB) - using schema-based placeholder data`);let w={},y=[],A=Math.min(r,100);for(let _=0;_<e.length;_++){let b=e[_].name,T=n[_];y.push(b),T==="float64"||T==="double"||T==="int64"||T==="int32"||T==="float32"?w[b]=new Float64Array(A).fill(0):T==="string"?w[b]=Array(A).fill("(large file - use RemoteLanceDataset)"):w[b]=[]}return{columns:w,rowCount:A,columnNames:y}}let o=await fetch(u);if(!o.ok)throw new Error(`Failed to fetch fragment: HTTP ${o.status}`);let i=new Uint8Array(await o.arrayBuffer());if(console.log(`[Worker] Fetched fragment: ${i.length} bytes`),i.length<40)throw new Error("Fragment too small");let a=String.fromCharCode(i[i.length-4],i[i.length-3],i[i.length-2],i[i.length-1]);if(a!=="LANC")throw new Error(`Invalid Lance magic: ${a}`);let c=I.alloc(i.length);if(!c||c<0)throw new Error("Failed to allocate WASM memory for fragment");new Uint8Array(U.buffer,c,i.length).set(i);let f=I.openFile(c,i.length);if(f!==0)throw new Error(`WASM openFile failed: ${f}`);let d=I.getNumColumns(),p=Number(I.getRowCount(0)),m=Math.min(p,r);console.log(`[Worker] Fragment has ${d} columns, ${p} rows, reading ${m}`);let h={},g=[];for(let w=0;w<e.length&&w<d;w++){let y=e[w].name,A=n[w];g.push(y);try{if(A==="float64"||A==="double"){let _=I.allocFloat64Buffer(m);if(_){let b=I.readFloat64Column(w,_,m);h[y]=new Float64Array(U.buffer,_,b).slice()}else h[y]=new Float64Array(m).fill(0)}else if(A==="int64"){let _=I.allocInt64Buffer(m);if(_){let b=I.readInt64Column(w,_,m),T=new BigInt64Array(U.buffer,_,b),S=new Float64Array(b);for(let L=0;L<b;L++)S[L]=Number(T[L]);h[y]=S}else h[y]=new Float64Array(m).fill(0)}else if(A==="int32"){let _=I.allocInt32Buffer(m);if(_){let b=I.readInt32Column(w,_,m),T=new Int32Array(U.buffer,_,b),S=new Float64Array(b);for(let L=0;L<b;L++)S[L]=T[L];h[y]=S}else h[y]=new Float64Array(m).fill(0)}else if(A==="float32"){let _=I.alloc(m*4);if(_&&_>0){let b=I.readFloat32Column(w,_,m),T=new Float32Array(U.buffer,_,b),S=new Float64Array(b);for(let L=0;L<b;L++)S[L]=T[L];h[y]=S}else h[y]=new Float64Array(m).fill(0)}else A==="string"?h[y]=Array(m).fill("(string data)"):A==="vector"?h[y]=[]:h[y]=[]}catch(_){console.warn(`[Worker] Failed to read column ${y}:`,_),h[y]=[]}}return I.closeFile(),console.log(`[Worker] Read ${m} rows from ${g.length} columns`),{columns:h,rowCount:m,columnNames:g}}function We(u,e){let n=0,r=0,t=0;for(;e+t<u.length;){let s=u[e+t];if(t++,n|=(s&127)<<r,(s&128)===0||(r+=7,r>35))break}return[n,t]}function Ye(u,e,n,r){let t=new DataView(u.buffer,u.byteOffset),s=u.length-40,l=Number(t.getBigUint64(s,!0)),o=Number(t.getBigUint64(s+8,!0)),i=t.getUint32(s+28,!0);console.log(`[Worker] parseLanceFileData: ${i} columns, metaStart=${l}, offsetsStart=${o}`);let a={},c=[],f=0;for(let d=0;d<i&&d<e.length;d++){let p=o+d*8;if(p+8>u.length){console.warn(`[Worker] Column ${d} offset position out of bounds`);continue}let m=Number(t.getBigUint64(p,!0));if(m>=u.length){console.warn(`[Worker] Column ${d} metadata position ${m} out of bounds`);continue}let h=m,g=e[d]?.name||`col_${d}`,w=n[d]||"unknown",y=0,A=0,_=0;for(;h<u.length&&h<m+500;){let S=u[h],L=S>>3,C=S&7;if(h++,L===0)break;if(C===0){let[x,E]=We(u,h);h+=E,L===3||(L===5?A=x:L===6&&(_=x))}else if(C===1){if(h+8>u.length)break;L===4&&(y=Number(t.getBigUint64(h,!0))),h+=8}else if(C===2){let[x,E]=We(u,h);if(h+=E,h+x>u.length)break;L===1?g=new TextDecoder().decode(u.slice(h,h+x)):L===2&&(w=new TextDecoder().decode(u.slice(h,h+x))),h+=x}else if(C===5)h+=4;else break}c.push(g),f===0&&(f=A),console.log(`[Worker] Column ${d}: name=${g}, type=${w}, dataOffset=${y}, rowCount=${A}, dataSize=${_}`);let b=Math.min(f,r);if(b===0||y===0){console.log(`[Worker] Column ${g}: skipping (actualRows=${b}, dataOffset=${y})`),a[g]=[];continue}let T=n[d]||w;try{if(T==="float64"||w==="float64"||w==="double")a[g]=new Float64Array(u.buffer,u.byteOffset+y,b).slice();else if(T==="int64"||w==="int64"){let S=new BigInt64Array(u.buffer,u.byteOffset+y,b);a[g]=new BigInt64Array(S)}else if(T==="int32"||w==="int32")a[g]=new Int32Array(u.buffer,u.byteOffset+y,b).slice();else if(T==="float32"||w==="float32")a[g]=new Float32Array(u.buffer,u.byteOffset+y,b).slice();else if(T==="string"||w==="string"){let S=(b+1)*4,L=_-S;if(L>0&&y+_<=u.length){let C=new Uint32Array(u.buffer,u.byteOffset+y+L,b+1),x=u.slice(y,y+L),E=[];for(let k=0;k<b;k++){let V=C[k],ee=C[k+1];V<=ee&&ee<=x.length?E.push(new TextDecoder().decode(x.slice(V,ee))):E.push("")}a[g]=E}else a[g]=[]}else T==="vector"||w.startsWith("fixed_size_list")?a[g]=[]:a[g]=[]}catch(S){console.warn(`[Worker] Failed to read column ${g}:`,S),a[g]=[]}}return{columns:a,rowCount:Math.min(f,r),columnNames:c}}async function Ue(u,e=1e4){try{console.log(`[Worker] Loading OPFS Lance: ${u}`);let n=u.split("/").filter(h=>h),r=n.pop(),l=await(await(await Ie(n)).getFileHandle(r)).getFile(),o=new Uint8Array(await l.arrayBuffer());if(!o||o.length===0)return console.error(`[Worker] Empty OPFS file: ${u}`),null;if(o.length<40)return console.error(`[Worker] File too small for Lance format: ${u}`),null;let i=String.fromCharCode(o[o.length-4],o[o.length-3],o[o.length-2],o[o.length-1]);if(i!=="LANC")return console.error(`[Worker] Invalid Lance magic in ${u}: ${i}`),null;let a=new DataView(o.buffer,o.byteOffset),c=o.length-40,f=Number(a.getBigUint64(c+8,!0)),d=a.getUint32(c+28,!0),p=[],m=[];for(let h=0;h<d;h++){let g=f+h*8,y=Number(a.getBigUint64(g,!0));o[y++];let A=o[y++],_=new TextDecoder().decode(o.slice(y,y+A));y+=A,o[y++];let b=o[y++],T=new TextDecoder().decode(o.slice(y,y+b));p.push({name:_,type:T}),m.push(T)}return Ye(o,p,m,e)}catch(n){return console.error("[Worker] Failed to load OPFS Lance:",n),null}}async function Re(u,e){if(!I&&(await Z(),!I))throw new Error("WASM not loaded");let n=e.replace(/--[^\n]*/g,"").replace(/\/\*[\s\S]*?\*\//g,"").trim(),r=pe(),t=Ge(n);for(let{url:o,alias:i}of t){if(r.hasTable(i)){console.log(`[Worker] Table ${i} already registered`);continue}let a=null,c=null;try{if(o.startsWith("https://")||o.startsWith("http://"))console.log(`[Worker] Fetching remote Lance: ${o} as ${i}`),a=await ze(o);else if(o.startsWith("opfs://")){let f=o.replace("opfs://","");console.log(`[Worker] Loading OPFS Lance: ${f} as ${i}`),a=await Ue(f)}else console.log(`[Worker] Loading OPFS Lance (no prefix): ${o} as ${i}`),a=await Ue(o)}catch(f){c=f,console.error(`[Worker] Failed to load ${o}:`,f)}if(a){if(console.log(`[Worker] Registering table ${i} with ${a.rowCount} rows, columns: ${Object.keys(a.columns).join(", ")}`),r.registerTable(i,a.columns,a.rowCount,o),!r.hasTable(i))throw new Error(`Failed to register table ${i} from ${o}`)}else{let f=c?c.message:"file may not exist or returned empty data";throw new Error(`Could not load read_lance('${o}'): ${f}`)}}let s=t.length>0?qe(n,t):n,l=r.getTableNames(s);for(let o of l){if(r.hasTable(o))continue;let a=u.tables.get(o);if(!a)continue;let c=u._columnarBuffer?.get(o),f=c?.__length||0,d=`${o}:${a.fragments?.length||0}:${f}:${a.deletionVector?.length||0}`,p=a.fragments.length>0,m=f>0;if(p){let h=[];for(let g of a.fragments){let w=await et(g);w&&h.push(w)}if(r.registerTableFromFiles(o,a.fragments,d),m){let g={};for(let w of a.schema){let y=c[w.name];y&&ArrayBuffer.isView(y)&&(g[w.name]=y.subarray(0,f))}r.appendTableMemory(o,g,f)}}else if(m){let h=await u.selectColumnar(o);if(h){let{columns:g,rowCount:w}=h;r.registerTable(o,g,w,d)}}}return r.execute(s)}var I=null,U=null,X=new Map,Xe=1;async function Ie(u){let e=await navigator.storage.getDirectory();e=await e.getDirectoryHandle("lanceql",{create:!0});for(let n of u)e=await e.getDirectoryHandle(n,{create:!0});return e}function Ze(){return{env:{opfs_open:(u,e)=>{try{let n=new Uint8Array(U.buffer,u,e),r=new TextDecoder().decode(n);for(let[t,s]of X.entries())if(s._path===r)return t;return console.warn("[LanceQLWorker] WASM tried to open unregistered path:",r),0}catch(n){return console.error("[LanceQLWorker] Error:",n),0}},opfs_read:(u,e,n,r)=>{let t=X.get(u);if(!t)return 0;try{let s=new Uint8Array(U.buffer,e,n);return t.read(s,{at:Number(r)})}catch{return 0}},opfs_size:u=>{let e=X.get(u);if(!e)return BigInt(0);try{return BigInt(e.getSize())}catch{return BigInt(0)}},opfs_close:u=>{},__assert_fail:(u,e,n,r)=>{let s=new TextDecoder().decode(new Uint8Array(U.buffer,u).subarray(0,100));console.error(`[WASM ASSERT] ${s} at line ${n}`)},js_log:(u,e)=>{let r=new TextDecoder().decode(new Uint8Array(U.buffer,u,e));console.log(`[WASM LOG] ${r}`);for(let t of Ee)t.postMessage({type:"log",message:r,marker:"__WASM_LOG_BRIDGE__"})}}}}async function et(u){try{let e=u.split("/").filter(o=>o),n=e.pop(),s=await(await(await Ie(e)).getFileHandle(n)).createSyncAccessHandle(),l=Xe++;return s._path=u,X.set(l,s),l}catch(e){return console.warn("[LanceQLWorker] Failed to register OPFS file:",u,e),0}}function Rt(u){let e=X.get(u);if(e){try{e.close()}catch{}X.delete(u)}}async function Z(){if(I)return I;try{let u=new URL("./lanceql.wasm",import.meta.url);u.searchParams.set("v",Date.now().toString());let n=await(await fetch(u)).arrayBuffer(),r=Ze();return I=(await WebAssembly.instantiate(n,r)).instance.exports,U=I.memory,console.log("[LanceQLWorker] WASM loaded with OPFS support"),I}catch(u){return console.warn("[LanceQLWorker] WASM not available:",u.message),null}}function M(){return I}function P(){return U}var _e=0,De=0,tt=1024*1024;function nt(u){if(!I)return 0;if(u<=De&&_e!==0)return _e;let e=Math.max(u,tt),n=I.alloc(e);return n&&(_e=n,De=e),n}async function Dt(u){let e=await Z();if(!e)return 0;try{let n=u.split("/").filter(f=>f),r=n.pop(),l=await(await(await Ie(n)).getFileHandle(r)).createSyncAccessHandle(),o=l.getSize(),i=nt(o);if(!i)return l.close(),0;let a=new Uint8Array(U.buffer,i,o),c=l.read(a,{at:0});return l.close(),c!==o?0:e.openFile(i,o)}catch(n){return console.warn("[LanceQLWorker] Failed to load fragment:",u,n),0}}async function rt(u,e){let n=e.split("/").filter(t=>t),r=u;for(let t=0;t<n.length-1;t++)r=await r.getDirectoryHandle(n[t],{create:!1});return await r.getFileHandle(n[n.length-1],{create:!1})}var Ae=null;async function st(u){let e=Le.get(u);if(e)return e;Ae||(Ae=await navigator.storage.getDirectory());let t=await(await(await rt(Ae,u)).getFile()).arrayBuffer();return e=new Uint8Array(t),e&&Le.set(u,e,e.byteLength),e}async function Nt(u,e,n){if(!await st(u))return null;let t=I;switch(n){case"sum":return t.opfsSumFloat64Column(e);case"min":return t.opfsMinFloat64Column(e);case"max":return t.opfsMaxFloat64Column(e);case"avg":return t.opfsAvgFloat64Column(e);case"count":return Number(t.opfsCountRows());default:return null}}Z();var Le=new Q,Te=new Map,Se=new Map,ce=null,Ee=new Set,Y=null,q=0,ot=1024,fe=new Map,Ne=1;async function K(u=null){return ce||(ce=new le),await ce.open(u),ce}async function W(u,e={},n=null){let r=n?.keyId||"none",t=`${u}:${r}:${JSON.stringify(e)}`;if(!Te.has(t)){let s=new ae(u,e);await s.open(n),Te.set(t,s)}return Te.get(t)}async function $(u){if(!Se.has(u)){let e=new J(u,Le);await e.open(),Se.set(u,e)}return Se.get(u)}function at(u,e,n){if(n&&n._format==="wasm_binary"){u.postMessage({id:e,result:{_format:"wasm_binary",buffer:n.buffer,columns:n.columns,rowCount:n.rowCount,schema:n.schema}},[n.buffer]);return}if(n&&n._format==="columnar"&&n.data){let r=n.columns,t=n.rowCount;if(t<1e5){let p=[],m={},h=new Set;for(let g of r){let w=n.data[g];if(ArrayBuffer.isView(w)){let y=w.byteOffset!==0||w.byteLength<w.buffer.byteLength,A=h.has(w.buffer);if(y||A){let _=new w.constructor(w);m[g]=_,p.push(_.buffer)}else m[g]=w,p.push(w.buffer),h.add(w.buffer)}else w&&w._arrowString?(m[g]=w,w.offsets&&w.offsets.buffer&&!h.has(w.offsets.buffer)&&(p.push(w.offsets.buffer),h.add(w.offsets.buffer)),w.bytes&&w.bytes.buffer&&!h.has(w.bytes.buffer)&&(p.push(w.bytes.buffer),h.add(w.bytes.buffer))):m[g]=w}u.postMessage({id:e,result:{_format:"columnar",columns:r,rowCount:t,data:m}},p);return}let s=[],l=[],o=0;for(let p of r){let m=n.data[p];ArrayBuffer.isView(m)?(s.push({name:p,arr:m}),o+=m.byteLength):Array.isArray(m)&&l.push({name:p,arr:m})}let i=o>0?new ArrayBuffer(o):null,a={},c=0;if(i){let p=new Uint8Array(i);for(let{name:m,arr:h}of s){let g=new Uint8Array(h.buffer,h.byteOffset,h.byteLength);p.set(g,c),a[m]={offset:c,length:h.length,type:h.constructor.name},c+=h.byteLength}}let f={};for(let{name:p,arr:m}of l)f[p]=m;let d=[];i&&d.push(i),u.postMessage({id:e,result:{_format:"packed",columns:r,rowCount:t,packedBuffer:i,colOffsets:a,stringData:f}},d);return}if(Y&&n!==void 0){let r=JSON.stringify(n);if(r.length>ot){let t=N.encode(r);if(q+t.length<=Y.byteLength){new Uint8Array(Y,q,t.length).set(t),u.postMessage({id:e,sharedOffset:q,sharedLength:t.length}),q+=t.length,q>Y.byteLength/2&&(q=0);return}}}u.postMessage({id:e,result:n})}async function Ve(u,e){if(e.type==="initSharedBuffer"){Y=e.buffer,q=0,console.log("[LanceQLWorker] SharedArrayBuffer initialized:",Y.byteLength,"bytes");return}let{id:n,method:r,args:t}=e;try{let s;if(r==="ping")s="pong";else if(r==="open")await W(t.name,t.options,t.encryption),s=!0;else if(r==="get")s=await(await W(t.name)).get(t.key);else if(r==="set")await(await W(t.name)).set(t.key,t.value),s=!0;else if(r==="delete")await(await W(t.name)).delete(t.key),s=!0;else if(r==="keys")s=await(await W(t.name)).keys();else if(r==="clear")await(await W(t.name)).clear(),s=!0;else if(r==="filter")s=await(await W(t.name)).filter(t.key,t.query);else if(r==="find")s=await(await W(t.name)).find(t.key,t.query);else if(r==="search")s=await(await W(t.name)).search(t.key,t.text,t.limit);else if(r==="count")s=await(await W(t.name)).count(t.key,t.query);else if(r==="enableSemanticSearch")s=await(await W(t.name)).enableSemanticSearch(t.options);else if(r==="disableSemanticSearch")(await W(t.name)).disableSemanticSearch(),s=!0;else if(r==="hasSemanticSearch")s=(await W(t.name)).hasSemanticSearch();else if(r==="db:open")console.log(`[LanceQLWorker] db:open ${t.name}`),await $(t.name),s=!0;else if(r==="db:createTable")console.log(`[LanceQLWorker] db:createTable ${t.tableName}`),s=await(await $(t.db)).createTable(t.tableName,t.columns,t.ifNotExists),console.log(`[LanceQLWorker] db:createTable ${t.tableName} done`);else if(r==="db:dropTable"){console.log(`[LanceQLWorker] db:dropTable ${t.tableName}`),s=await(await $(t.db)).dropTable(t.tableName,t.ifExists);let o=N.encode(t.tableName);pe().clearTable(o,o.length)}else if(r==="db:insert")console.log(`[LanceQLWorker] db:insert into ${t.tableName}, rows: ${t.rows?.length}`),s=await(await $(t.db)).insert(t.tableName,t.rows),console.log("[LanceQLWorker] db:insert done");else if(r==="db:delete"){let l=await $(t.db),o=t.where?i=>evalWhere(t.where,i):()=>!0;s=await l.delete(t.tableName,o)}else if(r==="db:update"){let l=await $(t.db),o=t.where?i=>evalWhere(t.where,i):()=>!0;s=await l.update(t.tableName,t.updates,o)}else if(r==="db:select"){let l=await $(t.db),o={...t.options};t.where&&(o.where=i=>evalWhere(t.where,i)),s=await l.select(t.tableName,o)}else if(r==="db:exec"){let l=await $(t.db),o=Oe(t.sql);if(o?.type==="SHOW_VERSIONS"){let i=await l.listVersions(o.table);s={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:i.length,data:{version:new Float64Array(i.map(a=>a.version)),timestamp:i.map(a=>new Date(a.timestamp).toISOString()),operation:i.map(a=>a.operation),rowCount:new Float64Array(i.map(a=>a.rowCount))}}}else if(o?.type==="RESTORE_TABLE"){let i=await l.restoreToVersion(o.table,o.version);s={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([i.newVersion])}}}else if(o?.type==="SELECT_VERSION"){let i=await l.selectAtVersion(o.table,o.version,{});if(i.length>0){let a=Object.keys(i[0]),c={};for(let f of a)c[f]=i.map(d=>d[f]);s={_format:"columnar",columns:a,rowCount:i.length,data:c}}else s={_format:"columnar",columns:[],rowCount:0,data:{}}}else s=await Re(l,t.sql);if(s&&s._format==="columnar"&&s.rowCount>=1e5){let i=Ne++;fe.set(i,s),s={_format:"cursor",cursorId:i,columns:s.columns,rowCount:s.rowCount}}}else if(r==="cursor:fetch"){let l=fe.get(t.cursorId);if(!l)throw new Error("Cursor not found");s=l,fe.delete(t.cursorId)}else if(r==="db:flush")console.log(`[LanceQLWorker] db:flush ${t.db}`),await(await $(t.db)).flush(),console.log(`[LanceQLWorker] db:flush ${t.db} done`),s=!0;else if(r==="db:compact")s=await(await $(t.db)).compact();else if(r==="db:listTables")s=(await $(t.db)).listTables();else if(r==="db:getTable")s=(await $(t.db)).getTable(t.tableName);else if(r==="db:scanStart")s=await(await $(t.db)).scanStart(t.tableName,t.options);else if(r==="db:scanNext")s=(await $(t.db)).scanNext(t.streamId);else if(r==="db:listVersions")s=await(await $(t.db)).listVersions(t.tableName);else if(r==="db:selectAtVersion"){let l=await $(t.db),o={...t.options};t.where&&(o.where=i=>evalWhere(t.where,i)),s=await l.selectAtVersion(t.tableName,t.version,o)}else if(r==="db:restoreTable")s=await(await $(t.db)).restoreToVersion(t.tableName,t.version);else if(r==="vault:open")await K(t.encryption),s=!0;else if(r==="vault:get")s=await(await K()).get(t.key);else if(r==="vault:set")await(await K()).set(t.key,t.value),s=!0;else if(r==="vault:delete")await(await K()).delete(t.key),s=!0;else if(r==="vault:keys")s=await(await K()).keys();else if(r==="vault:has")s=await(await K()).has(t.key);else if(r==="vault:tables"){let l=await K();s=l._db?l._db.listTables():[]}else if(r==="vault:exec"){let o=(await K())._db,i=Oe(t.sql);if(i?.type==="SHOW_VERSIONS"){let a=await o.listVersions(i.table);s={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:a.length,data:{version:new Float64Array(a.map(c=>c.version)),timestamp:a.map(c=>new Date(c.timestamp).toISOString()),operation:a.map(c=>c.operation),rowCount:new Float64Array(a.map(c=>c.rowCount))}}}else if(i?.type==="RESTORE_TABLE"){let a=await o.restoreToVersion(i.table,i.version);s={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([a.newVersion])}}}else if(i?.type==="SELECT_VERSION"){let a=await o.selectAtVersion(i.table,i.version,{});if(a.length>0){let c=Object.keys(a[0]),f={};for(let d of c)f[d]=a.map(p=>p[d]);s={_format:"columnar",columns:c,rowCount:a.length,data:f}}else s={_format:"columnar",columns:[],rowCount:0,data:{}}}else s=await Re(o,t.sql);if(s&&s._format==="columnar"&&s.rowCount>=1e5){let a=Ne++;fe.set(a,s),s={_format:"cursor",cursorId:a,columns:s.columns,rowCount:s.rowCount}}}else throw new Error(`Unknown method: ${r}`);at(u,n,s)}catch(s){let l=s.stack||s.message;l.includes("TableDoesNotExist")?l="Table does not exist":l.includes("ColumnDoesNotExist")?l="Column does not exist":l.includes("UnknownEmbeddingModel")&&(l="Unknown embedding model"),u.postMessage({id:n,error:l})}}var it=typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope;it?self.onconnect=u=>{let e=u.ports[0];Ee.add(e),e.onmessage=n=>{Ve(e,n.data)},e.onmessageerror=n=>{console.error("[LanceQLWorker] Message error:",n)},Z().then(()=>{e.postMessage({type:"ready"})}).catch(n=>{console.error("[LanceQLWorker] Failed to load WASM:",n),e.postMessage({type:"ready",error:"WASM load failed"})}),e.start(),console.log("[LanceQLWorker] New connection, total ports:",Ee.size)}:(self.onmessage=u=>{Ve(self,u.data)},Z().then(()=>{self.postMessage({type:"ready"})}).catch(u=>{console.error("[LanceQLWorker] Failed to load WASM:",u),self.postMessage({type:"ready",error:"WASM load failed"})}));console.log("[LanceQLWorker] Initialized");export{Rt as closeOPFSFile,M as getWasm,P as getWasmMemory,Dt as loadFragmentToWasm,et as registerOPFSFile,Nt as wasmAggregate};
//# sourceMappingURL=lanceql-worker.js.map
