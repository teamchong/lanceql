var K=new Map;async function re(d){return crypto.subtle.importKey("raw",new Uint8Array(d),{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function se(d,e){let n=crypto.getRandomValues(new Uint8Array(12)),t=new TextEncoder().encode(JSON.stringify(d)),s=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},e,t),l=new Uint8Array(12+s.byteLength);return l.set(n,0),l.set(new Uint8Array(s),12),l}async function oe(d,e){let n=d.slice(0,12),r=d.slice(12),t=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},e,r),s=new TextDecoder;return JSON.parse(s.decode(t))}var D=null,te=null,ue=new Map;function Ve(d){D=d}function Me(d){te=d}var ae=class{constructor(e,n={}){this.name=e,this.options=n,this._root=null,this._ready=!1,this._embedder=null,this._encryptionKeyId=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:n,keyBytes:r}=e;if(!K.has(n)){let t=await re(r);K.set(n,t)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle(`lanceql-${this.name}`,{create:!0}),this._ready=!0}catch(n){throw console.error("[WorkerStore] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?K.get(this._encryptionKeyId):null}async get(e){await this._ensureOpen();try{let n=this._getCryptoKey(),r=n?".enc":".json",s=await(await this._root.getFileHandle(`${e}${r}`)).getFile();if(n){let l=await s.arrayBuffer();return oe(new Uint8Array(l),n)}else{let l=await s.text();return JSON.parse(l)}}catch(n){if(n.name==="NotFoundError")return;throw n}}async set(e,n){await this._ensureOpen();let r=this._getCryptoKey(),t=r?".enc":".json",l=await(await this._root.getFileHandle(`${e}${t}`,{create:!0})).createWritable();if(r){let o=await se(n,r);await l.write(o)}else await l.write(JSON.stringify(n));await l.close()}async delete(e){await this._ensureOpen();let r=this._getCryptoKey()?".enc":".json";try{await this._root.removeEntry(`${e}${r}`)}catch(t){if(t.name!=="NotFoundError")throw t}}async keys(){await this._ensureOpen();let n=this._getCryptoKey()?".enc":".json",r=[];for await(let[t]of this._root.entries())t.endsWith(n)&&r.push(t.slice(0,-n.length));return r}async clear(){await this._ensureOpen();let e=[];for await(let[n]of this._root.entries())e.push(n);for(let n of e)await this._root.removeEntry(n)}async filter(e,n){let r=await this.get(e);if(!Array.isArray(r))throw new Error(`Key '${e}' is not a collection`);return r.filter(t=>this._matchQuery(t,n))}async find(e,n){let r=await this.get(e);if(!Array.isArray(r))throw new Error(`Key '${e}' is not a collection`);return r.find(t=>this._matchQuery(t,n))}async search(e,n,r=10){let t=await this.get(e);if(!Array.isArray(t))throw new Error(`Key '${e}' is not a collection`);if(t.length===0)return[];if(this._embedder)return this._semanticSearch(t,e,n,r);let s=n.toLowerCase();return t.map(o=>{let i=this._extractText(o).toLowerCase(),a=s.split(/\s+/),c=a.filter(f=>i.includes(f)).length;return{item:o,score:c/a.length}}).filter(o=>o.score>0).sort((o,i)=>i.score-o.score).slice(0,r)}async _semanticSearch(e,n,r,t){let s=await this._embedder.embed(r),l=[],o=[],i=[];for(let a=0;a<e.length;a++){let c=e[a],f=this._extractText(c),u=`${this.name}:${n}:${f}`;if(ue.has(u)){let y=ue.get(u),g=this._cosineSimilarity(s,y);l.push({item:c,score:g})}else o.push(f),i.push(a)}if(o.length>0){let a;o.length>1&&this._embedder.embedBatch?a=await this._embedder.embedBatch(o):a=await Promise.all(o.map(c=>this._embedder.embed(c)));for(let c=0;c<a.length;c++){let f=i[c],u=e[f],y=o[c],g=a[c],h=`${this.name}:${n}:${y}`;ue.set(h,g);let m=this._cosineSimilarity(s,g);l.push({item:u,score:m})}}return l.sort((a,c)=>c.score-a.score).slice(0,t)}async enableSemanticSearch(e={}){let{model:n="minilm",onProgress:r}=e;if(D||(te||(te=this._initGPUTransformer(),Me(te)),D=await te,Ve(D)),!D)return null;let t=await D.loadModel(n,r);return this._embedder={model:n,dimensions:t.hiddenSize,embed:async s=>D.encodeText(s,n),embedBatch:async s=>D.encodeTextBatch(s,n)},{model:n,dimensions:t.hiddenSize,type:t.modelType||"text"}}async _initGPUTransformer(){try{let e=await import("./webgpu/index.js");if(!e.isWebGPUAvailable())return console.log("[WorkerStore] WebGPU not available"),null;let n=e.getGPUTransformer();return await n.init()?(console.log("[WorkerStore] WebGPU initialized"),n):(console.log("[WorkerStore] WebGPU init failed"),null)}catch(e){return console.error("[WorkerStore] WebGPU init error:",e),null}}disableSemanticSearch(){this._embedder&&D&&(D.unloadModel(this._embedder.model),this._embedder=null)}hasSemanticSearch(){return this._embedder!==null}async count(e,n=null){let r=await this.get(e);if(!Array.isArray(r))throw new Error(`Key '${e}' is not a collection`);return n?r.filter(t=>this._matchQuery(t,n)).length:r.length}async _ensureOpen(){this._ready||await this.open()}_matchQuery(e,n){for(let[r,t]of Object.entries(n)){let s=e[r];if(typeof t=="object"&&t!==null)for(let[l,o]of Object.entries(t))switch(l){case"$eq":if(s!==o)return!1;break;case"$ne":if(s===o)return!1;break;case"$lt":if(!(s<o))return!1;break;case"$lte":if(!(s<=o))return!1;break;case"$gt":if(!(s>o))return!1;break;case"$gte":if(!(s>=o))return!1;break;case"$in":if(!Array.isArray(o)||!o.includes(s))return!1;break;case"$nin":if(Array.isArray(o)&&o.includes(s))return!1;break;case"$contains":if(typeof s!="string"||!s.includes(o))return!1;break;case"$regex":if(typeof s!="string"||!new RegExp(o).test(s))return!1;break}else if(s!==t)return!1}return!0}_extractText(e){if(typeof e=="string")return e;let n=[];for(let[r,t]of Object.entries(e))typeof t=="string"&&n.push(t);return n.join(" ")}_cosineSimilarity(e,n){let r=0,t=0,s=0;for(let l=0;l<e.length;l++)r+=e[l]*n[l],t+=e[l]*e[l],s+=n[l]*n[l];return r/(Math.sqrt(t)*Math.sqrt(s))}};var he=class{constructor(e="lanceql"){this.rootDir=e,this.root=null}async getRoot(){if(this.root)return this.root;if(typeof navigator>"u"||!navigator.storage?.getDirectory)throw new Error("OPFS not available");let e=await navigator.storage.getDirectory();return this.root=await e.getDirectoryHandle(this.rootDir,{create:!0}),this.root}async open(){return await this.getRoot(),this}async getDir(e){let n=await this.getRoot(),r=e.split("/").filter(s=>s),t=n;for(let s of r)t=await t.getDirectoryHandle(s,{create:!0});return t}async save(e,n){let r=e.split("/"),t=r.pop(),s=r.join("/"),o=await(s?await this.getDir(s):await this.getRoot()).getFileHandle(t,{create:!0});if(o.createSyncAccessHandle)try{let a=await o.createSyncAccessHandle();return a.truncate(0),a.write(n,{at:0}),a.flush(),a.close(),{path:e,size:n.byteLength}}catch{}let i=await o.createWritable();return await i.write(n),await i.close(),{path:e,size:n.byteLength}}async load(e){try{let n=e.split("/"),r=n.pop(),t=n.join("/"),i=await(await(await(t?await this.getDir(t):await this.getRoot()).getFileHandle(r)).getFile()).arrayBuffer();return new Uint8Array(i)}catch(n){if(n.name==="NotFoundError")return null;throw n}}async delete(e){try{let n=e.split("/"),r=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(r),!0}catch(n){if(n.name==="NotFoundError")return!1;throw n}}async list(e=""){try{let n=e?await this.getDir(e):await this.getRoot(),r=[];for await(let[t,s]of n.entries())r.push({name:t,type:s.kind});return r}catch{return[]}}async exists(e){try{let n=e.split("/"),r=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).getFileHandle(r),!0}catch{return!1}}async deleteDir(e){try{let n=e.split("/"),r=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(r,{recursive:!0}),!0}catch{return!1}}},C=new he;var V=new TextEncoder,q=new TextDecoder,$e={INT64:"int64",INT32:"int32",FLOAT64:"float64",FLOAT32:"float32",STRING:"string",BOOL:"bool",VECTOR:"vector"},Ce=1,Be=2,xe=3,ve=4,de=5,we=6;function Ie(d){switch(d){case"int32":case"integer":return Int32Array;case"int64":return BigInt64Array;case"float32":case"real":return Float32Array;case"float64":case"double":return Float64Array;default:return null}}function Pe(d){switch(d){case"int32":case"integer":return Ce;case"int64":return Be;case"float32":case"real":return xe;case"float64":case"double":return ve;case"string":case"text":return de;case"bool":case"boolean":return we;default:return de}}var ie=class{constructor(e){this.schema=e,this.columns=new Map,this.rowCount=0,this._useBinary=!0}addRows(e){if(e.length!==0){if(this.rowCount===0)for(let n of this.schema){let r=Ie(n.dataType);r?this.columns.set(n.name,{type:"typed",dataType:n.dataType,data:new r(Math.max(e.length,1024)),length:0}):this.columns.set(n.name,{type:"array",dataType:n.dataType,data:[],length:0})}for(let n of this.schema){let r=this.columns.get(n.name);if(r.type==="typed"){let t=r.length+e.length;if(t>r.data.length){let s=Math.max(t,r.data.length*2),l=new r.data.constructor(s);l.set(r.data),r.data=l}for(let s=0;s<e.length;s++){let l=e[s][n.name];r.data[r.length+s]=l??0}r.length+=e.length}else{for(let t=0;t<e.length;t++)r.data.push(e[t][n.name]??null);r.length+=e.length}}this.rowCount+=e.length}}buildBinary(){let e=[],n=16,r=[];for(let i of this.schema){let a=this.columns.get(i.name),c=V.encode(i.name),f=Pe(i.dataType),u;if(a.type==="typed"){let h=a.data.subarray(0,a.length);u=new Uint8Array(h.buffer,h.byteOffset,h.byteLength)}else u=V.encode(JSON.stringify(a.data));r.push({nameBytes:c,typeCode:f,dataBytes:u,dataType:i.dataType});let g=(8-(n+4+c.length+1+4)%8)%8;n+=4+c.length+1+g+4+u.length}let t=new ArrayBuffer(n),s=new DataView(t),l=new Uint8Array(t),o=0;s.setUint32(o,1279348291,!1),o+=4,s.setUint32(o,2,!1),o+=4,s.setUint32(o,this.schema.length,!1),o+=4,s.setUint32(o,this.rowCount,!1),o+=4;for(let i of r){s.setUint32(o,i.nameBytes.length,!1),o+=4,l.set(i.nameBytes,o),o+=i.nameBytes.length,s.setUint8(o,i.typeCode),o+=1;let a=(8-(o+4)%8)%8;for(let c=0;c<a;c++)s.setUint8(o+c,0);o+=a,s.setUint32(o,i.dataBytes.length,!1),o+=4,l.set(i.dataBytes,o),o+=i.dataBytes.length}return new Uint8Array(t)}setColumnarData(e){let n=Object.keys(e)[0];this.rowCount=e[n]?.length||0;for(let r of this.schema){let t=e[r.name];if(!t)continue;let s=Ie(r.dataType);if(s&&ArrayBuffer.isView(t))this.columns.set(r.name,{type:"typed",dataType:r.dataType,data:t,length:t.length});else if(s){let l=new s(t.length);for(let o=0;o<t.length;o++)l[o]=t[o]??0;this.columns.set(r.name,{type:"typed",dataType:r.dataType,data:l,length:t.length})}else this.columns.set(r.name,{type:"array",dataType:r.dataType,data:Array.isArray(t)?t:Array.from(t),length:t.length})}}build(){if(this._useBinary&&this.rowCount>0)try{return this.buildBinary()}catch(n){console.warn("[LanceFileWriter] Binary build failed, falling back to JSON:",n)}let e={format:"json",schema:this.schema,columns:{},rowCount:this.rowCount};for(let[n,r]of this.columns)r.type==="typed"?e.columns[n]=Array.from(r.data.subarray(0,r.length)):e.columns[n]=r.data;return V.encode(JSON.stringify(e))}};function ne(d){let e=new DataView(d.buffer||d),n=new Uint8Array(d.buffer||d),r=0;if(e.getUint32(r,!1)!==1279348291)return null;r+=4;let s=e.getUint32(r,!1);r+=4;let l=e.getUint32(r,!1);r+=4;let o=e.getUint32(r,!1);r+=4;let i=[],a={};for(let c=0;c<l;c++){let f=e.getUint32(r,!1);r+=4;let u=q.decode(n.subarray(r,r+f));r+=f;let y=e.getUint8(r);r+=1;let g=(8-(r+4)%8)%8;r+=g;let h=e.getUint32(r,!1);r+=4;let m=n.subarray(r,r+h);r+=h;let w,p;try{switch(y){case Ce:p="int32",m.byteOffset%4!==0?w=new Int32Array(m.slice().buffer):w=new Int32Array(m.buffer,m.byteOffset,m.byteLength/4);break;case xe:p="float32",m.byteOffset%4!==0?w=new Float32Array(m.slice().buffer):w=new Float32Array(m.buffer,m.byteOffset,m.byteLength/4);break;case ve:p="float64",m.byteOffset%8!==0?w=new Float64Array(m.slice().buffer):w=new Float64Array(m.buffer,m.byteOffset,m.byteLength/8);break;case Be:p="int64",m.byteOffset%8!==0?w=new BigInt64Array(m.slice().buffer):w=new BigInt64Array(m.buffer,m.byteOffset,m.byteLength/8);break;case de:case we:default:p=y===we?"bool":"string",w=JSON.parse(q.decode(m));break}}catch(_){throw console.error(`[LanceQLWorker] Error parsing column '${u}' (type ${y}, len ${h}):`,_),_}i.push({name:u,dataType:p}),a[u]=w}return{schema:i,columns:a,rowCount:o,format:"binary"}}var Y=class{constructor(e=512*1024*1024){this.maxBytes=e,this.currentBytes=0,this.cache=new Map,this.head=null,this.tail=null}get(e){let n=this.cache.get(e);if(n)return this._moveToHead(n),n.value}set(e,n,r=0){let t=this.cache.get(e);if(t)this.currentBytes-=t.size,this.currentBytes+=r,t.value=n,t.size=r,this._moveToHead(t);else{let s={key:e,value:n,size:r,prev:null,next:null};this.cache.set(e,s),this._addToHead(s),this.currentBytes+=r}this._evictIfNeeded()}has(e){return this.cache.has(e)}delete(e){let n=this.cache.get(e);n&&(this._removeNode(n),this.cache.delete(e),this.currentBytes-=n.size)}clear(){this.cache.clear(),this.head=null,this.tail=null,this.currentBytes=0}_moveToHead(e){e!==this.head&&(this._removeNode(e),this._addToHead(e))}_addToHead(e){e.next=this.head,e.prev=null,this.head&&(this.head.prev=e),this.head=e,this.tail||(this.tail=e)}_removeNode(e){e.prev?e.prev.next=e.next:this.head=e.next,e.next?e.next.prev=e.prev:this.tail=e.prev}_evictIfNeeded(){for(;this.currentBytes>this.maxBytes&&this.tail;){let e=this.tail;this._removeNode(e),this.cache.delete(e.key),this.currentBytes-=e.size}}static estimateSize(e){return e?e.byteLength?e.byteLength:Array.isArray(e)?e.length*100:e.buffer&&e.buffer.byteLength?e.buffer.byteLength:1e3:0}};var ge=new Map,He=1,X=class{constructor(e,n){this.name=e,this.tables=new Map,this.version=0,this.manifestKey=`${e}/__manifest__`,this.bufferPool=n||new Y,this._writeBuffer=new Map,this._flushTimer=null,this._flushInterval=2e3,this._flushThreshold=1e4,this._columnarBuffer=new Map,this._flushing=!1,this._readCache=new Map,this._columnarCache=new Map}async open(){let e=await C.load(this.manifestKey);if(e){let n=JSON.parse(q.decode(e));this.version=n.version||0,this.tables=new Map(Object.entries(n.tables||{}));for(let[r,t]of this.tables)await this._getLatestVersion(r)===0&&t.fragments?.length>0&&await this._createVersion(r,"MIGRATE")}return this}async _saveManifest(){this.version++;let e={version:this.version,timestamp:Date.now(),tables:Object.fromEntries(this.tables)},n=V.encode(JSON.stringify(e));await C.save(this.manifestKey,n)}async _getLatestVersion(e){let n=`${this.name}/${e}/_latest`;try{let r=await C.load(n);return r?parseInt(q.decode(r),10):0}catch{return 0}}async _setLatestVersion(e,n){let r=`${this.name}/${e}/_latest`;await C.save(r,V.encode(String(n)))}async _loadTableVersion(e,n){let r=`${this.name}/${e}/_versions/${n}.manifest`,t=await C.load(r);if(!t)throw new Error(`Version ${n} not found for table '${e}'`);return JSON.parse(q.decode(t))}async _saveTableVersion(e,n){let r=`${this.name}/${e}/_versions/${n.version}.manifest`;await C.save(r,V.encode(JSON.stringify(n)))}async _createVersion(e,n){let r=this.tables.get(e);if(!r)return 0;let t=await this._getLatestVersion(e),s=t+1,l={version:s,timestamp:Date.now(),parentVersion:t,operation:n,schema:r.schema,fragments:[...r.fragments],deletionVector:[...r.deletionVector],rowCount:r.rowCount,nextRowId:r.nextRowId};return await this._saveTableVersion(e,l),await this._setLatestVersion(e,s),s}async listVersions(e){let n=await this._getLatestVersion(e),r=[];for(let t=1;t<=n;t++)try{let s=await this._loadTableVersion(e,t);r.push({version:s.version,timestamp:s.timestamp,operation:s.operation,rowCount:s.rowCount})}catch{}return r}async selectAtVersion(e,n,r={}){let t=await this._loadTableVersion(e,n),s=new Set(t.deletionVector),l=this.tables.get(e),o=[];for(let c of t.fragments){let f=await C.load(c);if(f){let u=this._parseFragment(f,t.schema);for(let y of u)s.has(y.__rowId)||o.push(y)}}let i=o;if(r.where&&(i=i.filter(r.where)),r.orderBy){let{column:c,desc:f}=r.orderBy;i.sort((u,y)=>{let g=u[c]<y[c]?-1:u[c]>y[c]?1:0;return f?-g:g})}r.offset&&(i=i.slice(r.offset)),r.limit&&(i=i.slice(0,r.limit));let a=r.columns&&r.columns.length>0&&r.columns[0]!=="*"?r.columns:null;return i.map(c=>{if(a){let f={};for(let u of a)f[u]=c[u];return f}else{let{__rowId:f,...u}=c;return u}})}async restoreToVersion(e,n){let r=await this._loadTableVersion(e,n),t=await this._getLatestVersion(e),s=t+1,l={...r,version:s,timestamp:Date.now(),parentVersion:t,operation:`RESTORE_FROM_${n}`};await this._saveTableVersion(e,l),await this._setLatestVersion(e,s);let o=this.tables.get(e);return o&&(o.fragments=[...r.fragments],o.deletionVector=[...r.deletionVector],o.rowCount=r.rowCount,o.nextRowId=r.nextRowId,this._columnarBuffer.delete(e),this._writeBuffer.delete(e),await this._saveManifest()),{restored:!0,newVersion:s}}async createTable(e,n,r=!1){if(this.tables.has(e)){if(r)return{success:!0,existed:!0};throw new Error(`Table '${e}' already exists`)}let t=n.map(l=>({name:l.name,type:$e[(l.dataType||l.type)?.toUpperCase()]||l.dataType||l.type||"string",primaryKey:l.primaryKey||!1,vectorDim:l.vectorDim||null})),s={name:e,schema:t,fragments:[],deletionVector:[],rowCount:0,nextRowId:0,version:0,createdAt:Date.now()};return this.tables.set(e,s),await this._saveManifest(),await this._createVersion(e,"CREATE"),{success:!0,table:e}}async dropTable(e,n=!1){if(!this.tables.has(e)){if(n)return this._writeBuffer.delete(e),{success:!0,existed:!1};throw new Error(`Table '${e}' does not exist`)}let r=this.tables.get(e);this._writeBuffer.delete(e);for(let t of r.fragments)this._readCache.delete(t),await C.delete(t);return this.tables.delete(e),await this._saveManifest(),{success:!0,table:e}}async insert(e,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=this.tables.get(e),t=n.length;if(!this._columnarBuffer.has(e)){let i=Math.max(1024,t*2),a={__rowId:new Float64Array(i),__length:0,__capacity:i,__schema:r.schema};for(let c of r.schema){let f=(c.dataType||c.type||"").toLowerCase();f==="text"||f==="string"||f==="varchar"?a[c.name]=new Array(i):f==="int64"||f==="bigint"?a[c.name]=new BigInt64Array(i):a[c.name]=new Float64Array(i)}this._columnarBuffer.set(e,a)}let s=this._columnarBuffer.get(e),l=s.__length,o=s.__capacity;if(l+t>o){let i=Math.max(o*2,l+t),a=new Float64Array(i);a.set(s.__rowId.subarray(0,l)),s.__rowId=a;for(let c of r.schema){let f=s[c.name];if(f instanceof Float64Array){let u=new Float64Array(i);u.set(f.subarray(0,l)),s[c.name]=u}else if(f instanceof BigInt64Array){let u=new BigInt64Array(i);u.set(f.subarray(0,l)),s[c.name]=u}else s[c.name].length=i}s.__capacity=i}for(let i=0;i<t;i++){let a=n[i];s.__rowId[l+i]=r.nextRowId++;for(let c of r.schema){let f=a[c.name];s[c.name]instanceof Float64Array?s[c.name][l+i]=f!=null?Number(f):NaN:s[c.name]instanceof BigInt64Array?s[c.name][l+i]=f!=null?BigInt(f):0n:s[c.name][l+i]=f??null}}return s.__length=l+t,r.rowCount+=t,r.version=(r.version||0)+1,this._scheduleFlush(),s.__length>=this._flushThreshold&&await this._flushTable(e),{success:!0,inserted:t}}_scheduleFlush(){this._flushTimer||(this._flushTimer=setTimeout(()=>{this._flushTimer=null,this.flush().catch(e=>console.warn("[WorkerDatabase] Flush error:",e))},this._flushInterval))}async flush(){if(!this._flushing){this._flushing=!0;try{let e=[...this._columnarBuffer.keys()];for(let n of e)await this._flushTable(n)}finally{this._flushing=!1}}}async _flushTable(e){let n=this._columnarBuffer.get(e),r=n?.__length||0;if(!n||r===0)return;let t=this.tables.get(e);if(!t)return;let s=[{name:"__rowId",type:"int64",dataType:"float64",primaryKey:!0},...t.schema.filter(c=>c.name!=="__rowId").map(c=>{let f=(c.dataType||c.type||"").toLowerCase();return f==="int64"||f==="bigint"?{...c,dataType:"int64"}:{...c,dataType:f==="float64"||f==="float32"||f==="int32"||f==="integer"||f==="real"||f==="double"?"float64":c.dataType||c.type||"float64"}})],l={};for(let c of s){let f=n[c.name];f&&(f instanceof Float64Array||f instanceof BigInt64Array?l[c.name]=f.subarray(0,r):l[c.name]=f.slice(0,r))}n.__length=0;let o=new ie(s);o.setColumnarData(l);let i=o.build(),a=`${this.name}/${e}/frag_${Date.now()}_${Math.random().toString(36).slice(2)}.lance`;await C.save(a,i),t.fragments.push(a),await this._saveManifest(),await this._createVersion(e,"INSERT")}async delete(e,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=this.tables.get(e),t=0,s=this._columnarBuffer.get(e),l=s?.__length||0;if(s&&l>0){let o=r.schema.map(i=>i.name);for(let i=0;i<l;i++){let a={__rowId:s.__rowId[i]};for(let c of o){let f=s[c][i];a[c]=Number.isNaN(f)?null:f}n(a)&&(r.deletionVector.includes(s.__rowId[i])||(r.deletionVector.push(s.__rowId[i]),t++))}}for(let o of r.fragments){let i=await C.load(o);if(i){let a=this._parseFragment(i,r.schema);for(let c of a)!r.deletionVector.includes(c.__rowId)&&n(c)&&(r.deletionVector.push(c.__rowId),t++)}}return r.rowCount-=t,r.version=(r.version||0)+1,await this._saveManifest(),t>0&&await this._createVersion(e,"DELETE"),{success:!0,deleted:t}}async update(e,n,r){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let t=this.tables.get(e),s=0,l=this._writeBuffer.get(e);if(l&&l.length>0)for(let i of l)r(i)&&(Object.assign(i,n),s++);let o=[];for(let i of t.fragments){let a=await C.load(i);if(a){let c=this._parseFragment(a,t.schema);for(let f of c)if(!t.deletionVector.includes(f.__rowId)&&r(f)){t.deletionVector.push(f.__rowId),t.rowCount--;let u={...f,...n};delete u.__rowId,o.push(u),s++}}}return o.length>0?await this.insert(e,o):await this._saveManifest(),s>0&&o.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:s}}async updateWithExpr(e,n,r,t){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=this.tables.get(e),l=0,o=this._columnarBuffer.get(e),i=o?.__length||0;if(o&&i>0){let c=s.schema.map(f=>f.name);for(let f=0;f<i;f++){let u={__rowId:o.__rowId[f]};for(let y of c){let g=o[y][f];u[y]=Number.isNaN(g)?null:g}if(r(u)){for(let[y,g]of Object.entries(n)){let h=t(g,u);o[y]!==void 0&&(o[y][f]=h??(o[y]instanceof Float64Array?NaN:null))}s.version=(s.version||0)+1,l++}}}let a=[];for(let c of s.fragments){let f=await C.load(c);if(f){let u=this._parseFragment(f,s.schema);for(let y of u)if(!s.deletionVector.includes(y.__rowId)&&r(y)){s.deletionVector.push(y.__rowId),s.rowCount--;let g={...y};for(let[h,m]of Object.entries(n))g[h]=t(m,y);delete g.__rowId,a.push(g),l++}}}return a.length>0?await this.insert(e,a):await this._saveManifest(),l>0&&a.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:l}}async select(e,n={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=await this._readAllRows(e);if(n.where&&(r=r.filter(n.where)),n.orderBy){let{column:l,desc:o}=n.orderBy;r.sort((i,a)=>{let c=i[l]<a[l]?-1:i[l]>a[l]?1:0;return o?-c:c})}n.offset&&(r=r.slice(n.offset)),n.limit&&(r=r.slice(0,n.limit));let t=n.columns&&n.columns.length>0&&n.columns[0]!=="*"?n.columns:null,s=new Array(r.length);for(let l=0;l<r.length;l++){let o=r[l];if(t){let i={};for(let a of t)i[a]=o[a];s[l]=i}else{let{__rowId:i,...a}=o;s[l]=a}}return s}async _readAllRows(e){let n=this.tables.get(e),r=this._columnarBuffer.get(e),s=n.deletionVector.length>0?new Set(n.deletionVector):null,l=[];for(let i of n.fragments){let a=this.bufferPool.get(i),c=null;if(!a){let f=await C.load(i);f&&(a=ne(f),a?this.bufferPool.set(i,a,f.byteLength):c=this._parseFragment(f,n.schema))}if(a&&!c&&(c=this._hydrateRowsFromBinary(a,n.schema)),c=c||[],!s)l.push(...c);else for(let f of c)s.has(f.__rowId)||l.push(f)}let o=r?.__length||0;if(r&&o>0){let i=n.schema.map(a=>a.name);for(let a=0;a<o;a++){if(s&&s.has(r.__rowId[a]))continue;let c={__rowId:r.__rowId[a]};for(let f of i){let u=r[f][a];c[f]=Number.isNaN(u)?null:u}l.push(c)}}return l}_hydrateRowsFromBinary(e,n){let{columns:r,rowCount:t}=e,s=n.map(o=>o.name),l=new Array(t);for(let o=0;o<t;o++){let i={__rowId:r.__rowId[o]};for(let a of s)r[a]&&(i[a]=r[a][o]);l[o]=i}return l}_parseFragment(e,n){try{let r=ne(e);if(r)return this._parseBinaryColumnar(r);let t=q.decode(e),s=JSON.parse(t);return s.format==="json"&&s.columns?this._parseJsonColumnar(s):Array.isArray(s)?s:[s]}catch(r){return console.warn("[WorkerDatabase] Failed to parse fragment:",r),[]}}async selectColumnar(e){let n=this.tables.get(e);if(!n)return null;let r=this._columnarBuffer.get(e)?.__length||0,t=`${n.fragments.length}:${r}:${n.deletionVector.length}:${n.version||0}`,s=this._columnarCache.get(e);if(s&&s.version===t){let h={};for(let[m,w]of Object.entries(s.data.columns))ArrayBuffer.isView(w)?h[m]=new w.constructor(w.buffer,w.byteOffset,w.length):h[m]=w;return{schema:n.schema,columns:h,rowCount:s.data.rowCount}}let o=n.deletionVector.length>0?new Set(n.deletionVector):null,i={},a=n.schema.map(h=>h.name);for(let h of a)i[h]=[];i.__rowId=[];for(let h of n.fragments){let m=this.bufferPool.get(h);if(!m){let _=await C.load(h);if(!_)continue;m=ne(_),m&&this.bufferPool.set(h,m,_.byteLength)}if(!m)continue;let{columns:w,rowCount:p}=m;if(o){let _=w.__rowId,A=[];for(let b=0;b<p;b++)o.has(_[b])||A.push(b);for(let b of a)if(w[b]){let T=w[b],E=new T.constructor(A.length);for(let S=0;S<A.length;S++)E[S]=T[A[S]];i[b].push(E)}}else{for(let _ of a)w[_]&&i[_].push(w[_]);w.__rowId&&i.__rowId.push(w.__rowId)}}let c=this._columnarBuffer.get(e),f=c?.__length||0;if(c&&f>0)if(o){let h=[];for(let p=0;p<f;p++)o.has(c.__rowId[p])||h.push(p);let m=h.length;for(let p of n.schema){let _=c[p.name];if(_)if(_ instanceof Float64Array){let A=new Float64Array(m);for(let b=0;b<m;b++)A[b]=_[h[b]];i[p.name].push(A)}else i[p.name].push(h.map(A=>_[A]))}let w=new Float64Array(m);for(let p=0;p<m;p++)w[p]=c.__rowId[h[p]];i.__rowId.push(w)}else{for(let m of n.schema){let w=c[m.name];if(w)if(w instanceof Float64Array){let p=new Float64Array(f);p.set(w.subarray(0,f)),i[m.name].push(p)}else i[m.name].push(w.slice(0,f))}let h=new Float64Array(f);h.set(c.__rowId.subarray(0,f)),i.__rowId.push(h)}let u={},y=0;for(let h of[...a,"__rowId"]){let m=i[h];if(m.length===0)u[h]=new Float64Array(0);else if(m.length===1)u[h]=m[0],y===0&&(y=m[0].length);else{let w=m.reduce((b,T)=>b+T.length,0);y===0&&(y=w);let p=m[0],_=ArrayBuffer.isView(p)?new p.constructor(w):new Array(w),A=0;for(let b of m){if(ArrayBuffer.isView(_))_.set(b,A);else for(let T=0;T<b.length;T++)_[A+T]=b[T];A+=b.length}u[h]=_}}let g={schema:n.schema,columns:u,rowCount:y};return this._columnarCache.set(e,{version:t,data:g}),g}async _readColumn(e,n){let r=this.tables.get(e);if(!r)return null;let t=this._writeBuffer.get(e),s=[];for(let a of r.fragments){let c=await C.load(a);if(!c)continue;let f=ne(c);if(f&&f.columns[n]){let u=f.columns[n];u.length>0&&s.push(u)}}if(t&&t.length>0){let a=new Float64Array(t.length);for(let c=0;c<t.length;c++){let f=t[c][n];a[c]=typeof f=="number"?f:0}s.push(a)}if(s.length===0)return new Float64Array(0);if(s.length===1)return s[0];let l=s.reduce((a,c)=>a+c.length,0),o=new Float64Array(l),i=0;for(let a of s)o.set(a,i),i+=a.length;return o}_parseBinaryColumnar(e){let{schema:n,columns:r,rowCount:t}=e,s=new Array(t),l=n.map(a=>a.name),o=l.map(a=>r[a]),i=l.length;for(let a=0;a<t;a++){let c={};for(let f=0;f<i;f++)c[l[f]]=o[f][a]??null;s[a]=c}return s}_parseJsonColumnar(e){let{schema:n,columns:r,rowCount:t}=e,s=new Array(t),l=n.map(a=>a.name),o=l.map(a=>r[a]||[]),i=l.length;for(let a=0;a<t;a++){let c={};for(let f=0;f<i;f++)c[l[f]]=o[f][a]??null;s[a]=c}return s}getTable(e){return this.tables.get(e)}listTables(){return Array.from(this.tables.keys())}getFragmentPaths(e){let n=this.tables.get(e);return n?n.fragments:[]}getColumnIndex(e,n){let r=this.tables.get(e);if(!r)return-1;let t=r.schema.findIndex(s=>s.name===n);return t>=0?t+1:-1}hasBufferedData(e){let n=this._columnarBuffer.get(e);return n&&(n.__length||0)>0}async compact(){for(let[e,n]of this.tables){let r=await this._readAllRows(e);for(let t of n.fragments)await C.delete(t);if(n.fragments=[],n.deletionVector=[],n.rowCount=0,n.nextRowId=0,r.length>0){let t=r.map(({__rowId:s,...l})=>l);await this.insert(e,t)}}return{success:!0,compacted:this.tables.size}}async scanStart(e,n={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=He++,t=this.tables.get(e),s=new Set(t.deletionVector),l=[];for(let i of t.fragments){let a=await C.load(i);if(a){let c=this._parseFragment(a,t.schema);for(let f of c)s.has(f.__rowId)||l.push(f)}}let o=this._writeBuffer.get(e);if(o)for(let i of o)s.has(i.__rowId)||l.push(i);return ge.set(r,{rows:l,index:0,batchSize:n.batchSize||1e4,columns:n.columns}),r}scanNext(e){let n=ge.get(e);if(!n)return{batch:[],done:!0};let r=[],t=Math.min(n.index+n.batchSize,n.rows.length);for(let l=n.index;l<t;l++){let o=n.rows[l],i;if(n.columns&&n.columns.length>0&&n.columns[0]!=="*"){i={};for(let a of n.columns)i[a]=o[a]}else{let{__rowId:a,...c}=o;i=c}r.push(i)}n.index=t;let s=n.index>=n.rows.length;return s&&ge.delete(e),{batch:r,done:s}}};var le=class{constructor(){this._root=null,this._ready=!1,this._kv={},this._encryptionKeyId=null,this._db=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:n,keyBytes:r}=e;if(!K.has(n)){let t=await re(r);K.set(n,t)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle("vault",{create:!0}),await this._loadKV(),this._db=new X("vault"),await this._db.open(),this._ready=!0}catch(n){throw console.error("[WorkerVault] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?K.get(this._encryptionKeyId):null}async _loadKV(){try{let e=this._getCryptoKey(),n=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(n)).getFile();if(e){let s=await t.arrayBuffer();this._kv=await oe(new Uint8Array(s),e)}else{let s=await t.text();this._kv=JSON.parse(s)}}catch(e){if(e.name==="NotFoundError")this._kv={};else throw e}}async _saveKV(){let e=this._getCryptoKey(),n=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(n,{create:!0})).createWritable();if(e){let s=await se(this._kv,e);await t.write(s)}else await t.write(JSON.stringify(this._kv));await t.close()}async get(e){return this._kv[e]}async set(e,n){this._kv[e]=n,await this._saveKV()}async delete(e){delete this._kv[e],await this._saveKV()}async keys(){return Object.keys(this._kv)}async has(e){return e in this._kv}};var Ke=1;var ke={INT64:0,FLOAT64:1,INT32:2,FLOAT32:3,STRING:4,LIST:5},ye=class{constructor(){this._registered=new Map}getLastError(){let e=P();if(!e)return"WASM not loaded";let n=H(),r=e.alloc(4096);console.log(`[WASM LOG] getLastError alloc ptr: ${r}`);let t=e.getLastError(r,4096);if(console.log(`[WASM LOG] getLastError len: ${t}`),t===0)return"Unknown Error";let s=new Uint8Array(n.buffer,r,t),l=new TextDecoder().decode(s);return console.log(`[WASM LOG] getLastError msg: ${l}`),l}getTableNames(e){let n=P();if(!n)throw new Error("WASM not loaded");let r=H(),t=new TextEncoder().encode(e),s=n.alloc(t.length);new Uint8Array(r.buffer,s,t.length).set(t);let l=n.getTableNames(s,t.length);if(l===0)return[];let o=new Uint8Array(r.buffer,l),i=0;for(;o[i]!==0&&i<1024;)i++;let a=new TextDecoder().decode(o.subarray(0,i));return a?a.split(",").filter(c=>c):[]}hasTable(e){let n=P();if(!n)return!1;let r=H(),t=new TextEncoder().encode(e),s=n.alloc(t.length);return new Uint8Array(r.buffer,s,t.length).set(t),n.hasTable(s,t.length)===1}registerTable(e,n,r,t=""){let s=P();if(!s)throw new Error("WASM not loaded");let l=this._registered.get(e);if(l&&l.version===t)return;if(l){let f=new TextEncoder().encode(e);s.clearTable(f,f.length)}let o=H();if(!o||!o.buffer)throw new Error("WASM memory not available");let i=new TextEncoder().encode(e),a=s.alloc(i.length);if(a<0||a>=o.buffer.byteLength)throw new Error(`Invalid alloc result: ${a} for ${i.length} bytes`);new Uint8Array(o.buffer,a,i.length).set(i);let c=new Set;for(let[f,u]of Object.entries(n)){if(f.startsWith("__")||Array.isArray(u)&&u.length===0)continue;let y=new TextEncoder().encode(f),g=s.alloc(y.length);if(g<0||g>=o.buffer.byteLength)throw new Error(`Invalid colName alloc: ${g}`);if(new Uint8Array(o.buffer,g,y.length).set(y),u instanceof Float64Array){let h=s.allocFloat64Buffer(u.length);if(h===0||h<0||h>=o.buffer.byteLength)throw new Error(`Invalid Float64 alloc: ${h} for ${u.length} elements`);new Float64Array(o.buffer,h,u.length).set(u),s.registerTableFloat64(a,i.length,g,y.length,h,u.length),c.add(f)}else if(u instanceof BigInt64Array){let h=s.allocInt64Buffer(u.length);new BigInt64Array(o.buffer,h,u.length).set(u),s.registerTableInt64(a,i.length,g,y.length,h,u.length),c.add(f)}else if(u instanceof Int32Array){let h=new Float64Array(u.length);for(let w=0;w<u.length;w++)h[w]=u[w];let m=s.allocFloat64Buffer(h.length);new Float64Array(o.buffer,m,h.length).set(h),s.registerTableFloat64(a,i.length,g,y.length,m,h.length),c.add(f)}else if(Array.isArray(u)){let h=new Uint32Array(u.length),m=new Uint32Array(u.length),w=0;for(let E=0;E<u.length;E++){let S=String(u[E]||"");m[E]=S.length,h[E]=w,w+=S.length}let p=new Uint8Array(w),_=0;for(let E=0;E<u.length;E++){let S=String(u[E]||""),I=new TextEncoder().encode(S);p.set(I,_),_+=I.length}let A=s.alloc(h.byteLength);if(A<0||A>=o.buffer.byteLength)throw new Error(`Invalid offsetsPtr alloc: ${A}`);new Uint32Array(o.buffer,A,h.length).set(h);let b=s.alloc(m.byteLength);if(b<0||b>=o.buffer.byteLength)throw new Error(`Invalid lengthsPtr alloc: ${b}`);new Uint32Array(o.buffer,b,m.length).set(m);let T=s.alloc(p.length||1);if(T<0||T>=o.buffer.byteLength)throw new Error(`Invalid dataPtr alloc: ${T}`);new Uint8Array(o.buffer,T,p.length).set(p),s.registerTableString(a,i.length,g,y.length,A,b,T,w,u.length),c.add(f)}}this._registered.set(e,{version:t,columns:c,rowCount:r})}registerTableFromFiles(e,n,r=""){let t=P();if(!t)throw new Error("WASM not loaded");let s=this._registered.get(e);if(s&&s.version===r)return;if(s){let a=new TextEncoder().encode(e);t.clearTable(a,a.length)}let l=new TextEncoder,o=l.encode(e),i=t.alloc(o.length);new Uint8Array(H().buffer,i,o.length).set(o);for(let a of n){let c=l.encode(a),f=t.alloc(c.length);new Uint8Array(H().buffer,f,c.length).set(c);let u=t.registerTableFromOPFS(i,o.length,f,c.length);u!==0&&console.warn(`Failed to register fragment ${a} for table ${e}: error ${u}`)}this._registered.set(e,{version:r,type:"files"})}appendTableMemory(e,n,r){let t=P();if(!t)throw new Error("WASM not loaded");let s=H(),l=new TextEncoder().encode(e),o=t.alloc(l.length);new Uint8Array(s.buffer,o,l.length).set(l);for(let[i,a]of Object.entries(n)){if(i.startsWith("__"))continue;let c=new TextEncoder().encode(i),f=t.alloc(c.length);if(new Uint8Array(s.buffer,f,c.length).set(c),a instanceof Float64Array){let u=t.allocFloat64Buffer(a.length);new Float64Array(s.buffer,u,a.length).set(a),t.appendTableMemory(o,l.length,f,c.length,u,4,r)}else if(a instanceof BigInt64Array){let u=t.allocInt64Buffer(a.length);new BigInt64Array(s.buffer,u,a.length).set(a),t.appendTableMemory(o,l.length,f,c.length,u,2,r)}else if(a instanceof Int32Array){let u=t.alloc(a.byteLength);new Int32Array(s.buffer,u,a.length).set(a),t.appendTableMemory(o,l.length,f,c.length,u,1,r)}else if(a instanceof Float32Array){let u=t.alloc(a.byteLength);new Float32Array(s.buffer,u,a.length).set(a),t.appendTableMemory(o,l.length,f,c.length,u,3,r)}}}execute(e){let n=P();if(!n)throw new Error("WASM not loaded");let r=H();if(n.setCurrentTimestamp)try{n.setCurrentTimestamp(BigInt(Date.now()))}catch(u){console.warn("setCurrentTimestamp failed:",u)}let t=n.getSqlInputBuffer(),s=n.getSqlInputBufferSize(),l=new TextEncoder().encode(e);if(l.length>s)throw new Error(`SQL too long: ${l.length} > ${s}`);new Uint8Array(r.buffer,t,l.length).set(l),n.setSqlInputLength(l.length);let o=n.executeSql();if(o===0){let u=this.getLastError();throw console.log(`[WASM LOG] execute throwing: "${u}"`),new Error(u)}let i=n.getResultSize(),a=this.getLastError();a&&a.length>0&&console.log(`[WASM DEBUG CAPTURED] ${a}`),a.length>0&&a.startsWith("DEBUG:");let c=n.memory.buffer,f=this._parseResult(r.buffer,o,i);return n.resetResult(),f}_parseResult(e,n,r){let t=new DataView(e,n,r),s=new TextDecoder;if(r>=40){let l=r-40,o=[t.getUint8(l+36),t.getUint8(l+37),t.getUint8(l+38),t.getUint8(l+39)];if(String.fromCharCode(...o)==="LANC")return this._parseLanceResult(e,n,r,l,t,s)}if(r>=36&&t.getUint32(0,!0)===Ke)return this._parseLegacyResult(e,n,r);throw new Error(`Invalid result format (Size: ${r}). Not a Lance file.`)}_parseLanceResult(e,n,r,t,s,l){let o=Number(s.getBigUint64(t+8,!0)),i=s.getUint32(t+28,!0),a=[],c={},f=0;for(let u=0;u<i;u++){let y=o+u*8,h=Number(s.getBigUint64(y,!0));s.getUint8(h++);let[m,w]=this._readVarint(s,h);h+=w;let p=new Uint8Array(e,n+h,m),_=l.decode(p);h+=m,a.push(_),s.getUint8(h++);let[A,b]=this._readVarint(s,h);h+=b;let T=new Uint8Array(e,n+h,A),E=l.decode(T);h+=A,s.getUint8(h++);let[S,I]=this._readVarint(s,h);h+=I,s.getUint8(h++);let O=Number(s.getBigUint64(h,!0));h+=8,s.getUint8(h++);let[F,B]=this._readVarint(s,h);h+=B,f=F,s.getUint8(h++);let[R,J]=this._readVarint(s,h);h+=J;let M=n+O;if(E==="float64"||E==="int64"||E==="int32"||E==="float32")if(E==="float64"){let N=new Float64Array(e,M,F).slice(),W=!1;for(let $=0;$<F;$++)if(Number.isNaN(N[$])){W=!0;break}if(W){console.log(`[WASM LOG] Column ${_} has NaNs, converting to nulls`);let $=new Array(F);for(let x=0;x<F;x++){let G=N[x];$[x]=Number.isNaN(G)?null:G}c[_]=$}else c[_]=N}else if(E==="int64"){let N=new BigInt64Array(e,M,F),W=new Array(F),$=-9223372036854775808n;for(let x=0;x<F;x++){let G=N[x];W[x]=G===$?null:Number(G)}c[_]=W}else if(E==="int32"){let N=new Int32Array(e,M,F),W=new Array(F);for(let $=0;$<F;$++){let x=N[$];x===-2147483648?W[$]=null:W[$]=x}c[_]=W}else{let N=new Float32Array(e,M,F),W=new Array(F);for(let $=0;$<F;$++){let x=N[$];W[$]=isNaN(x)?null:x}c[_]=W}else if(E==="string"||E==="list"){let N=E==="list",W=(F+1)*4,$=R-W,x=new Uint8Array(e,M,$).slice(),G=new Uint32Array(e,M+$,F+1).slice();c[_]={_arrowString:!0,offsets:G,bytes:x,isList:E==="list",nullable:S===1}}}return{_format:"columnar",columns:a,rowCount:f,data:c}}_readVarint(e,n){let r=0,t=0,s=0;for(;;){let l=e.getUint8(n+s);if(s++,r|=(l&127)<<t,(l&128)===0)break;t+=7}return[r,s]}_parseLegacyResult(e,n,r){let t=new DataView(e,n,r),s=new TextDecoder,l=t.getUint32(4,!0),o=Number(t.getBigUint64(8,!0)),i=t.getUint32(24,!0),a=t.getUint32(32,!0),c=[],f={};for(let u=0;u<l;u++){let y=36+u*16,g=t.getUint32(y,!0),h=t.getUint32(y+4,!0),m=t.getUint32(y+8,!0),w=t.getUint32(y+12,!0),p=new Uint8Array(e,n+a+h,m),_=s.decode(p);c.push(_);let A=Object.keys(ke).find(T=>ke[T]===g).toLowerCase(),b=n+i+w;if(A==="float64"||A==="int64"||A==="int32"||A==="float32")A==="float64"?f[_]=new Float64Array(e,b,o).slice():A==="int64"?f[_]=new Float64Array(e,b,o).slice():A==="int32"?f[_]=new Int32Array(e,b,o).slice():A==="float32"&&(f[_]=new Float32Array(e,b,o).slice());else if(A==="string"||A==="list"){let T=new Uint32Array(o+1),E=0;T[0]=0;let S=b,I=0;for(let B=0;B<o;B++){let R=t.getUint32(S+B*8+4,!0);I+=R,T[B+1]=I}let O=b+o*8,F=new Uint8Array(e,O,I).slice();f[_]={_arrowString:!0,offsets:T,bytes:F,isList:A==="list"}}}return{_format:"columnar",columns:c,rowCount:o,data:f}}clear(){let e=P();e&&e.clearTables(),this._registered.clear()}},me=null;function pe(){return me||(me=new ye),me}var be={showVersions:/^\s*SHOW\s+VERSIONS\s+FOR\s+(\w+)\s*$/i,restoreTable:/^\s*RESTORE\s+(\w+)\s+TO\s+VERSION\s+(\d+)\s*$/i,versionAsOf:/FROM\s+(\w+)\s+VERSION\s+AS\s+OF\s+(\d+)/i};function Oe(d){let e;return(e=d.match(be.showVersions))?{type:"SHOW_VERSIONS",table:e[1]}:(e=d.match(be.restoreTable))?{type:"RESTORE_TABLE",table:e[1],version:parseInt(e[2],10)}:(e=d.match(be.versionAsOf))?{type:"SELECT_VERSION",table:e[1],version:parseInt(e[2],10),sql:d}:null}function je(d){let e=/^(SELECT|FROM|WHERE|JOIN|LEFT|RIGHT|INNER|OUTER|ON|AND|OR|NOT|IN|LIKE|BETWEEN|GROUP|ORDER|BY|HAVING|LIMIT|OFFSET|UNION|EXCEPT|INTERSECT|AS|NULL|TRUE|FALSE|IS|CASE|WHEN|THEN|ELSE|END|DISTINCT|ALL|ASC|DESC|CREATE|DROP|INSERT|UPDATE|DELETE|INTO|VALUES|TABLE|INDEX|VIEW|SET|WITH|RECURSIVE)$/i,n=/read_lance\s*\(\s*'([^']+)'\s*\)(?:\s+AS\s+(\w+)|\s+(\w+))?/gi,r=[],t;for(;(t=n.exec(d))!==null;){let s=t[2],l=t[3];l&&e.test(l)&&(l=null);let o=s||l||`_tbl${r.length}`,i=t[0];t[3]&&e.test(t[3])&&(i=`read_lance('${t[1]}')`),console.log(`[Worker] extractReadLanceUrls: found "${i}" -> alias "${o}"`),r.push({fullMatch:i,url:t[1],alias:o})}return console.log(`[Worker] extractReadLanceUrls: found ${r.length} URLs`),r}function Ge(d,e){let n=d;for(let{fullMatch:r,alias:t}of e)console.log(`[Worker] rewriteSqlWithAliases: replacing "${r}" with "${t}"`),n=n.replace(r,t);return console.log(`[Worker] rewriteSqlWithAliases: result = "${n}"`),n}async function qe(d,e=1e4){try{console.log(`[Worker] Fetching remote Lance: ${d}`);let n=`${d}/.meta.json`,r=null,t=[],s=[];try{let a=await fetch(n);if(a.ok){let c=await a.json();r=c.schema,t=c.fragments||[],s=r.map(f=>{let u=f.type;return u.startsWith("vector[")?"vector":u==="float64"||u==="double"?"float64":u==="float32"?"float32":u.includes("int64")?"int64":u.includes("int")?"int32":u==="string"?"string":"unknown"}),console.log(`[Worker] Loaded sidecar: ${r.length} columns, ${t.length} fragments`)}}catch(a){console.log(`[Worker] No sidecar available: ${a.message}`)}if(!r){let a=0,c=[1,5,10,20,50,100];for(let g of c)try{(await fetch(`${d}/_versions/${g}.manifest`,{method:"HEAD"})).ok&&(a=g)}catch{}if(a>0)for(let g=a+1;g<=a+50;g++)try{if((await fetch(`${d}/_versions/${g}.manifest`,{method:"HEAD"})).ok)a=g;else break}catch{break}if(a===0)return console.error(`[Worker] No manifest found for ${d}`),null;let f=await fetch(`${d}/_versions/${a}.manifest`);if(!f.ok)return null;let u=new Uint8Array(await f.arrayBuffer()),y=ze(u);r=y.schema,t=y.fragments,s=r.map(g=>g.type||"unknown")}if(!r||r.length===0)return console.error(`[Worker] No schema found for ${d}`),null;if(t.length===0)return console.error(`[Worker] No fragments found for ${d}`),null;let l=t[0].data_files?.[0]||`${t[0].id}.lance`,o=`${d}/data/${l}`;return await Qe(o,r,s,e)}catch(n){return console.error("[Worker] Failed to fetch remote Lance:",n),null}}function ze(d){let e=new DataView(d.buffer,d.byteOffset),n=[],r=[],t=e.getUint32(0,!0),s=4+t,l;if(s+4<d.length){let c=e.getUint32(s,!0);c>0&&s+4+c<=d.length?l=d.slice(s+4,s+4+c):l=d.slice(4,4+t)}else l=d.slice(4,4+t);let o=0,i=()=>{let c=0,f=0;for(;o<l.length;){let u=l[o++];if(c|=(u&127)<<f,(u&128)===0)break;f+=7}return c},a=c=>{c===0?i():c===2?o+=i():c===5?o+=4:c===1&&(o+=8)};for(;o<l.length;){let c=i(),f=c>>3,u=c&7;if(f===1&&u===2){let y=i(),g=o+y,h=null,m=null,w=null;for(;o<g;){let p=i(),_=p>>3,A=p&7;if(A===0){let b=i();_===3&&(m=b)}else if(A===2){let b=i(),T=l.slice(o,o+b);o+=b,_===2?h=new TextDecoder().decode(T):_===5&&(w=new TextDecoder().decode(T))}else a(A)}h&&n.push({name:h,id:m,type:w})}else if(f===2&&u===2){let y=i(),g=o+y,h=null,m=null,w=0;for(;o<g;){let p=i(),_=p>>3,A=p&7;if(A===0){let b=i();_===1?h=b:_===4&&(w=b)}else if(A===2){let b=i(),T=l.slice(o,o+b);if(o+=b,_===2){let E=0;for(;E<T.length;){let S=T[E++],I=S>>3,O=S&7;if(O===2){let F=0,B=0;for(;E<T.length;){let R=T[E++];if(F|=(R&127)<<B,(R&128)===0)break;B+=7}I===1&&(m=new TextDecoder().decode(T.slice(E,E+F))),E+=F}else if(O===0)for(;E<T.length&&(T[E++]&128)!==0;);else O===5?E+=4:O===1&&(E+=8)}}}else a(A)}m&&r.push({id:h,data_files:[m],num_rows:w})}else a(u)}return{schema:n,fragments:r}}async function Qe(d,e,n,r){if(console.log(`[Worker] Fetching fragment: ${d}`),!L&&(await Q(),!L))throw new Error("WASM not loaded");let t=await fetch(d,{method:"HEAD"});if(!t.ok)throw new Error(`Failed to check fragment size: HTTP ${t.status}`);let s=parseInt(t.headers.get("Content-Length")||"0",10),l=100*1024*1024;if(s>l){console.warn(`[Worker] Fragment too large (${(s/1024/1024).toFixed(1)}MB) - using schema-based placeholder data`);let w={},p=[],_=Math.min(r,100);for(let A=0;A<e.length;A++){let b=e[A].name,T=n[A];p.push(b),T==="float64"||T==="double"||T==="int64"||T==="int32"||T==="float32"?w[b]=new Float64Array(_).fill(0):T==="string"?w[b]=Array(_).fill("(large file - use RemoteLanceDataset)"):w[b]=[]}return{columns:w,rowCount:_,columnNames:p}}let o=await fetch(d);if(!o.ok)throw new Error(`Failed to fetch fragment: HTTP ${o.status}`);let i=new Uint8Array(await o.arrayBuffer());if(console.log(`[Worker] Fetched fragment: ${i.length} bytes`),i.length<40)throw new Error("Fragment too small");let a=String.fromCharCode(i[i.length-4],i[i.length-3],i[i.length-2],i[i.length-1]);if(a!=="LANC")throw new Error(`Invalid Lance magic: ${a}`);let c=L.alloc(i.length);if(!c||c<0)throw new Error("Failed to allocate WASM memory for fragment");new Uint8Array(k.buffer,c,i.length).set(i);let f=L.openFile(c,i.length);if(f!==0)throw new Error(`WASM openFile failed: ${f}`);let u=L.getNumColumns(),y=Number(L.getRowCount(0)),g=Math.min(y,r);console.log(`[Worker] Fragment has ${u} columns, ${y} rows, reading ${g}`);let h={},m=[];for(let w=0;w<e.length&&w<u;w++){let p=e[w].name,_=n[w];m.push(p);try{if(_==="float64"||_==="double"){let A=L.allocFloat64Buffer(g);if(A){let b=L.readFloat64Column(w,A,g);h[p]=new Float64Array(k.buffer,A,b).slice()}else h[p]=new Float64Array(g).fill(0)}else if(_==="int64"){let A=L.allocInt64Buffer(g);if(A){let b=L.readInt64Column(w,A,g),T=new BigInt64Array(k.buffer,A,b),E=new Float64Array(b);for(let S=0;S<b;S++)E[S]=Number(T[S]);h[p]=E}else h[p]=new Float64Array(g).fill(0)}else if(_==="int32"){let A=L.allocInt32Buffer(g);if(A){let b=L.readInt32Column(w,A,g),T=new Int32Array(k.buffer,A,b),E=new Float64Array(b);for(let S=0;S<b;S++)E[S]=T[S];h[p]=E}else h[p]=new Float64Array(g).fill(0)}else if(_==="float32"){let A=L.alloc(g*4);if(A&&A>0){let b=L.readFloat32Column(w,A,g),T=new Float32Array(k.buffer,A,b),E=new Float64Array(b);for(let S=0;S<b;S++)E[S]=T[S];h[p]=E}else h[p]=new Float64Array(g).fill(0)}else _==="string"?h[p]=Array(g).fill("(string data)"):_==="vector"?h[p]=[]:h[p]=[]}catch(A){console.warn(`[Worker] Failed to read column ${p}:`,A),h[p]=[]}}return L.closeFile(),console.log(`[Worker] Read ${g} rows from ${m.length} columns`),{columns:h,rowCount:g,columnNames:m}}async function We(d,e=1e4){try{console.log(`[Worker] Loading OPFS Lance: ${d}`);let n=d.split("/").filter(b=>b),r=n.pop(),l=await(await(await Fe(n)).getFileHandle(r)).getFile(),o=new Uint8Array(await l.arrayBuffer());if(!o||o.length===0)return console.error(`[Worker] Empty OPFS file: ${d}`),null;if(o.length<40)return console.error(`[Worker] File too small for Lance format: ${d}`),null;let i=String.fromCharCode(o[o.length-4],o[o.length-3],o[o.length-2],o[o.length-1]);if(i!=="LANC")return console.error(`[Worker] Invalid Lance magic in ${d}: ${i}`),null;let a=new DataView(o.buffer,o.byteOffset),c=o.length-40,f=Number(a.getBigUint64(c+8,!0)),u=a.getUint32(c+28,!0),y=[],g=[];for(let b=0;b<u;b++){let T=f+b*8;if(T+8>o.length)continue;let E=Number(a.getBigUint64(T,!0));if(E>=o.length)continue;let S=E,I=`col_${b}`,O="unknown";for(;S<o.length&&S<E+200;){let F=o[S];if(F===0)break;let B=F>>3,R=F&7;if(S++,R===2){let J=o[S++];if(J>0&&S+J<=o.length){let M=new TextDecoder().decode(o.slice(S,S+J));B===1?I=M:B===2&&(O=M)}S+=J}else if(R===0){for(;S<o.length&&o[S]&128;)S++;S++}else if(R===1)S+=8;else if(R===5)S+=4;else break}y.push({name:I,type:O}),g.push(O),console.log(`[Worker] OPFS column ${b}: name=${I}, type=${O}`)}if(!L&&(await Q(),!L))throw new Error("WASM not loaded");let h=L.alloc(o.length);if(!h||h<0)throw new Error("Failed to allocate WASM memory for OPFS file");if(new Uint8Array(k.buffer,h,o.length).set(o),L.openFile(h,o.length)===0)throw new Error("WASM openFile failed: invalid Lance file");let w=Number(L.getRowCount(0)),p=Math.min(w,e);console.log(`[Worker] OPFS file has ${u} columns, ${w} rows, reading ${p}`);let _={},A=[];for(let b=0;b<y.length;b++){let{name:T,type:E}=y[b];if(A.push(T),E==="float64"||E==="double"){let S=L.allocFloat64Buffer(p);if(S){let I=L.readFloat64Column(b,S,p);_[T]=new Float64Array(k.buffer,S,I).slice()}else _[T]=new Float64Array(p).fill(0)}else if(E==="int64"){let S=L.allocInt64Buffer(p);if(S){let I=L.readInt64Column(b,S,p),O=new BigInt64Array(k.buffer,S,I),F=new Float64Array(I);for(let B=0;B<I;B++)F[B]=Number(O[B]);_[T]=F}else _[T]=new Float64Array(p).fill(0)}else if(E==="string")_[T]=Array(p).fill("(string)");else if(E.includes("vector")||E.includes("list"))_[T]=[];else{let S=L.allocFloat64Buffer(p);if(S){let I=L.readFloat64Column(b,S,p);I>0?_[T]=new Float64Array(k.buffer,S,I).slice():_[T]=Array(p).fill("")}else _[T]=[]}}return L.closeFile(),console.log(`[Worker] OPFS read ${p} rows from ${A.length} columns: ${A.join(", ")}`),{columns:_,rowCount:p,columnNames:A}}catch(n){return console.error("[Worker] Failed to load OPFS Lance:",n),null}}async function Ue(d,e){if(!L&&(await Q(),!L))throw new Error("WASM not loaded");let n=e.replace(/--[^\n]*/g,"").replace(/\/\*[\s\S]*?\*\//g,"").trim(),r=pe(),t=je(n);for(let{url:o,alias:i}of t){if(r.hasTable(i)){console.log(`[Worker] Table ${i} already registered`);continue}let a=null,c=null;try{if(o.startsWith("https://")||o.startsWith("http://"))console.log(`[Worker] Fetching remote Lance: ${o} as ${i}`),a=await qe(o);else if(o.startsWith("opfs://")){let f=o.replace("opfs://","");console.log(`[Worker] Loading OPFS Lance: ${f} as ${i}`),a=await We(f)}else console.log(`[Worker] Loading OPFS Lance (no prefix): ${o} as ${i}`),a=await We(o)}catch(f){c=f,console.error(`[Worker] Failed to load ${o}:`,f)}if(a){let f=Object.keys(a.columns),u=f.filter(g=>{let h=a.columns[g];return h&&(Array.isArray(h),h.length>0)});console.log(`[Worker] Registering table ${i} with ${a.rowCount} rows, columns: ${f.join(", ")}, non-empty: ${u.join(", ")}`);try{r.registerTable(i,a.columns,a.rowCount,o)}catch(g){throw console.error(`[Worker] Registration error for ${i}:`,g),new Error(`Failed to register table ${i}: ${g.message}`)}let y=r.hasTable(i);if(console.log(`[Worker] hasTable(${i}) = ${y}`),!y)throw new Error(`Failed to register table ${i} from ${o} - hasTable returned false`)}else{let f=c?c.message:"file may not exist or returned empty data";throw new Error(`Could not load read_lance('${o}'): ${f}`)}}let s=t.length>0?Ge(n,t):n,l=r.getTableNames(s);for(let o of l){if(r.hasTable(o))continue;let a=d.tables.get(o);if(!a)continue;let c=d._columnarBuffer?.get(o),f=c?.__length||0,u=`${o}:${a.fragments?.length||0}:${f}:${a.deletionVector?.length||0}`,y=a.fragments.length>0,g=f>0;if(y){let h=[];for(let m of a.fragments){let w=await Xe(m);w&&h.push(w)}if(r.registerTableFromFiles(o,a.fragments,u),g){let m={};for(let w of a.schema){let p=c[w.name];p&&ArrayBuffer.isView(p)&&(m[w.name]=p.subarray(0,f))}r.appendTableMemory(o,m,f)}}else if(g){let h=await d.selectColumnar(o);if(h){let{columns:m,rowCount:w}=h;r.registerTable(o,m,w,u)}}}return r.execute(s)}var L=null,k=null,ee=new Map,Je=1;async function Fe(d){let e=await navigator.storage.getDirectory();e=await e.getDirectoryHandle("lanceql",{create:!0});for(let n of d)e=await e.getDirectoryHandle(n,{create:!0});return e}function Ye(){return{env:{opfs_open:(d,e)=>{try{let n=new Uint8Array(k.buffer,d,e),r=new TextDecoder().decode(n);for(let[t,s]of ee.entries())if(s._path===r)return t;return console.warn("[LanceQLWorker] WASM tried to open unregistered path:",r),0}catch(n){return console.error("[LanceQLWorker] Error:",n),0}},opfs_read:(d,e,n,r)=>{let t=ee.get(d);if(!t)return 0;try{let s=new Uint8Array(k.buffer,e,n);return t.read(s,{at:Number(r)})}catch{return 0}},opfs_size:d=>{let e=ee.get(d);if(!e)return BigInt(0);try{return BigInt(e.getSize())}catch{return BigInt(0)}},opfs_close:d=>{},__assert_fail:(d,e,n,r)=>{let s=new TextDecoder().decode(new Uint8Array(k.buffer,d).subarray(0,100));console.error(`[WASM ASSERT] ${s} at line ${n}`)},js_log:(d,e)=>{let r=new TextDecoder().decode(new Uint8Array(k.buffer,d,e));console.log(`[WASM LOG] ${r}`);for(let t of Le)t.postMessage({type:"log",message:r,marker:"__WASM_LOG_BRIDGE__"})}}}}async function Xe(d){try{let e=d.split("/").filter(o=>o),n=e.pop(),s=await(await(await Fe(e)).getFileHandle(n)).createSyncAccessHandle(),l=Je++;return s._path=d,ee.set(l,s),l}catch(e){return console.warn("[LanceQLWorker] Failed to register OPFS file:",d,e),0}}function Wt(d){let e=ee.get(d);if(e){try{e.close()}catch{}ee.delete(d)}}async function Q(){if(L)return L;try{let d=new URL("./lanceql.wasm",import.meta.url);d.searchParams.set("v",Date.now().toString());let n=await(await fetch(d)).arrayBuffer(),r=Ye();return L=(await WebAssembly.instantiate(n,r)).instance.exports,k=L.memory,console.log("[LanceQLWorker] WASM loaded with OPFS support"),L}catch(d){return console.warn("[LanceQLWorker] WASM not available:",d.message),null}}function P(){return L}function H(){return k}var _e=0,Re=0,Ze=1024*1024;function et(d){if(!L)return 0;if(d<=Re&&_e!==0)return _e;let e=Math.max(d,Ze),n=L.alloc(e);return n&&(_e=n,Re=e),n}async function Ut(d){let e=await Q();if(!e)return 0;try{let n=d.split("/").filter(f=>f),r=n.pop(),l=await(await(await Fe(n)).getFileHandle(r)).createSyncAccessHandle(),o=l.getSize(),i=et(o);if(!i)return l.close(),0;let a=new Uint8Array(k.buffer,i,o),c=l.read(a,{at:0});return l.close(),c!==o?0:e.openFile(i,o)}catch(n){return console.warn("[LanceQLWorker] Failed to load fragment:",d,n),0}}async function tt(d,e){let n=e.split("/").filter(t=>t),r=d;for(let t=0;t<n.length-1;t++)r=await r.getDirectoryHandle(n[t],{create:!1});return await r.getFileHandle(n[n.length-1],{create:!1})}var Ae=null;async function nt(d){let e=Ee.get(d);if(e)return e;Ae||(Ae=await navigator.storage.getDirectory());let t=await(await(await tt(Ae,d)).getFile()).arrayBuffer();return e=new Uint8Array(t),e&&Ee.set(d,e,e.byteLength),e}async function Rt(d,e,n){if(!await nt(d))return null;let t=L;switch(n){case"sum":return t.opfsSumFloat64Column(e);case"min":return t.opfsMinFloat64Column(e);case"max":return t.opfsMaxFloat64Column(e);case"avg":return t.opfsAvgFloat64Column(e);case"count":return Number(t.opfsCountRows());default:return null}}Q();var Ee=new Y,Te=new Map,Se=new Map,ce=null,Le=new Set,Z=null,z=0,rt=1024,fe=new Map,Ne=1;async function j(d=null){return ce||(ce=new le),await ce.open(d),ce}async function U(d,e={},n=null){let r=n?.keyId||"none",t=`${d}:${r}:${JSON.stringify(e)}`;if(!Te.has(t)){let s=new ae(d,e);await s.open(n),Te.set(t,s)}return Te.get(t)}async function v(d){if(!Se.has(d)){let e=new X(d,Ee);await e.open(),Se.set(d,e)}return Se.get(d)}function st(d,e,n){if(n&&n._format==="wasm_binary"){d.postMessage({id:e,result:{_format:"wasm_binary",buffer:n.buffer,columns:n.columns,rowCount:n.rowCount,schema:n.schema}},[n.buffer]);return}if(n&&n._format==="columnar"&&n.data){let r=n.columns,t=n.rowCount;if(t<1e5){let y=[],g={},h=new Set;for(let m of r){let w=n.data[m];if(ArrayBuffer.isView(w)){let p=w.byteOffset!==0||w.byteLength<w.buffer.byteLength,_=h.has(w.buffer);if(p||_){let A=new w.constructor(w);g[m]=A,y.push(A.buffer)}else g[m]=w,y.push(w.buffer),h.add(w.buffer)}else w&&w._arrowString?(g[m]=w,w.offsets&&w.offsets.buffer&&!h.has(w.offsets.buffer)&&(y.push(w.offsets.buffer),h.add(w.offsets.buffer)),w.bytes&&w.bytes.buffer&&!h.has(w.bytes.buffer)&&(y.push(w.bytes.buffer),h.add(w.bytes.buffer))):g[m]=w}d.postMessage({id:e,result:{_format:"columnar",columns:r,rowCount:t,data:g}},y);return}let s=[],l=[],o=0;for(let y of r){let g=n.data[y];ArrayBuffer.isView(g)?(s.push({name:y,arr:g}),o+=g.byteLength):Array.isArray(g)&&l.push({name:y,arr:g})}let i=o>0?new ArrayBuffer(o):null,a={},c=0;if(i){let y=new Uint8Array(i);for(let{name:g,arr:h}of s){let m=new Uint8Array(h.buffer,h.byteOffset,h.byteLength);y.set(m,c),a[g]={offset:c,length:h.length,type:h.constructor.name},c+=h.byteLength}}let f={};for(let{name:y,arr:g}of l)f[y]=g;let u=[];i&&u.push(i),d.postMessage({id:e,result:{_format:"packed",columns:r,rowCount:t,packedBuffer:i,colOffsets:a,stringData:f}},u);return}if(Z&&n!==void 0){let r=JSON.stringify(n);if(r.length>rt){let t=V.encode(r);if(z+t.length<=Z.byteLength){new Uint8Array(Z,z,t.length).set(t),d.postMessage({id:e,sharedOffset:z,sharedLength:t.length}),z+=t.length,z>Z.byteLength/2&&(z=0);return}}}d.postMessage({id:e,result:n})}async function De(d,e){if(e.type==="initSharedBuffer"){Z=e.buffer,z=0,console.log("[LanceQLWorker] SharedArrayBuffer initialized:",Z.byteLength,"bytes");return}let{id:n,method:r,args:t}=e;try{let s;if(r==="ping")s="pong";else if(r==="open")await U(t.name,t.options,t.encryption),s=!0;else if(r==="get")s=await(await U(t.name)).get(t.key);else if(r==="set")await(await U(t.name)).set(t.key,t.value),s=!0;else if(r==="delete")await(await U(t.name)).delete(t.key),s=!0;else if(r==="keys")s=await(await U(t.name)).keys();else if(r==="clear")await(await U(t.name)).clear(),s=!0;else if(r==="filter")s=await(await U(t.name)).filter(t.key,t.query);else if(r==="find")s=await(await U(t.name)).find(t.key,t.query);else if(r==="search")s=await(await U(t.name)).search(t.key,t.text,t.limit);else if(r==="count")s=await(await U(t.name)).count(t.key,t.query);else if(r==="enableSemanticSearch")s=await(await U(t.name)).enableSemanticSearch(t.options);else if(r==="disableSemanticSearch")(await U(t.name)).disableSemanticSearch(),s=!0;else if(r==="hasSemanticSearch")s=(await U(t.name)).hasSemanticSearch();else if(r==="db:open")console.log(`[LanceQLWorker] db:open ${t.name}`),await v(t.name),s=!0;else if(r==="db:createTable")console.log(`[LanceQLWorker] db:createTable ${t.tableName}`),s=await(await v(t.db)).createTable(t.tableName,t.columns,t.ifNotExists),console.log(`[LanceQLWorker] db:createTable ${t.tableName} done`);else if(r==="db:dropTable"){console.log(`[LanceQLWorker] db:dropTable ${t.tableName}`),s=await(await v(t.db)).dropTable(t.tableName,t.ifExists);let o=V.encode(t.tableName);pe().clearTable(o,o.length)}else if(r==="db:insert")console.log(`[LanceQLWorker] db:insert into ${t.tableName}, rows: ${t.rows?.length}`),s=await(await v(t.db)).insert(t.tableName,t.rows),console.log("[LanceQLWorker] db:insert done");else if(r==="db:delete"){let l=await v(t.db),o=t.where?i=>evalWhere(t.where,i):()=>!0;s=await l.delete(t.tableName,o)}else if(r==="db:update"){let l=await v(t.db),o=t.where?i=>evalWhere(t.where,i):()=>!0;s=await l.update(t.tableName,t.updates,o)}else if(r==="db:select"){let l=await v(t.db),o={...t.options};t.where&&(o.where=i=>evalWhere(t.where,i)),s=await l.select(t.tableName,o)}else if(r==="db:exec"){let l=await v(t.db),o=Oe(t.sql);if(o?.type==="SHOW_VERSIONS"){let i=await l.listVersions(o.table);s={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:i.length,data:{version:new Float64Array(i.map(a=>a.version)),timestamp:i.map(a=>new Date(a.timestamp).toISOString()),operation:i.map(a=>a.operation),rowCount:new Float64Array(i.map(a=>a.rowCount))}}}else if(o?.type==="RESTORE_TABLE"){let i=await l.restoreToVersion(o.table,o.version);s={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([i.newVersion])}}}else if(o?.type==="SELECT_VERSION"){let i=await l.selectAtVersion(o.table,o.version,{});if(i.length>0){let a=Object.keys(i[0]),c={};for(let f of a)c[f]=i.map(u=>u[f]);s={_format:"columnar",columns:a,rowCount:i.length,data:c}}else s={_format:"columnar",columns:[],rowCount:0,data:{}}}else s=await Ue(l,t.sql);if(s&&s._format==="columnar"&&s.rowCount>=1e5){let i=Ne++;fe.set(i,s),s={_format:"cursor",cursorId:i,columns:s.columns,rowCount:s.rowCount}}}else if(r==="cursor:fetch"){let l=fe.get(t.cursorId);if(!l)throw new Error("Cursor not found");s=l,fe.delete(t.cursorId)}else if(r==="db:flush")console.log(`[LanceQLWorker] db:flush ${t.db}`),await(await v(t.db)).flush(),console.log(`[LanceQLWorker] db:flush ${t.db} done`),s=!0;else if(r==="db:compact")s=await(await v(t.db)).compact();else if(r==="db:listTables")s=(await v(t.db)).listTables();else if(r==="db:getTable")s=(await v(t.db)).getTable(t.tableName);else if(r==="db:scanStart")s=await(await v(t.db)).scanStart(t.tableName,t.options);else if(r==="db:scanNext")s=(await v(t.db)).scanNext(t.streamId);else if(r==="db:listVersions")s=await(await v(t.db)).listVersions(t.tableName);else if(r==="db:selectAtVersion"){let l=await v(t.db),o={...t.options};t.where&&(o.where=i=>evalWhere(t.where,i)),s=await l.selectAtVersion(t.tableName,t.version,o)}else if(r==="db:restoreTable")s=await(await v(t.db)).restoreToVersion(t.tableName,t.version);else if(r==="vault:open")await j(t.encryption),s=!0;else if(r==="vault:get")s=await(await j()).get(t.key);else if(r==="vault:set")await(await j()).set(t.key,t.value),s=!0;else if(r==="vault:delete")await(await j()).delete(t.key),s=!0;else if(r==="vault:keys")s=await(await j()).keys();else if(r==="vault:has")s=await(await j()).has(t.key);else if(r==="vault:tables"){let l=await j();s=l._db?l._db.listTables():[]}else if(r==="vault:exec"){let o=(await j())._db,i=Oe(t.sql);if(i?.type==="SHOW_VERSIONS"){let a=await o.listVersions(i.table);s={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:a.length,data:{version:new Float64Array(a.map(c=>c.version)),timestamp:a.map(c=>new Date(c.timestamp).toISOString()),operation:a.map(c=>c.operation),rowCount:new Float64Array(a.map(c=>c.rowCount))}}}else if(i?.type==="RESTORE_TABLE"){let a=await o.restoreToVersion(i.table,i.version);s={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([a.newVersion])}}}else if(i?.type==="SELECT_VERSION"){let a=await o.selectAtVersion(i.table,i.version,{});if(a.length>0){let c=Object.keys(a[0]),f={};for(let u of c)f[u]=a.map(y=>y[u]);s={_format:"columnar",columns:c,rowCount:a.length,data:f}}else s={_format:"columnar",columns:[],rowCount:0,data:{}}}else s=await Ue(o,t.sql);if(s&&s._format==="columnar"&&s.rowCount>=1e5){let a=Ne++;fe.set(a,s),s={_format:"cursor",cursorId:a,columns:s.columns,rowCount:s.rowCount}}}else throw new Error(`Unknown method: ${r}`);st(d,n,s)}catch(s){let l=s.stack||s.message;l.includes("TableDoesNotExist")?l="Table does not exist":l.includes("ColumnDoesNotExist")?l="Column does not exist":l.includes("UnknownEmbeddingModel")&&(l="Unknown embedding model"),d.postMessage({id:n,error:l})}}var ot=typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope;ot?self.onconnect=d=>{let e=d.ports[0];Le.add(e),e.onmessage=n=>{De(e,n.data)},e.onmessageerror=n=>{console.error("[LanceQLWorker] Message error:",n)},Q().then(()=>{e.postMessage({type:"ready"})}).catch(n=>{console.error("[LanceQLWorker] Failed to load WASM:",n),e.postMessage({type:"ready",error:"WASM load failed"})}),e.start(),console.log("[LanceQLWorker] New connection, total ports:",Le.size)}:(self.onmessage=d=>{De(self,d.data)},Q().then(()=>{self.postMessage({type:"ready"})}).catch(d=>{console.error("[LanceQLWorker] Failed to load WASM:",d),self.postMessage({type:"ready",error:"WASM load failed"})}));console.log("[LanceQLWorker] Initialized");export{Wt as closeOPFSFile,P as getWasm,H as getWasmMemory,Ut as loadFragmentToWasm,Xe as registerOPFSFile,Rt as wasmAggregate};
//# sourceMappingURL=lanceql-worker.js.map
