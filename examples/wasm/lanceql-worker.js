var P=new Map;async function se(u){return crypto.subtle.importKey("raw",new Uint8Array(u),{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function re(u,e){let n=crypto.getRandomValues(new Uint8Array(12)),t=new TextEncoder().encode(JSON.stringify(u)),r=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},e,t),i=new Uint8Array(12+r.byteLength);return i.set(n,0),i.set(new Uint8Array(r),12),i}async function oe(u,e){let n=u.slice(0,12),s=u.slice(12),t=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},e,s),r=new TextDecoder;return JSON.parse(r.decode(t))}var V=null,ee=null,ue=new Map;function Me(u){V=u}function Pe(u){ee=u}var ae=class{constructor(e,n={}){this.name=e,this.options=n,this._root=null,this._ready=!1,this._embedder=null,this._encryptionKeyId=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:n,keyBytes:s}=e;if(!P.has(n)){let t=await se(s);P.set(n,t)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle(`lanceql-${this.name}`,{create:!0}),this._ready=!0}catch(n){throw console.error("[WorkerStore] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?P.get(this._encryptionKeyId):null}async get(e){await this._ensureOpen();try{let n=this._getCryptoKey(),s=n?".enc":".json",r=await(await this._root.getFileHandle(`${e}${s}`)).getFile();if(n){let i=await r.arrayBuffer();return oe(new Uint8Array(i),n)}else{let i=await r.text();return JSON.parse(i)}}catch(n){if(n.name==="NotFoundError")return;throw n}}async set(e,n){await this._ensureOpen();let s=this._getCryptoKey(),t=s?".enc":".json",i=await(await this._root.getFileHandle(`${e}${t}`,{create:!0})).createWritable();if(s){let o=await re(n,s);await i.write(o)}else await i.write(JSON.stringify(n));await i.close()}async delete(e){await this._ensureOpen();let s=this._getCryptoKey()?".enc":".json";try{await this._root.removeEntry(`${e}${s}`)}catch(t){if(t.name!=="NotFoundError")throw t}}async keys(){await this._ensureOpen();let n=this._getCryptoKey()?".enc":".json",s=[];for await(let[t]of this._root.entries())t.endsWith(n)&&s.push(t.slice(0,-n.length));return s}async clear(){await this._ensureOpen();let e=[];for await(let[n]of this._root.entries())e.push(n);for(let n of e)await this._root.removeEntry(n)}async filter(e,n){let s=await this.get(e);if(!Array.isArray(s))throw new Error(`Key '${e}' is not a collection`);return s.filter(t=>this._matchQuery(t,n))}async find(e,n){let s=await this.get(e);if(!Array.isArray(s))throw new Error(`Key '${e}' is not a collection`);return s.find(t=>this._matchQuery(t,n))}async search(e,n,s=10){let t=await this.get(e);if(!Array.isArray(t))throw new Error(`Key '${e}' is not a collection`);if(t.length===0)return[];if(this._embedder)return this._semanticSearch(t,e,n,s);let r=n.toLowerCase();return t.map(o=>{let c=this._extractText(o).toLowerCase(),a=r.split(/\s+/),l=a.filter(f=>c.includes(f)).length;return{item:o,score:l/a.length}}).filter(o=>o.score>0).sort((o,c)=>c.score-o.score).slice(0,s)}async _semanticSearch(e,n,s,t){let r=await this._embedder.embed(s),i=[],o=[],c=[];for(let a=0;a<e.length;a++){let l=e[a],f=this._extractText(l),h=`${this.name}:${n}:${f}`;if(ue.has(h)){let m=ue.get(h),y=this._cosineSimilarity(r,m);i.push({item:l,score:y})}else o.push(f),c.push(a)}if(o.length>0){let a;o.length>1&&this._embedder.embedBatch?a=await this._embedder.embedBatch(o):a=await Promise.all(o.map(l=>this._embedder.embed(l)));for(let l=0;l<a.length;l++){let f=c[l],h=e[f],m=o[l],y=a[l],d=`${this.name}:${n}:${m}`;ue.set(d,y);let w=this._cosineSimilarity(r,y);i.push({item:h,score:w})}}return i.sort((a,l)=>l.score-a.score).slice(0,t)}async enableSemanticSearch(e={}){let{model:n="minilm",onProgress:s}=e;if(V||(ee||(ee=this._initGPUTransformer(),Pe(ee)),V=await ee,Me(V)),!V)return null;let t=await V.loadModel(n,s);return this._embedder={model:n,dimensions:t.hiddenSize,embed:async r=>V.encodeText(r,n),embedBatch:async r=>V.encodeTextBatch(r,n)},{model:n,dimensions:t.hiddenSize,type:t.modelType||"text"}}async _initGPUTransformer(){try{let e=await import("./webgpu/index.js");if(!e.isWebGPUAvailable())return console.log("[WorkerStore] WebGPU not available"),null;let n=e.getGPUTransformer();return await n.init()?(console.log("[WorkerStore] WebGPU initialized"),n):(console.log("[WorkerStore] WebGPU init failed"),null)}catch(e){return console.error("[WorkerStore] WebGPU init error:",e),null}}disableSemanticSearch(){this._embedder&&V&&(V.unloadModel(this._embedder.model),this._embedder=null)}hasSemanticSearch(){return this._embedder!==null}async count(e,n=null){let s=await this.get(e);if(!Array.isArray(s))throw new Error(`Key '${e}' is not a collection`);return n?s.filter(t=>this._matchQuery(t,n)).length:s.length}async _ensureOpen(){this._ready||await this.open()}_matchQuery(e,n){for(let[s,t]of Object.entries(n)){let r=e[s];if(typeof t=="object"&&t!==null)for(let[i,o]of Object.entries(t))switch(i){case"$eq":if(r!==o)return!1;break;case"$ne":if(r===o)return!1;break;case"$lt":if(!(r<o))return!1;break;case"$lte":if(!(r<=o))return!1;break;case"$gt":if(!(r>o))return!1;break;case"$gte":if(!(r>=o))return!1;break;case"$in":if(!Array.isArray(o)||!o.includes(r))return!1;break;case"$nin":if(Array.isArray(o)&&o.includes(r))return!1;break;case"$contains":if(typeof r!="string"||!r.includes(o))return!1;break;case"$regex":if(typeof r!="string"||!new RegExp(o).test(r))return!1;break}else if(r!==t)return!1}return!0}_extractText(e){if(typeof e=="string")return e;let n=[];for(let[s,t]of Object.entries(e))typeof t=="string"&&n.push(t);return n.join(" ")}_cosineSimilarity(e,n){let s=0,t=0,r=0;for(let i=0;i<e.length;i++)s+=e[i]*n[i],t+=e[i]*e[i],r+=n[i]*n[i];return s/(Math.sqrt(t)*Math.sqrt(r))}};var he=class{constructor(e="lanceql"){this.rootDir=e,this.root=null}async getRoot(){if(this.root)return this.root;if(typeof navigator>"u"||!navigator.storage?.getDirectory)throw new Error("OPFS not available");let e=await navigator.storage.getDirectory();return this.root=await e.getDirectoryHandle(this.rootDir,{create:!0}),this.root}async open(){return await this.getRoot(),this}async getDir(e){let n=await this.getRoot(),s=e.split("/").filter(r=>r),t=n;for(let r of s)t=await t.getDirectoryHandle(r,{create:!0});return t}async save(e,n){let s=e.split("/"),t=s.pop(),r=s.join("/"),o=await(r?await this.getDir(r):await this.getRoot()).getFileHandle(t,{create:!0});if(o.createSyncAccessHandle)try{let a=await o.createSyncAccessHandle();return a.truncate(0),a.write(n,{at:0}),a.flush(),a.close(),{path:e,size:n.byteLength}}catch{}let c=await o.createWritable();return await c.write(n),await c.close(),{path:e,size:n.byteLength}}async load(e){try{let n=e.split("/"),s=n.pop(),t=n.join("/"),c=await(await(await(t?await this.getDir(t):await this.getRoot()).getFileHandle(s)).getFile()).arrayBuffer();return new Uint8Array(c)}catch(n){if(n.name==="NotFoundError")return null;throw n}}async delete(e){try{let n=e.split("/"),s=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(s),!0}catch(n){if(n.name==="NotFoundError")return!1;throw n}}async list(e=""){try{let n=e?await this.getDir(e):await this.getRoot(),s=[];for await(let[t,r]of n.entries())s.push({name:t,type:r.kind});return s}catch{return[]}}async exists(e){try{let n=e.split("/"),s=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).getFileHandle(s),!0}catch{return!1}}async deleteDir(e){try{let n=e.split("/"),s=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(s,{recursive:!0}),!0}catch{return!1}}},B=new he;var D=new TextEncoder,j=new TextDecoder,ve={INT64:"int64",INT32:"int32",FLOAT64:"float64",FLOAT32:"float32",STRING:"string",BOOL:"bool",VECTOR:"vector"},Be=1,Ce=2,$e=3,Fe=4,de=5,we=6;function xe(u){switch(u){case"int32":case"integer":return Int32Array;case"int64":return BigInt64Array;case"float32":case"real":return Float32Array;case"float64":case"double":return Float64Array;default:return null}}function He(u){switch(u){case"int32":case"integer":return Be;case"int64":return Ce;case"float32":case"real":return $e;case"float64":case"double":return Fe;case"string":case"text":return de;case"bool":case"boolean":return we;default:return de}}var ie=class{constructor(e){this.schema=e,this.columns=new Map,this.rowCount=0,this._useBinary=!0}addRows(e){if(e.length!==0){if(this.rowCount===0)for(let n of this.schema){let s=xe(n.dataType);s?this.columns.set(n.name,{type:"typed",dataType:n.dataType,data:new s(Math.max(e.length,1024)),length:0}):this.columns.set(n.name,{type:"array",dataType:n.dataType,data:[],length:0})}for(let n of this.schema){let s=this.columns.get(n.name);if(s.type==="typed"){let t=s.length+e.length;if(t>s.data.length){let r=Math.max(t,s.data.length*2),i=new s.data.constructor(r);i.set(s.data),s.data=i}for(let r=0;r<e.length;r++){let i=e[r][n.name];s.data[s.length+r]=i??0}s.length+=e.length}else{for(let t=0;t<e.length;t++)s.data.push(e[t][n.name]??null);s.length+=e.length}}this.rowCount+=e.length}}buildBinary(){let e=[],n=16,s=[];for(let c of this.schema){let a=this.columns.get(c.name),l=D.encode(c.name),f=He(c.dataType),h;if(a.type==="typed"){let d=a.data.subarray(0,a.length);h=new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}else h=D.encode(JSON.stringify(a.data));s.push({nameBytes:l,typeCode:f,dataBytes:h,dataType:c.dataType});let y=(8-(n+4+l.length+1+4)%8)%8;n+=4+l.length+1+y+4+h.length}let t=new ArrayBuffer(n),r=new DataView(t),i=new Uint8Array(t),o=0;r.setUint32(o,1279348291,!1),o+=4,r.setUint32(o,2,!1),o+=4,r.setUint32(o,this.schema.length,!1),o+=4,r.setUint32(o,this.rowCount,!1),o+=4;for(let c of s){r.setUint32(o,c.nameBytes.length,!1),o+=4,i.set(c.nameBytes,o),o+=c.nameBytes.length,r.setUint8(o,c.typeCode),o+=1;let a=(8-(o+4)%8)%8;for(let l=0;l<a;l++)r.setUint8(o+l,0);o+=a,r.setUint32(o,c.dataBytes.length,!1),o+=4,i.set(c.dataBytes,o),o+=c.dataBytes.length}return new Uint8Array(t)}setColumnarData(e){let n=Object.keys(e)[0];this.rowCount=e[n]?.length||0;for(let s of this.schema){let t=e[s.name];if(!t)continue;let r=xe(s.dataType);if(r&&ArrayBuffer.isView(t))this.columns.set(s.name,{type:"typed",dataType:s.dataType,data:t,length:t.length});else if(r){let i=new r(t.length);for(let o=0;o<t.length;o++)i[o]=t[o]??0;this.columns.set(s.name,{type:"typed",dataType:s.dataType,data:i,length:t.length})}else this.columns.set(s.name,{type:"array",dataType:s.dataType,data:Array.isArray(t)?t:Array.from(t),length:t.length})}}build(){if(this._useBinary&&this.rowCount>0)try{return this.buildBinary()}catch(n){console.warn("[LanceFileWriter] Binary build failed, falling back to JSON:",n)}let e={format:"json",schema:this.schema,columns:{},rowCount:this.rowCount};for(let[n,s]of this.columns)s.type==="typed"?e.columns[n]=Array.from(s.data.subarray(0,s.length)):e.columns[n]=s.data;return D.encode(JSON.stringify(e))}};function te(u){let e=new DataView(u.buffer||u),n=new Uint8Array(u.buffer||u),s=0;if(e.getUint32(s,!1)!==1279348291)return null;s+=4;let r=e.getUint32(s,!1);s+=4;let i=e.getUint32(s,!1);s+=4;let o=e.getUint32(s,!1);s+=4;let c=[],a={};for(let l=0;l<i;l++){let f=e.getUint32(s,!1);s+=4;let h=j.decode(n.subarray(s,s+f));s+=f;let m=e.getUint8(s);s+=1;let y=(8-(s+4)%8)%8;s+=y;let d=e.getUint32(s,!1);s+=4;let w=n.subarray(s,s+d);s+=d;let g,p;try{switch(m){case Be:p="int32",w.byteOffset%4!==0?g=new Int32Array(w.slice().buffer):g=new Int32Array(w.buffer,w.byteOffset,w.byteLength/4);break;case $e:p="float32",w.byteOffset%4!==0?g=new Float32Array(w.slice().buffer):g=new Float32Array(w.buffer,w.byteOffset,w.byteLength/4);break;case Fe:p="float64",w.byteOffset%8!==0?g=new Float64Array(w.slice().buffer):g=new Float64Array(w.buffer,w.byteOffset,w.byteLength/8);break;case Ce:p="int64",w.byteOffset%8!==0?g=new BigInt64Array(w.slice().buffer):g=new BigInt64Array(w.buffer,w.byteOffset,w.byteLength/8);break;case de:case we:default:p=m===we?"bool":"string",g=JSON.parse(j.decode(w));break}}catch(b){throw console.error(`[LanceQLWorker] Error parsing column '${h}' (type ${m}, len ${d}):`,b),b}c.push({name:h,dataType:p}),a[h]=g}return{schema:c,columns:a,rowCount:o,format:"binary"}}var Q=class{constructor(e=512*1024*1024){this.maxBytes=e,this.currentBytes=0,this.cache=new Map,this.head=null,this.tail=null}get(e){let n=this.cache.get(e);if(n)return this._moveToHead(n),n.value}set(e,n,s=0){let t=this.cache.get(e);if(t)this.currentBytes-=t.size,this.currentBytes+=s,t.value=n,t.size=s,this._moveToHead(t);else{let r={key:e,value:n,size:s,prev:null,next:null};this.cache.set(e,r),this._addToHead(r),this.currentBytes+=s}this._evictIfNeeded()}has(e){return this.cache.has(e)}delete(e){let n=this.cache.get(e);n&&(this._removeNode(n),this.cache.delete(e),this.currentBytes-=n.size)}clear(){this.cache.clear(),this.head=null,this.tail=null,this.currentBytes=0}_moveToHead(e){e!==this.head&&(this._removeNode(e),this._addToHead(e))}_addToHead(e){e.next=this.head,e.prev=null,this.head&&(this.head.prev=e),this.head=e,this.tail||(this.tail=e)}_removeNode(e){e.prev?e.prev.next=e.next:this.head=e.next,e.next?e.next.prev=e.prev:this.tail=e.prev}_evictIfNeeded(){for(;this.currentBytes>this.maxBytes&&this.tail;){let e=this.tail;this._removeNode(e),this.cache.delete(e.key),this.currentBytes-=e.size}}static estimateSize(e){return e?e.byteLength?e.byteLength:Array.isArray(e)?e.length*100:e.buffer&&e.buffer.byteLength?e.buffer.byteLength:1e3:0}};var ge=new Map,Ke=1,J=class{constructor(e,n){this.name=e,this.tables=new Map,this.version=0,this.manifestKey=`${e}/__manifest__`,this.bufferPool=n||new Q,this._writeBuffer=new Map,this._flushTimer=null,this._flushInterval=2e3,this._flushThreshold=1e4,this._columnarBuffer=new Map,this._flushing=!1,this._readCache=new Map,this._columnarCache=new Map}async open(){let e=await B.load(this.manifestKey);if(e){let n=JSON.parse(j.decode(e));this.version=n.version||0,this.tables=new Map(Object.entries(n.tables||{}));for(let[s,t]of this.tables)await this._getLatestVersion(s)===0&&t.fragments?.length>0&&await this._createVersion(s,"MIGRATE")}return this}async _saveManifest(){this.version++;let e={version:this.version,timestamp:Date.now(),tables:Object.fromEntries(this.tables)},n=D.encode(JSON.stringify(e));await B.save(this.manifestKey,n)}async _getLatestVersion(e){let n=`${this.name}/${e}/_latest`;try{let s=await B.load(n);return s?parseInt(j.decode(s),10):0}catch{return 0}}async _setLatestVersion(e,n){let s=`${this.name}/${e}/_latest`;await B.save(s,D.encode(String(n)))}async _loadTableVersion(e,n){let s=`${this.name}/${e}/_versions/${n}.manifest`,t=await B.load(s);if(!t)throw new Error(`Version ${n} not found for table '${e}'`);return JSON.parse(j.decode(t))}async _saveTableVersion(e,n){let s=`${this.name}/${e}/_versions/${n.version}.manifest`;await B.save(s,D.encode(JSON.stringify(n)))}async _createVersion(e,n){let s=this.tables.get(e);if(!s)return 0;let t=await this._getLatestVersion(e),r=t+1,i={version:r,timestamp:Date.now(),parentVersion:t,operation:n,schema:s.schema,fragments:[...s.fragments],deletionVector:[...s.deletionVector],rowCount:s.rowCount,nextRowId:s.nextRowId};return await this._saveTableVersion(e,i),await this._setLatestVersion(e,r),r}async listVersions(e){let n=await this._getLatestVersion(e),s=[];for(let t=1;t<=n;t++)try{let r=await this._loadTableVersion(e,t);s.push({version:r.version,timestamp:r.timestamp,operation:r.operation,rowCount:r.rowCount})}catch{}return s}async selectAtVersion(e,n,s={}){let t=await this._loadTableVersion(e,n),r=new Set(t.deletionVector),i=this.tables.get(e),o=[];for(let l of t.fragments){let f=await B.load(l);if(f){let h=this._parseFragment(f,t.schema);for(let m of h)r.has(m.__rowId)||o.push(m)}}let c=o;if(s.where&&(c=c.filter(s.where)),s.orderBy){let{column:l,desc:f}=s.orderBy;c.sort((h,m)=>{let y=h[l]<m[l]?-1:h[l]>m[l]?1:0;return f?-y:y})}s.offset&&(c=c.slice(s.offset)),s.limit&&(c=c.slice(0,s.limit));let a=s.columns&&s.columns.length>0&&s.columns[0]!=="*"?s.columns:null;return c.map(l=>{if(a){let f={};for(let h of a)f[h]=l[h];return f}else{let{__rowId:f,...h}=l;return h}})}async restoreToVersion(e,n){let s=await this._loadTableVersion(e,n),t=await this._getLatestVersion(e),r=t+1,i={...s,version:r,timestamp:Date.now(),parentVersion:t,operation:`RESTORE_FROM_${n}`};await this._saveTableVersion(e,i),await this._setLatestVersion(e,r);let o=this.tables.get(e);return o&&(o.fragments=[...s.fragments],o.deletionVector=[...s.deletionVector],o.rowCount=s.rowCount,o.nextRowId=s.nextRowId,this._columnarBuffer.delete(e),this._writeBuffer.delete(e),await this._saveManifest()),{restored:!0,newVersion:r}}async createTable(e,n,s=!1){if(this.tables.has(e)){if(s)return{success:!0,existed:!0};throw new Error(`Table '${e}' already exists`)}let t=n.map(i=>({name:i.name,type:ve[(i.dataType||i.type)?.toUpperCase()]||i.dataType||i.type||"string",primaryKey:i.primaryKey||!1,vectorDim:i.vectorDim||null})),r={name:e,schema:t,fragments:[],deletionVector:[],rowCount:0,nextRowId:0,version:0,createdAt:Date.now()};return this.tables.set(e,r),await this._saveManifest(),await this._createVersion(e,"CREATE"),{success:!0,table:e}}async dropTable(e,n=!1){if(!this.tables.has(e)){if(n)return this._writeBuffer.delete(e),{success:!0,existed:!1};throw new Error(`Table '${e}' does not exist`)}let s=this.tables.get(e);this._writeBuffer.delete(e);for(let t of s.fragments)this._readCache.delete(t),await B.delete(t);return this.tables.delete(e),await this._saveManifest(),{success:!0,table:e}}async insert(e,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=this.tables.get(e),t=n.length;if(!this._columnarBuffer.has(e)){let c=Math.max(1024,t*2),a={__rowId:new Float64Array(c),__length:0,__capacity:c,__schema:s.schema};for(let l of s.schema){let f=(l.dataType||l.type||"").toLowerCase();f==="text"||f==="string"||f==="varchar"?a[l.name]=new Array(c):f==="int64"||f==="bigint"?a[l.name]=new BigInt64Array(c):a[l.name]=new Float64Array(c)}this._columnarBuffer.set(e,a)}let r=this._columnarBuffer.get(e),i=r.__length,o=r.__capacity;if(i+t>o){let c=Math.max(o*2,i+t),a=new Float64Array(c);a.set(r.__rowId.subarray(0,i)),r.__rowId=a;for(let l of s.schema){let f=r[l.name];if(f instanceof Float64Array){let h=new Float64Array(c);h.set(f.subarray(0,i)),r[l.name]=h}else if(f instanceof BigInt64Array){let h=new BigInt64Array(c);h.set(f.subarray(0,i)),r[l.name]=h}else r[l.name].length=c}r.__capacity=c}for(let c=0;c<t;c++){let a=n[c];r.__rowId[i+c]=s.nextRowId++;for(let l of s.schema){let f=a[l.name];r[l.name]instanceof Float64Array?r[l.name][i+c]=f!=null?Number(f):NaN:r[l.name]instanceof BigInt64Array?r[l.name][i+c]=f!=null?BigInt(f):0n:r[l.name][i+c]=f??null}}return r.__length=i+t,s.rowCount+=t,s.version=(s.version||0)+1,this._scheduleFlush(),r.__length>=this._flushThreshold&&await this._flushTable(e),{success:!0,inserted:t}}_scheduleFlush(){this._flushTimer||(this._flushTimer=setTimeout(()=>{this._flushTimer=null,this.flush().catch(e=>console.warn("[WorkerDatabase] Flush error:",e))},this._flushInterval))}async flush(){if(!this._flushing){this._flushing=!0;try{let e=[...this._columnarBuffer.keys()];for(let n of e)await this._flushTable(n)}finally{this._flushing=!1}}}async _flushTable(e){let n=this._columnarBuffer.get(e),s=n?.__length||0;if(!n||s===0)return;let t=this.tables.get(e);if(!t)return;let r=[{name:"__rowId",type:"int64",dataType:"float64",primaryKey:!0},...t.schema.filter(l=>l.name!=="__rowId").map(l=>{let f=(l.dataType||l.type||"").toLowerCase();return f==="int64"||f==="bigint"?{...l,dataType:"int64"}:{...l,dataType:f==="float64"||f==="float32"||f==="int32"||f==="integer"||f==="real"||f==="double"?"float64":l.dataType||l.type||"float64"}})],i={};for(let l of r){let f=n[l.name];f&&(f instanceof Float64Array||f instanceof BigInt64Array?i[l.name]=f.subarray(0,s):i[l.name]=f.slice(0,s))}n.__length=0;let o=new ie(r);o.setColumnarData(i);let c=o.build(),a=`${this.name}/${e}/frag_${Date.now()}_${Math.random().toString(36).slice(2)}.lance`;await B.save(a,c),t.fragments.push(a),await this._saveManifest(),await this._createVersion(e,"INSERT")}async delete(e,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=this.tables.get(e),t=0,r=this._columnarBuffer.get(e),i=r?.__length||0;if(r&&i>0){let o=s.schema.map(c=>c.name);for(let c=0;c<i;c++){let a={__rowId:r.__rowId[c]};for(let l of o){let f=r[l][c];a[l]=Number.isNaN(f)?null:f}n(a)&&(s.deletionVector.includes(r.__rowId[c])||(s.deletionVector.push(r.__rowId[c]),t++))}}for(let o of s.fragments){let c=await B.load(o);if(c){let a=this._parseFragment(c,s.schema);for(let l of a)!s.deletionVector.includes(l.__rowId)&&n(l)&&(s.deletionVector.push(l.__rowId),t++)}}return s.rowCount-=t,s.version=(s.version||0)+1,await this._saveManifest(),t>0&&await this._createVersion(e,"DELETE"),{success:!0,deleted:t}}async update(e,n,s){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let t=this.tables.get(e),r=0,i=this._writeBuffer.get(e);if(i&&i.length>0)for(let c of i)s(c)&&(Object.assign(c,n),r++);let o=[];for(let c of t.fragments){let a=await B.load(c);if(a){let l=this._parseFragment(a,t.schema);for(let f of l)if(!t.deletionVector.includes(f.__rowId)&&s(f)){t.deletionVector.push(f.__rowId),t.rowCount--;let h={...f,...n};delete h.__rowId,o.push(h),r++}}}return o.length>0?await this.insert(e,o):await this._saveManifest(),r>0&&o.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:r}}async updateWithExpr(e,n,s,t){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=this.tables.get(e),i=0,o=this._columnarBuffer.get(e),c=o?.__length||0;if(o&&c>0){let l=r.schema.map(f=>f.name);for(let f=0;f<c;f++){let h={__rowId:o.__rowId[f]};for(let m of l){let y=o[m][f];h[m]=Number.isNaN(y)?null:y}if(s(h)){for(let[m,y]of Object.entries(n)){let d=t(y,h);o[m]!==void 0&&(o[m][f]=d??(o[m]instanceof Float64Array?NaN:null))}r.version=(r.version||0)+1,i++}}}let a=[];for(let l of r.fragments){let f=await B.load(l);if(f){let h=this._parseFragment(f,r.schema);for(let m of h)if(!r.deletionVector.includes(m.__rowId)&&s(m)){r.deletionVector.push(m.__rowId),r.rowCount--;let y={...m};for(let[d,w]of Object.entries(n))y[d]=t(w,m);delete y.__rowId,a.push(y),i++}}}return a.length>0?await this.insert(e,a):await this._saveManifest(),i>0&&a.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:i}}async select(e,n={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=await this._readAllRows(e);if(n.where&&(s=s.filter(n.where)),n.orderBy){let{column:i,desc:o}=n.orderBy;s.sort((c,a)=>{let l=c[i]<a[i]?-1:c[i]>a[i]?1:0;return o?-l:l})}n.offset&&(s=s.slice(n.offset)),n.limit&&(s=s.slice(0,n.limit));let t=n.columns&&n.columns.length>0&&n.columns[0]!=="*"?n.columns:null,r=new Array(s.length);for(let i=0;i<s.length;i++){let o=s[i];if(t){let c={};for(let a of t)c[a]=o[a];r[i]=c}else{let{__rowId:c,...a}=o;r[i]=a}}return r}async _readAllRows(e){let n=this.tables.get(e),s=this._columnarBuffer.get(e),r=n.deletionVector.length>0?new Set(n.deletionVector):null,i=[];for(let c of n.fragments){let a=this.bufferPool.get(c),l=null;if(!a){let f=await B.load(c);f&&(a=te(f),a?this.bufferPool.set(c,a,f.byteLength):l=this._parseFragment(f,n.schema))}if(a&&!l&&(l=this._hydrateRowsFromBinary(a,n.schema)),l=l||[],!r)i.push(...l);else for(let f of l)r.has(f.__rowId)||i.push(f)}let o=s?.__length||0;if(s&&o>0){let c=n.schema.map(a=>a.name);for(let a=0;a<o;a++){if(r&&r.has(s.__rowId[a]))continue;let l={__rowId:s.__rowId[a]};for(let f of c){let h=s[f][a];l[f]=Number.isNaN(h)?null:h}i.push(l)}}return i}_hydrateRowsFromBinary(e,n){let{columns:s,rowCount:t}=e,r=n.map(o=>o.name),i=new Array(t);for(let o=0;o<t;o++){let c={__rowId:s.__rowId[o]};for(let a of r)s[a]&&(c[a]=s[a][o]);i[o]=c}return i}_parseFragment(e,n){try{let s=te(e);if(s)return this._parseBinaryColumnar(s);let t=j.decode(e),r=JSON.parse(t);return r.format==="json"&&r.columns?this._parseJsonColumnar(r):Array.isArray(r)?r:[r]}catch(s){return console.warn("[WorkerDatabase] Failed to parse fragment:",s),[]}}async selectColumnar(e){let n=this.tables.get(e);if(!n)return null;let s=this._columnarBuffer.get(e)?.__length||0,t=`${n.fragments.length}:${s}:${n.deletionVector.length}:${n.version||0}`,r=this._columnarCache.get(e);if(r&&r.version===t){let d={};for(let[w,g]of Object.entries(r.data.columns))ArrayBuffer.isView(g)?d[w]=new g.constructor(g.buffer,g.byteOffset,g.length):d[w]=g;return{schema:n.schema,columns:d,rowCount:r.data.rowCount}}let o=n.deletionVector.length>0?new Set(n.deletionVector):null,c={},a=n.schema.map(d=>d.name);for(let d of a)c[d]=[];c.__rowId=[];for(let d of n.fragments){let w=this.bufferPool.get(d);if(!w){let b=await B.load(d);if(!b)continue;w=te(b),w&&this.bufferPool.set(d,w,b.byteLength)}if(!w)continue;let{columns:g,rowCount:p}=w;if(o){let b=g.__rowId,A=[];for(let _=0;_<p;_++)o.has(b[_])||A.push(_);for(let _ of a)if(g[_]){let S=g[_],T=new S.constructor(A.length);for(let E=0;E<A.length;E++)T[E]=S[A[E]];c[_].push(T)}}else{for(let b of a)g[b]&&c[b].push(g[b]);g.__rowId&&c.__rowId.push(g.__rowId)}}let l=this._columnarBuffer.get(e),f=l?.__length||0;if(l&&f>0)if(o){let d=[];for(let p=0;p<f;p++)o.has(l.__rowId[p])||d.push(p);let w=d.length;for(let p of n.schema){let b=l[p.name];if(b)if(b instanceof Float64Array){let A=new Float64Array(w);for(let _=0;_<w;_++)A[_]=b[d[_]];c[p.name].push(A)}else c[p.name].push(d.map(A=>b[A]))}let g=new Float64Array(w);for(let p=0;p<w;p++)g[p]=l.__rowId[d[p]];c.__rowId.push(g)}else{for(let w of n.schema){let g=l[w.name];if(g)if(g instanceof Float64Array){let p=new Float64Array(f);p.set(g.subarray(0,f)),c[w.name].push(p)}else c[w.name].push(g.slice(0,f))}let d=new Float64Array(f);d.set(l.__rowId.subarray(0,f)),c.__rowId.push(d)}let h={},m=0;for(let d of[...a,"__rowId"]){let w=c[d];if(w.length===0)h[d]=new Float64Array(0);else if(w.length===1)h[d]=w[0],m===0&&(m=w[0].length);else{let g=w.reduce((_,S)=>_+S.length,0);m===0&&(m=g);let p=w[0],b=ArrayBuffer.isView(p)?new p.constructor(g):new Array(g),A=0;for(let _ of w){if(ArrayBuffer.isView(b))b.set(_,A);else for(let S=0;S<_.length;S++)b[A+S]=_[S];A+=_.length}h[d]=b}}let y={schema:n.schema,columns:h,rowCount:m};return this._columnarCache.set(e,{version:t,data:y}),y}async _readColumn(e,n){let s=this.tables.get(e);if(!s)return null;let t=this._writeBuffer.get(e),r=[];for(let a of s.fragments){let l=await B.load(a);if(!l)continue;let f=te(l);if(f&&f.columns[n]){let h=f.columns[n];h.length>0&&r.push(h)}}if(t&&t.length>0){let a=new Float64Array(t.length);for(let l=0;l<t.length;l++){let f=t[l][n];a[l]=typeof f=="number"?f:0}r.push(a)}if(r.length===0)return new Float64Array(0);if(r.length===1)return r[0];let i=r.reduce((a,l)=>a+l.length,0),o=new Float64Array(i),c=0;for(let a of r)o.set(a,c),c+=a.length;return o}_parseBinaryColumnar(e){let{schema:n,columns:s,rowCount:t}=e,r=new Array(t),i=n.map(a=>a.name),o=i.map(a=>s[a]),c=i.length;for(let a=0;a<t;a++){let l={};for(let f=0;f<c;f++)l[i[f]]=o[f][a]??null;r[a]=l}return r}_parseJsonColumnar(e){let{schema:n,columns:s,rowCount:t}=e,r=new Array(t),i=n.map(a=>a.name),o=i.map(a=>s[a]||[]),c=i.length;for(let a=0;a<t;a++){let l={};for(let f=0;f<c;f++)l[i[f]]=o[f][a]??null;r[a]=l}return r}getTable(e){return this.tables.get(e)}listTables(){return Array.from(this.tables.keys())}getFragmentPaths(e){let n=this.tables.get(e);return n?n.fragments:[]}getColumnIndex(e,n){let s=this.tables.get(e);if(!s)return-1;let t=s.schema.findIndex(r=>r.name===n);return t>=0?t+1:-1}hasBufferedData(e){let n=this._columnarBuffer.get(e);return n&&(n.__length||0)>0}async compact(){for(let[e,n]of this.tables){let s=await this._readAllRows(e);for(let t of n.fragments)await B.delete(t);if(n.fragments=[],n.deletionVector=[],n.rowCount=0,n.nextRowId=0,s.length>0){let t=s.map(({__rowId:r,...i})=>i);await this.insert(e,t)}}return{success:!0,compacted:this.tables.size}}async scanStart(e,n={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=Ke++,t=this.tables.get(e),r=new Set(t.deletionVector),i=[];for(let c of t.fragments){let a=await B.load(c);if(a){let l=this._parseFragment(a,t.schema);for(let f of l)r.has(f.__rowId)||i.push(f)}}let o=this._writeBuffer.get(e);if(o)for(let c of o)r.has(c.__rowId)||i.push(c);return ge.set(s,{rows:i,index:0,batchSize:n.batchSize||1e4,columns:n.columns}),s}scanNext(e){let n=ge.get(e);if(!n)return{batch:[],done:!0};let s=[],t=Math.min(n.index+n.batchSize,n.rows.length);for(let i=n.index;i<t;i++){let o=n.rows[i],c;if(n.columns&&n.columns.length>0&&n.columns[0]!=="*"){c={};for(let a of n.columns)c[a]=o[a]}else{let{__rowId:a,...l}=o;c=l}s.push(c)}n.index=t;let r=n.index>=n.rows.length;return r&&ge.delete(e),{batch:s,done:r}}};var ce=class{constructor(){this._root=null,this._ready=!1,this._kv={},this._encryptionKeyId=null,this._db=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:n,keyBytes:s}=e;if(!P.has(n)){let t=await se(s);P.set(n,t)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle("vault",{create:!0}),await this._loadKV(),this._db=new J("vault"),await this._db.open(),this._ready=!0}catch(n){throw console.error("[WorkerVault] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?P.get(this._encryptionKeyId):null}async _loadKV(){try{let e=this._getCryptoKey(),n=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(n)).getFile();if(e){let r=await t.arrayBuffer();this._kv=await oe(new Uint8Array(r),e)}else{let r=await t.text();this._kv=JSON.parse(r)}}catch(e){if(e.name==="NotFoundError")this._kv={};else throw e}}async _saveKV(){let e=this._getCryptoKey(),n=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(n,{create:!0})).createWritable();if(e){let r=await re(this._kv,e);await t.write(r)}else await t.write(JSON.stringify(this._kv));await t.close()}async get(e){return this._kv[e]}async set(e,n){this._kv[e]=n,await this._saveKV()}async delete(e){delete this._kv[e],await this._saveKV()}async keys(){return Object.keys(this._kv)}async has(e){return e in this._kv}};var je=1;var Oe={INT64:0,FLOAT64:1,INT32:2,FLOAT32:3,STRING:4,LIST:5},ye=class{constructor(){this._registered=new Map}getLastError(){let e=N();if(!e)return"WASM not loaded";let n=M(),s=e.alloc(4096);console.log(`[WASM LOG] getLastError alloc ptr: ${s}`);let t=e.getLastError(s,4096);if(console.log(`[WASM LOG] getLastError len: ${t}`),t===0)return"Unknown Error";let r=new Uint8Array(n.buffer,s,t),i=new TextDecoder().decode(r);return console.log(`[WASM LOG] getLastError msg: ${i}`),i}getTableNames(e){let n=N();if(!n)throw new Error("WASM not loaded");let s=M(),t=new TextEncoder().encode(e),r=n.alloc(t.length);new Uint8Array(s.buffer,r,t.length).set(t);let i=n.getTableNames(r,t.length);if(i===0)return[];let o=new Uint8Array(s.buffer,i),c=0;for(;o[c]!==0&&c<1024;)c++;let a=new TextDecoder().decode(o.subarray(0,c));return a?a.split(",").filter(l=>l):[]}hasTable(e){let n=N();if(!n)return!1;let s=M(),t=new TextEncoder().encode(e),r=n.alloc(t.length);return new Uint8Array(s.buffer,r,t.length).set(t),n.hasTable(r,t.length)===1}registerTable(e,n,s,t=""){let r=N();if(!r)throw new Error("WASM not loaded");let i=this._registered.get(e);if(i&&i.version===t)return;if(i){let f=new TextEncoder().encode(e);r.clearTable(f,f.length)}let o=M();if(!o||!o.buffer)throw new Error("WASM memory not available");let c=new TextEncoder().encode(e),a=r.alloc(c.length);if(a<0||a>=o.buffer.byteLength)throw new Error(`Invalid alloc result: ${a} for ${c.length} bytes`);new Uint8Array(o.buffer,a,c.length).set(c);let l=new Set;for(let[f,h]of Object.entries(n)){if(f.startsWith("__")||Array.isArray(h)&&h.length===0)continue;let m=new TextEncoder().encode(f),y=r.alloc(m.length);if(y<0||y>=o.buffer.byteLength)throw new Error(`Invalid colName alloc: ${y}`);if(new Uint8Array(o.buffer,y,m.length).set(m),h instanceof Float64Array){let d=r.allocFloat64Buffer(h.length);if(d===0||d<0||d>=o.buffer.byteLength)throw new Error(`Invalid Float64 alloc: ${d} for ${h.length} elements`);new Float64Array(o.buffer,d,h.length).set(h),r.registerTableFloat64(a,c.length,y,m.length,d,h.length),l.add(f)}else if(h instanceof BigInt64Array){let d=r.allocInt64Buffer(h.length);new BigInt64Array(o.buffer,d,h.length).set(h),r.registerTableInt64(a,c.length,y,m.length,d,h.length),l.add(f)}else if(h instanceof Int32Array){let d=new Float64Array(h.length);for(let g=0;g<h.length;g++)d[g]=h[g];let w=r.allocFloat64Buffer(d.length);new Float64Array(o.buffer,w,d.length).set(d),r.registerTableFloat64(a,c.length,y,m.length,w,d.length),l.add(f)}else if(Array.isArray(h)){let d=new Uint32Array(h.length),w=new Uint32Array(h.length),g=0;for(let T=0;T<h.length;T++){let E=String(h[T]||"");w[T]=E.length,d[T]=g,g+=E.length}let p=new Uint8Array(g),b=0;for(let T=0;T<h.length;T++){let E=String(h[T]||""),v=new TextEncoder().encode(E);p.set(v,b),b+=v.length}let A=r.alloc(d.byteLength);if(A<0||A>=o.buffer.byteLength)throw new Error(`Invalid offsetsPtr alloc: ${A}`);new Uint32Array(o.buffer,A,d.length).set(d);let _=r.alloc(w.byteLength);if(_<0||_>=o.buffer.byteLength)throw new Error(`Invalid lengthsPtr alloc: ${_}`);new Uint32Array(o.buffer,_,w.length).set(w);let S=r.alloc(p.length||1);if(S<0||S>=o.buffer.byteLength)throw new Error(`Invalid dataPtr alloc: ${S}`);new Uint8Array(o.buffer,S,p.length).set(p),r.registerTableString(a,c.length,y,m.length,A,_,S,g,h.length),l.add(f)}}this._registered.set(e,{version:t,columns:l,rowCount:s})}registerTableFromFiles(e,n,s=""){let t=N();if(!t)throw new Error("WASM not loaded");let r=this._registered.get(e);if(r&&r.version===s)return;if(r){let a=new TextEncoder().encode(e);t.clearTable(a,a.length)}let i=new TextEncoder,o=i.encode(e),c=t.alloc(o.length);new Uint8Array(M().buffer,c,o.length).set(o);for(let a of n){let l=i.encode(a),f=t.alloc(l.length);new Uint8Array(M().buffer,f,l.length).set(l);let h=t.registerTableFromOPFS(c,o.length,f,l.length);h!==0&&console.warn(`Failed to register fragment ${a} for table ${e}: error ${h}`)}this._registered.set(e,{version:s,type:"files"})}appendTableMemory(e,n,s){let t=N();if(!t)throw new Error("WASM not loaded");let r=M(),i=new TextEncoder().encode(e),o=t.alloc(i.length);new Uint8Array(r.buffer,o,i.length).set(i);for(let[c,a]of Object.entries(n)){if(c.startsWith("__"))continue;let l=new TextEncoder().encode(c),f=t.alloc(l.length);if(new Uint8Array(r.buffer,f,l.length).set(l),a instanceof Float64Array){let h=t.allocFloat64Buffer(a.length);new Float64Array(r.buffer,h,a.length).set(a),t.appendTableMemory(o,i.length,f,l.length,h,4,s)}else if(a instanceof BigInt64Array){let h=t.allocInt64Buffer(a.length);new BigInt64Array(r.buffer,h,a.length).set(a),t.appendTableMemory(o,i.length,f,l.length,h,2,s)}else if(a instanceof Int32Array){let h=t.alloc(a.byteLength);new Int32Array(r.buffer,h,a.length).set(a),t.appendTableMemory(o,i.length,f,l.length,h,1,s)}else if(a instanceof Float32Array){let h=t.alloc(a.byteLength);new Float32Array(r.buffer,h,a.length).set(a),t.appendTableMemory(o,i.length,f,l.length,h,3,s)}}}execute(e){let n=N();if(!n)throw new Error("WASM not loaded");let s=M();if(n.setCurrentTimestamp)try{n.setCurrentTimestamp(BigInt(Date.now()))}catch(h){console.warn("setCurrentTimestamp failed:",h)}let t=n.getSqlInputBuffer(),r=n.getSqlInputBufferSize(),i=new TextEncoder().encode(e);if(i.length>r)throw new Error(`SQL too long: ${i.length} > ${r}`);new Uint8Array(s.buffer,t,i.length).set(i),n.setSqlInputLength(i.length);let o=n.executeSql();if(o===0){let h=this.getLastError();throw console.log(`[WASM LOG] execute throwing: "${h}"`),new Error(h)}let c=n.getResultSize(),a=this.getLastError();a&&a.length>0&&console.log(`[WASM DEBUG CAPTURED] ${a}`),a.length>0&&a.startsWith("DEBUG:");let l=n.memory.buffer,f=this._parseResult(s.buffer,o,c);return n.resetResult(),f}_parseResult(e,n,s){let t=new DataView(e,n,s),r=new TextDecoder;if(s>=40){let i=s-40,o=[t.getUint8(i+36),t.getUint8(i+37),t.getUint8(i+38),t.getUint8(i+39)];if(String.fromCharCode(...o)==="LANC")return this._parseLanceResult(e,n,s,i,t,r)}if(s>=36&&t.getUint32(0,!0)===je)return this._parseLegacyResult(e,n,s);throw new Error(`Invalid result format (Size: ${s}). Not a Lance file.`)}_parseLanceResult(e,n,s,t,r,i){let o=Number(r.getBigUint64(t+8,!0)),c=r.getUint32(t+28,!0),a=[],l={},f=0;for(let h=0;h<c;h++){let m=o+h*8,d=Number(r.getBigUint64(m,!0));r.getUint8(d++);let[w,g]=this._readVarint(r,d);d+=g;let p=new Uint8Array(e,n+d,w),b=i.decode(p);d+=w,a.push(b),r.getUint8(d++);let[A,_]=this._readVarint(r,d);d+=_;let S=new Uint8Array(e,n+d,A),T=i.decode(S);d+=A,r.getUint8(d++);let[E,v]=this._readVarint(r,d);d+=v,r.getUint8(d++);let x=Number(r.getBigUint64(d,!0));d+=8,r.getUint8(d++);let[L,F]=this._readVarint(r,d);d+=F,f=L,r.getUint8(d++);let[R,Z]=this._readVarint(r,d);d+=Z;let z=n+x;if(T==="float64"||T==="int64"||T==="int32"||T==="float32")if(T==="float64"){let U=new Float64Array(e,z,L).slice(),O=!1;for(let I=0;I<L;I++)if(Number.isNaN(U[I])){O=!0;break}if(O){console.log(`[WASM LOG] Column ${b} has NaNs, converting to nulls`);let I=new Array(L);for(let C=0;C<L;C++){let K=U[C];I[C]=Number.isNaN(K)?null:K}l[b]=I}else l[b]=U}else if(T==="int64"){let U=new BigInt64Array(e,z,L),O=new Array(L),I=-9223372036854775808n;for(let C=0;C<L;C++){let K=U[C];O[C]=K===I?null:Number(K)}l[b]=O}else if(T==="int32"){let U=new Int32Array(e,z,L),O=new Array(L);for(let I=0;I<L;I++){let C=U[I];C===-2147483648?O[I]=null:O[I]=C}l[b]=O}else{let U=new Float32Array(e,z,L),O=new Array(L);for(let I=0;I<L;I++){let C=U[I];O[I]=isNaN(C)?null:C}l[b]=O}else if(T==="string"||T==="list"){let U=T==="list",O=(L+1)*4,I=R-O,C=new Uint8Array(e,z,I).slice(),K=new Uint32Array(e,z+I,L+1).slice();l[b]={_arrowString:!0,offsets:K,bytes:C,isList:T==="list",nullable:E===1}}}return{_format:"columnar",columns:a,rowCount:f,data:l}}_readVarint(e,n){let s=0,t=0,r=0;for(;;){let i=e.getUint8(n+r);if(r++,s|=(i&127)<<t,(i&128)===0)break;t+=7}return[s,r]}_parseLegacyResult(e,n,s){let t=new DataView(e,n,s),r=new TextDecoder,i=t.getUint32(4,!0),o=Number(t.getBigUint64(8,!0)),c=t.getUint32(24,!0),a=t.getUint32(32,!0),l=[],f={};for(let h=0;h<i;h++){let m=36+h*16,y=t.getUint32(m,!0),d=t.getUint32(m+4,!0),w=t.getUint32(m+8,!0),g=t.getUint32(m+12,!0),p=new Uint8Array(e,n+a+d,w),b=r.decode(p);l.push(b);let A=Object.keys(Oe).find(S=>Oe[S]===y).toLowerCase(),_=n+c+g;if(A==="float64"||A==="int64"||A==="int32"||A==="float32")A==="float64"?f[b]=new Float64Array(e,_,o).slice():A==="int64"?f[b]=new Float64Array(e,_,o).slice():A==="int32"?f[b]=new Int32Array(e,_,o).slice():A==="float32"&&(f[b]=new Float32Array(e,_,o).slice());else if(A==="string"||A==="list"){let S=new Uint32Array(o+1),T=0;S[0]=0;let E=_,v=0;for(let F=0;F<o;F++){let R=t.getUint32(E+F*8+4,!0);v+=R,S[F+1]=v}let x=_+o*8,L=new Uint8Array(e,x,v).slice();f[b]={_arrowString:!0,offsets:S,bytes:L,isList:A==="list"}}}return{_format:"columnar",columns:l,rowCount:o,data:f}}clear(){let e=N();e&&e.clearTables(),this._registered.clear()}},me=null;function pe(){return me||(me=new ye),me}var be={showVersions:/^\s*SHOW\s+VERSIONS\s+FOR\s+(\w+)\s*$/i,restoreTable:/^\s*RESTORE\s+(\w+)\s+TO\s+VERSION\s+(\d+)\s*$/i,versionAsOf:/FROM\s+(\w+)\s+VERSION\s+AS\s+OF\s+(\d+)/i};function ke(u){let e;return(e=u.match(be.showVersions))?{type:"SHOW_VERSIONS",table:e[1]}:(e=u.match(be.restoreTable))?{type:"RESTORE_TABLE",table:e[1],version:parseInt(e[2],10)}:(e=u.match(be.versionAsOf))?{type:"SELECT_VERSION",table:e[1],version:parseInt(e[2],10),sql:u}:null}function Ge(u){let e=/^(SELECT|FROM|WHERE|JOIN|LEFT|RIGHT|INNER|OUTER|ON|AND|OR|NOT|IN|LIKE|BETWEEN|GROUP|ORDER|BY|HAVING|LIMIT|OFFSET|UNION|EXCEPT|INTERSECT|AS|NULL|TRUE|FALSE|IS|CASE|WHEN|THEN|ELSE|END|DISTINCT|ALL|ASC|DESC|CREATE|DROP|INSERT|UPDATE|DELETE|INTO|VALUES|TABLE|INDEX|VIEW|SET|WITH|RECURSIVE)$/i,n=/read_lance\s*\(\s*'([^']+)'\s*\)(?:\s+AS\s+(\w+)|\s+(\w+))?/gi,s=[],t;for(;(t=n.exec(u))!==null;){let r=t[2],i=t[3];i&&e.test(i)&&(i=null);let o=r||i||`_tbl${s.length}`,c=t[0];t[3]&&e.test(t[3])&&(c=`read_lance('${t[1]}')`),console.log(`[Worker] extractReadLanceUrls: found "${c}" -> alias "${o}"`),s.push({fullMatch:c,url:t[1],alias:o})}return console.log(`[Worker] extractReadLanceUrls: found ${s.length} URLs`),s}function qe(u,e){let n=u;for(let{fullMatch:s,alias:t}of e)console.log(`[Worker] rewriteSqlWithAliases: replacing "${s}" with "${t}"`),n=n.replace(s,t);return console.log(`[Worker] rewriteSqlWithAliases: result = "${n}"`),n}async function ze(u,e=1e4){try{console.log(`[Worker] Fetching remote Lance: ${u}`);let n=`${u}/.meta.json`,s=null,t=[],r=[];try{let a=await fetch(n);if(a.ok){let l=await a.json();s=l.schema,t=l.fragments||[],r=s.map(f=>{let h=f.type;return h.startsWith("vector[")?"vector":h==="float64"||h==="double"?"float64":h==="float32"?"float32":h.includes("int64")?"int64":h.includes("int")?"int32":h==="string"?"string":"unknown"}),console.log(`[Worker] Loaded sidecar: ${s.length} columns, ${t.length} fragments`)}}catch(a){console.log(`[Worker] No sidecar available: ${a.message}`)}if(!s){let a=0,l=[1,5,10,20,50,100];for(let y of l)try{(await fetch(`${u}/_versions/${y}.manifest`,{method:"HEAD"})).ok&&(a=y)}catch{}if(a>0)for(let y=a+1;y<=a+50;y++)try{if((await fetch(`${u}/_versions/${y}.manifest`,{method:"HEAD"})).ok)a=y;else break}catch{break}if(a===0)return console.error(`[Worker] No manifest found for ${u}`),null;let f=await fetch(`${u}/_versions/${a}.manifest`);if(!f.ok)return null;let h=new Uint8Array(await f.arrayBuffer()),m=Qe(h);s=m.schema,t=m.fragments,r=s.map(y=>y.type||"unknown")}if(!s||s.length===0)return console.error(`[Worker] No schema found for ${u}`),null;if(t.length===0)return console.error(`[Worker] No fragments found for ${u}`),null;let i=t[0].data_files?.[0]||`${t[0].id}.lance`,o=`${u}/data/${i}`;return await Je(o,s,r,e)}catch(n){return console.error("[Worker] Failed to fetch remote Lance:",n),null}}function Qe(u){let e=new DataView(u.buffer,u.byteOffset),n=[],s=[],t=e.getUint32(0,!0),r=4+t,i;if(r+4<u.length){let l=e.getUint32(r,!0);l>0&&r+4+l<=u.length?i=u.slice(r+4,r+4+l):i=u.slice(4,4+t)}else i=u.slice(4,4+t);let o=0,c=()=>{let l=0,f=0;for(;o<i.length;){let h=i[o++];if(l|=(h&127)<<f,(h&128)===0)break;f+=7}return l},a=l=>{l===0?c():l===2?o+=c():l===5?o+=4:l===1&&(o+=8)};for(;o<i.length;){let l=c(),f=l>>3,h=l&7;if(f===1&&h===2){let m=c(),y=o+m,d=null,w=null,g=null;for(;o<y;){let p=c(),b=p>>3,A=p&7;if(A===0){let _=c();b===3&&(w=_)}else if(A===2){let _=c(),S=i.slice(o,o+_);o+=_,b===2?d=new TextDecoder().decode(S):b===5&&(g=new TextDecoder().decode(S))}else a(A)}d&&n.push({name:d,id:w,type:g})}else if(f===2&&h===2){let m=c(),y=o+m,d=null,w=null,g=0;for(;o<y;){let p=c(),b=p>>3,A=p&7;if(A===0){let _=c();b===1?d=_:b===4&&(g=_)}else if(A===2){let _=c(),S=i.slice(o,o+_);if(o+=_,b===2){let T=0;for(;T<S.length;){let E=S[T++],v=E>>3,x=E&7;if(x===2){let L=0,F=0;for(;T<S.length;){let R=S[T++];if(L|=(R&127)<<F,(R&128)===0)break;F+=7}v===1&&(w=new TextDecoder().decode(S.slice(T,T+L))),T+=L}else if(x===0)for(;T<S.length&&(S[T++]&128)!==0;);else x===5?T+=4:x===1&&(T+=8)}}}else a(A)}w&&s.push({id:d,data_files:[w],num_rows:g})}else a(h)}return{schema:n,fragments:s}}async function Je(u,e,n,s){console.log(`[Worker] Fetching fragment: ${u}`);let t={},r=[],i=Math.min(s,100);for(let o=0;o<e.length;o++){let c=e[o].name,a=n[o];r.push(c),a==="float64"||a==="double"||a==="int64"?t[c]=new Float64Array(i).fill(0):a==="int32"?t[c]=new Float64Array(i).fill(0):a==="float32"?t[c]=new Float64Array(i).fill(0):a==="string"?t[c]=Array(i).fill(""):a==="vector"?t[c]=[]:t[c]=[]}return console.log(`[Worker] Created placeholder data with ${i} rows for ${e.length} columns`),{columns:t,rowCount:i,columnNames:r}}function We(u,e){let n=0,s=0,t=0;for(;e+t<u.length;){let r=u[e+t];if(t++,n|=(r&127)<<s,(r&128)===0||(s+=7,s>35))break}return[n,t]}function Ye(u,e,n,s){let t=new DataView(u.buffer,u.byteOffset),r=u.length-40,i=Number(t.getBigUint64(r,!0)),o=Number(t.getBigUint64(r+8,!0)),c=t.getUint32(r+28,!0);console.log(`[Worker] parseLanceFileData: ${c} columns, metaStart=${i}, offsetsStart=${o}`);let a={},l=[],f=0;for(let h=0;h<c&&h<e.length;h++){let m=o+h*8;if(m+8>u.length){console.warn(`[Worker] Column ${h} offset position out of bounds`);continue}let y=Number(t.getBigUint64(m,!0));if(y>=u.length){console.warn(`[Worker] Column ${h} metadata position ${y} out of bounds`);continue}let d=y,w=e[h]?.name||`col_${h}`,g=n[h]||"unknown",p=0,b=0,A=0;for(;d<u.length&&d<y+500;){let T=u[d],E=T>>3,v=T&7;if(d++,E===0)break;if(v===0){let[x,L]=We(u,d);d+=L,E===3||(E===5?b=x:E===6&&(A=x))}else if(v===1){if(d+8>u.length)break;E===4&&(p=Number(t.getBigUint64(d,!0))),d+=8}else if(v===2){let[x,L]=We(u,d);if(d+=L,d+x>u.length)break;E===1?w=new TextDecoder().decode(u.slice(d,d+x)):E===2&&(g=new TextDecoder().decode(u.slice(d,d+x))),d+=x}else if(v===5)d+=4;else break}l.push(w),f===0&&(f=b),console.log(`[Worker] Column ${h}: name=${w}, type=${g}, dataOffset=${p}, rowCount=${b}, dataSize=${A}`);let _=Math.min(f,s);if(_===0||p===0){console.log(`[Worker] Column ${w}: skipping (actualRows=${_}, dataOffset=${p})`),a[w]=[];continue}let S=n[h]||g;try{if(S==="float64"||g==="float64"||g==="double")a[w]=new Float64Array(u.buffer,u.byteOffset+p,_).slice();else if(S==="int64"||g==="int64"){let T=new BigInt64Array(u.buffer,u.byteOffset+p,_);a[w]=new BigInt64Array(T)}else if(S==="int32"||g==="int32")a[w]=new Int32Array(u.buffer,u.byteOffset+p,_).slice();else if(S==="float32"||g==="float32")a[w]=new Float32Array(u.buffer,u.byteOffset+p,_).slice();else if(S==="string"||g==="string"){let T=(_+1)*4,E=A-T;if(E>0&&p+A<=u.length){let v=new Uint32Array(u.buffer,u.byteOffset+p+E,_+1),x=u.slice(p,p+E),L=[];for(let F=0;F<_;F++){let R=v[F],Z=v[F+1];R<=Z&&Z<=x.length?L.push(new TextDecoder().decode(x.slice(R,Z))):L.push("")}a[w]=L}else a[w]=[]}else S==="vector"||g.startsWith("fixed_size_list")?a[w]=[]:a[w]=[]}catch(T){console.warn(`[Worker] Failed to read column ${w}:`,T),a[w]=[]}}return{columns:a,rowCount:Math.min(f,s),columnNames:l}}async function Ue(u,e=1e4){try{console.log(`[Worker] Loading OPFS Lance: ${u}`);let n=u.split("/").filter(d=>d),s=n.pop(),i=await(await(await Ie(n)).getFileHandle(s)).getFile(),o=new Uint8Array(await i.arrayBuffer());if(!o||o.length===0)return console.error(`[Worker] Empty OPFS file: ${u}`),null;if(o.length<40)return console.error(`[Worker] File too small for Lance format: ${u}`),null;let c=String.fromCharCode(o[o.length-4],o[o.length-3],o[o.length-2],o[o.length-1]);if(c!=="LANC")return console.error(`[Worker] Invalid Lance magic in ${u}: ${c}`),null;let a=new DataView(o.buffer,o.byteOffset),l=o.length-40,f=Number(a.getBigUint64(l+8,!0)),h=a.getUint32(l+28,!0),m=[],y=[];for(let d=0;d<h;d++){let w=f+d*8,p=Number(a.getBigUint64(w,!0));o[p++];let b=o[p++],A=new TextDecoder().decode(o.slice(p,p+b));p+=b,o[p++];let _=o[p++],S=new TextDecoder().decode(o.slice(p,p+_));m.push({name:A,type:S}),y.push(S)}return Ye(o,m,y,e)}catch(n){return console.error("[Worker] Failed to load OPFS Lance:",n),null}}async function Ve(u,e){if(!W&&(await ne(),!W))throw new Error("WASM not loaded");let n=e.replace(/--[^\n]*/g,"").replace(/\/\*[\s\S]*?\*\//g,"").trim(),s=pe(),t=Ge(n);for(let{url:o,alias:c}of t){if(s.hasTable(c)){console.log(`[Worker] Table ${c} already registered`);continue}let a=null,l=null;try{if(o.startsWith("https://")||o.startsWith("http://"))console.log(`[Worker] Fetching remote Lance: ${o} as ${c}`),a=await ze(o);else if(o.startsWith("opfs://")){let f=o.replace("opfs://","");console.log(`[Worker] Loading OPFS Lance: ${f} as ${c}`),a=await Ue(f)}else console.log(`[Worker] Loading OPFS Lance (no prefix): ${o} as ${c}`),a=await Ue(o)}catch(f){l=f,console.error(`[Worker] Failed to load ${o}:`,f)}if(a){if(console.log(`[Worker] Registering table ${c} with ${a.rowCount} rows, columns: ${Object.keys(a.columns).join(", ")}`),s.registerTable(c,a.columns,a.rowCount,o),!s.hasTable(c))throw new Error(`Failed to register table ${c} from ${o}`)}else{let f=l?l.message:"file may not exist or returned empty data";throw new Error(`Could not load read_lance('${o}'): ${f}`)}}let r=t.length>0?qe(n,t):n,i=s.getTableNames(r);for(let o of i){if(s.hasTable(o))continue;let a=u.tables.get(o);if(!a)continue;let l=u._columnarBuffer?.get(o),f=l?.__length||0,h=`${o}:${a.fragments?.length||0}:${f}:${a.deletionVector?.length||0}`,m=a.fragments.length>0,y=f>0;if(m){let d=[];for(let w of a.fragments){let g=await et(w);g&&d.push(g)}if(s.registerTableFromFiles(o,a.fragments,h),y){let w={};for(let g of a.schema){let p=l[g.name];p&&ArrayBuffer.isView(p)&&(w[g.name]=p.subarray(0,f))}s.appendTableMemory(o,w,f)}}else if(y){let d=await u.selectColumnar(o);if(d){let{columns:w,rowCount:g}=d;s.registerTable(o,w,g,h)}}}return s.execute(r)}var W=null,q=null,X=new Map,Xe=1;async function Ie(u){let e=await navigator.storage.getDirectory();e=await e.getDirectoryHandle("lanceql",{create:!0});for(let n of u)e=await e.getDirectoryHandle(n,{create:!0});return e}function Ze(){return{env:{opfs_open:(u,e)=>{try{let n=new Uint8Array(q.buffer,u,e),s=new TextDecoder().decode(n);for(let[t,r]of X.entries())if(r._path===s)return t;return console.warn("[LanceQLWorker] WASM tried to open unregistered path:",s),0}catch(n){return console.error("[LanceQLWorker] Error:",n),0}},opfs_read:(u,e,n,s)=>{let t=X.get(u);if(!t)return 0;try{let r=new Uint8Array(q.buffer,e,n);return t.read(r,{at:Number(s)})}catch{return 0}},opfs_size:u=>{let e=X.get(u);if(!e)return BigInt(0);try{return BigInt(e.getSize())}catch{return BigInt(0)}},opfs_close:u=>{},__assert_fail:(u,e,n,s)=>{let r=new TextDecoder().decode(new Uint8Array(q.buffer,u).subarray(0,100));console.error(`[WASM ASSERT] ${r} at line ${n}`)},js_log:(u,e)=>{let s=new TextDecoder().decode(new Uint8Array(q.buffer,u,e));console.log(`[WASM LOG] ${s}`);for(let t of Ee)t.postMessage({type:"log",message:s,marker:"__WASM_LOG_BRIDGE__"})}}}}async function et(u){try{let e=u.split("/").filter(o=>o),n=e.pop(),r=await(await(await Ie(e)).getFileHandle(n)).createSyncAccessHandle(),i=Xe++;return r._path=u,X.set(i,r),i}catch(e){return console.warn("[LanceQLWorker] Failed to register OPFS file:",u,e),0}}function Vt(u){let e=X.get(u);if(e){try{e.close()}catch{}X.delete(u)}}async function ne(){if(W)return W;try{let u=new URL("./lanceql.wasm",import.meta.url);u.searchParams.set("v",Date.now().toString());let n=await(await fetch(u)).arrayBuffer(),s=Ze();return W=(await WebAssembly.instantiate(n,s)).instance.exports,q=W.memory,console.log("[LanceQLWorker] WASM loaded with OPFS support"),W}catch(u){return console.warn("[LanceQLWorker] WASM not available:",u.message),null}}function N(){return W}function M(){return q}var _e=0,De=0,tt=1024*1024;function nt(u){if(!W)return 0;if(u<=De&&_e!==0)return _e;let e=Math.max(u,tt),n=W.alloc(e);return n&&(_e=n,De=e),n}async function Dt(u){let e=await ne();if(!e)return 0;try{let n=u.split("/").filter(f=>f),s=n.pop(),i=await(await(await Ie(n)).getFileHandle(s)).createSyncAccessHandle(),o=i.getSize(),c=nt(o);if(!c)return i.close(),0;let a=new Uint8Array(q.buffer,c,o),l=i.read(a,{at:0});return i.close(),l!==o?0:e.openFile(c,o)}catch(n){return console.warn("[LanceQLWorker] Failed to load fragment:",u,n),0}}async function st(u,e){let n=e.split("/").filter(t=>t),s=u;for(let t=0;t<n.length-1;t++)s=await s.getDirectoryHandle(n[t],{create:!1});return await s.getFileHandle(n[n.length-1],{create:!1})}var Ae=null;async function rt(u){let e=Le.get(u);if(e)return e;Ae||(Ae=await navigator.storage.getDirectory());let t=await(await(await st(Ae,u)).getFile()).arrayBuffer();return e=new Uint8Array(t),e&&Le.set(u,e,e.byteLength),e}async function Rt(u,e,n){if(!await rt(u))return null;let t=W;switch(n){case"sum":return t.opfsSumFloat64Column(e);case"min":return t.opfsMinFloat64Column(e);case"max":return t.opfsMaxFloat64Column(e);case"avg":return t.opfsAvgFloat64Column(e);case"count":return Number(t.opfsCountRows());default:return null}}ne();var Le=new Q,Te=new Map,Se=new Map,le=null,Ee=new Set,Y=null,G=0,ot=1024,fe=new Map,Re=1;async function H(u=null){return le||(le=new ce),await le.open(u),le}async function k(u,e={},n=null){let s=n?.keyId||"none",t=`${u}:${s}:${JSON.stringify(e)}`;if(!Te.has(t)){let r=new ae(u,e);await r.open(n),Te.set(t,r)}return Te.get(t)}async function $(u){if(!Se.has(u)){let e=new J(u,Le);await e.open(),Se.set(u,e)}return Se.get(u)}function at(u,e,n){if(n&&n._format==="wasm_binary"){u.postMessage({id:e,result:{_format:"wasm_binary",buffer:n.buffer,columns:n.columns,rowCount:n.rowCount,schema:n.schema}},[n.buffer]);return}if(n&&n._format==="columnar"&&n.data){let s=n.columns,t=n.rowCount;if(t<1e5){let m=[],y={},d=new Set;for(let w of s){let g=n.data[w];if(ArrayBuffer.isView(g)){let p=g.byteOffset!==0||g.byteLength<g.buffer.byteLength,b=d.has(g.buffer);if(p||b){let A=new g.constructor(g);y[w]=A,m.push(A.buffer)}else y[w]=g,m.push(g.buffer),d.add(g.buffer)}else g&&g._arrowString?(y[w]=g,g.offsets&&g.offsets.buffer&&!d.has(g.offsets.buffer)&&(m.push(g.offsets.buffer),d.add(g.offsets.buffer)),g.bytes&&g.bytes.buffer&&!d.has(g.bytes.buffer)&&(m.push(g.bytes.buffer),d.add(g.bytes.buffer))):y[w]=g}u.postMessage({id:e,result:{_format:"columnar",columns:s,rowCount:t,data:y}},m);return}let r=[],i=[],o=0;for(let m of s){let y=n.data[m];ArrayBuffer.isView(y)?(r.push({name:m,arr:y}),o+=y.byteLength):Array.isArray(y)&&i.push({name:m,arr:y})}let c=o>0?new ArrayBuffer(o):null,a={},l=0;if(c){let m=new Uint8Array(c);for(let{name:y,arr:d}of r){let w=new Uint8Array(d.buffer,d.byteOffset,d.byteLength);m.set(w,l),a[y]={offset:l,length:d.length,type:d.constructor.name},l+=d.byteLength}}let f={};for(let{name:m,arr:y}of i)f[m]=y;let h=[];c&&h.push(c),u.postMessage({id:e,result:{_format:"packed",columns:s,rowCount:t,packedBuffer:c,colOffsets:a,stringData:f}},h);return}if(Y&&n!==void 0){let s=JSON.stringify(n);if(s.length>ot){let t=D.encode(s);if(G+t.length<=Y.byteLength){new Uint8Array(Y,G,t.length).set(t),u.postMessage({id:e,sharedOffset:G,sharedLength:t.length}),G+=t.length,G>Y.byteLength/2&&(G=0);return}}}u.postMessage({id:e,result:n})}async function Ne(u,e){if(e.type==="initSharedBuffer"){Y=e.buffer,G=0,console.log("[LanceQLWorker] SharedArrayBuffer initialized:",Y.byteLength,"bytes");return}let{id:n,method:s,args:t}=e;try{let r;if(s==="ping")r="pong";else if(s==="open")await k(t.name,t.options,t.encryption),r=!0;else if(s==="get")r=await(await k(t.name)).get(t.key);else if(s==="set")await(await k(t.name)).set(t.key,t.value),r=!0;else if(s==="delete")await(await k(t.name)).delete(t.key),r=!0;else if(s==="keys")r=await(await k(t.name)).keys();else if(s==="clear")await(await k(t.name)).clear(),r=!0;else if(s==="filter")r=await(await k(t.name)).filter(t.key,t.query);else if(s==="find")r=await(await k(t.name)).find(t.key,t.query);else if(s==="search")r=await(await k(t.name)).search(t.key,t.text,t.limit);else if(s==="count")r=await(await k(t.name)).count(t.key,t.query);else if(s==="enableSemanticSearch")r=await(await k(t.name)).enableSemanticSearch(t.options);else if(s==="disableSemanticSearch")(await k(t.name)).disableSemanticSearch(),r=!0;else if(s==="hasSemanticSearch")r=(await k(t.name)).hasSemanticSearch();else if(s==="db:open")console.log(`[LanceQLWorker] db:open ${t.name}`),await $(t.name),r=!0;else if(s==="db:createTable")console.log(`[LanceQLWorker] db:createTable ${t.tableName}`),r=await(await $(t.db)).createTable(t.tableName,t.columns,t.ifNotExists),console.log(`[LanceQLWorker] db:createTable ${t.tableName} done`);else if(s==="db:dropTable"){console.log(`[LanceQLWorker] db:dropTable ${t.tableName}`),r=await(await $(t.db)).dropTable(t.tableName,t.ifExists);let o=D.encode(t.tableName);pe().clearTable(o,o.length)}else if(s==="db:insert")console.log(`[LanceQLWorker] db:insert into ${t.tableName}, rows: ${t.rows?.length}`),r=await(await $(t.db)).insert(t.tableName,t.rows),console.log("[LanceQLWorker] db:insert done");else if(s==="db:delete"){let i=await $(t.db),o=t.where?c=>evalWhere(t.where,c):()=>!0;r=await i.delete(t.tableName,o)}else if(s==="db:update"){let i=await $(t.db),o=t.where?c=>evalWhere(t.where,c):()=>!0;r=await i.update(t.tableName,t.updates,o)}else if(s==="db:select"){let i=await $(t.db),o={...t.options};t.where&&(o.where=c=>evalWhere(t.where,c)),r=await i.select(t.tableName,o)}else if(s==="db:exec"){let i=await $(t.db),o=ke(t.sql);if(o?.type==="SHOW_VERSIONS"){let c=await i.listVersions(o.table);r={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:c.length,data:{version:new Float64Array(c.map(a=>a.version)),timestamp:c.map(a=>new Date(a.timestamp).toISOString()),operation:c.map(a=>a.operation),rowCount:new Float64Array(c.map(a=>a.rowCount))}}}else if(o?.type==="RESTORE_TABLE"){let c=await i.restoreToVersion(o.table,o.version);r={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([c.newVersion])}}}else if(o?.type==="SELECT_VERSION"){let c=await i.selectAtVersion(o.table,o.version,{});if(c.length>0){let a=Object.keys(c[0]),l={};for(let f of a)l[f]=c.map(h=>h[f]);r={_format:"columnar",columns:a,rowCount:c.length,data:l}}else r={_format:"columnar",columns:[],rowCount:0,data:{}}}else r=await Ve(i,t.sql);if(r&&r._format==="columnar"&&r.rowCount>=1e5){let c=Re++;fe.set(c,r),r={_format:"cursor",cursorId:c,columns:r.columns,rowCount:r.rowCount}}}else if(s==="cursor:fetch"){let i=fe.get(t.cursorId);if(!i)throw new Error("Cursor not found");r=i,fe.delete(t.cursorId)}else if(s==="db:flush")console.log(`[LanceQLWorker] db:flush ${t.db}`),await(await $(t.db)).flush(),console.log(`[LanceQLWorker] db:flush ${t.db} done`),r=!0;else if(s==="db:compact")r=await(await $(t.db)).compact();else if(s==="db:listTables")r=(await $(t.db)).listTables();else if(s==="db:getTable")r=(await $(t.db)).getTable(t.tableName);else if(s==="db:scanStart")r=await(await $(t.db)).scanStart(t.tableName,t.options);else if(s==="db:scanNext")r=(await $(t.db)).scanNext(t.streamId);else if(s==="db:listVersions")r=await(await $(t.db)).listVersions(t.tableName);else if(s==="db:selectAtVersion"){let i=await $(t.db),o={...t.options};t.where&&(o.where=c=>evalWhere(t.where,c)),r=await i.selectAtVersion(t.tableName,t.version,o)}else if(s==="db:restoreTable")r=await(await $(t.db)).restoreToVersion(t.tableName,t.version);else if(s==="vault:open")await H(t.encryption),r=!0;else if(s==="vault:get")r=await(await H()).get(t.key);else if(s==="vault:set")await(await H()).set(t.key,t.value),r=!0;else if(s==="vault:delete")await(await H()).delete(t.key),r=!0;else if(s==="vault:keys")r=await(await H()).keys();else if(s==="vault:has")r=await(await H()).has(t.key);else if(s==="vault:tables"){let i=await H();r=i._db?i._db.listTables():[]}else if(s==="vault:exec"){let o=(await H())._db,c=ke(t.sql);if(c?.type==="SHOW_VERSIONS"){let a=await o.listVersions(c.table);r={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:a.length,data:{version:new Float64Array(a.map(l=>l.version)),timestamp:a.map(l=>new Date(l.timestamp).toISOString()),operation:a.map(l=>l.operation),rowCount:new Float64Array(a.map(l=>l.rowCount))}}}else if(c?.type==="RESTORE_TABLE"){let a=await o.restoreToVersion(c.table,c.version);r={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([a.newVersion])}}}else if(c?.type==="SELECT_VERSION"){let a=await o.selectAtVersion(c.table,c.version,{});if(a.length>0){let l=Object.keys(a[0]),f={};for(let h of l)f[h]=a.map(m=>m[h]);r={_format:"columnar",columns:l,rowCount:a.length,data:f}}else r={_format:"columnar",columns:[],rowCount:0,data:{}}}else r=await Ve(o,t.sql);if(r&&r._format==="columnar"&&r.rowCount>=1e5){let a=Re++;fe.set(a,r),r={_format:"cursor",cursorId:a,columns:r.columns,rowCount:r.rowCount}}}else throw new Error(`Unknown method: ${s}`);at(u,n,r)}catch(r){let i=r.stack||r.message;i.includes("TableDoesNotExist")?i="Table does not exist":i.includes("ColumnDoesNotExist")?i="Column does not exist":i.includes("UnknownEmbeddingModel")&&(i="Unknown embedding model"),u.postMessage({id:n,error:i})}}var it=typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope;it?self.onconnect=u=>{let e=u.ports[0];Ee.add(e),e.onmessage=n=>{Ne(e,n.data)},e.onmessageerror=n=>{console.error("[LanceQLWorker] Message error:",n)},ne().then(()=>{e.postMessage({type:"ready"})}).catch(n=>{console.error("[LanceQLWorker] Failed to load WASM:",n),e.postMessage({type:"ready",error:"WASM load failed"})}),e.start(),console.log("[LanceQLWorker] New connection, total ports:",Ee.size)}:(self.onmessage=u=>{Ne(self,u.data)},ne().then(()=>{self.postMessage({type:"ready"})}).catch(u=>{console.error("[LanceQLWorker] Failed to load WASM:",u),self.postMessage({type:"ready",error:"WASM load failed"})}));console.log("[LanceQLWorker] Initialized");export{Vt as closeOPFSFile,N as getWasm,M as getWasmMemory,Dt as loadFragmentToWasm,et as registerOPFSFile,Rt as wasmAggregate};
//# sourceMappingURL=lanceql-worker.js.map
