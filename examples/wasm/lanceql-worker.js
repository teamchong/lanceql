var W=new Map;async function ee(h){return crypto.subtle.importKey("raw",new Uint8Array(h),{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function te(h,e){let n=crypto.getRandomValues(new Uint8Array(12)),t=new TextEncoder().encode(JSON.stringify(h)),r=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},e,t),o=new Uint8Array(12+r.byteLength);return o.set(n,0),o.set(new Uint8Array(r),12),o}async function ne(h,e){let n=h.slice(0,12),s=h.slice(12),t=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},e,s),r=new TextDecoder;return JSON.parse(r.decode(t))}var U=null,Y=null,fe=new Map;function We(h){U=h}function $e(h){Y=h}var se=class{constructor(e,n={}){this.name=e,this.options=n,this._root=null,this._ready=!1,this._embedder=null,this._encryptionKeyId=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:n,keyBytes:s}=e;if(!W.has(n)){let t=await ee(s);W.set(n,t)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle(`lanceql-${this.name}`,{create:!0}),this._ready=!0}catch(n){throw console.error("[WorkerStore] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?W.get(this._encryptionKeyId):null}async get(e){await this._ensureOpen();try{let n=this._getCryptoKey(),s=n?".enc":".json",r=await(await this._root.getFileHandle(`${e}${s}`)).getFile();if(n){let o=await r.arrayBuffer();return ne(new Uint8Array(o),n)}else{let o=await r.text();return JSON.parse(o)}}catch(n){if(n.name==="NotFoundError")return;throw n}}async set(e,n){await this._ensureOpen();let s=this._getCryptoKey(),t=s?".enc":".json",o=await(await this._root.getFileHandle(`${e}${t}`,{create:!0})).createWritable();if(s){let a=await te(n,s);await o.write(a)}else await o.write(JSON.stringify(n));await o.close()}async delete(e){await this._ensureOpen();let s=this._getCryptoKey()?".enc":".json";try{await this._root.removeEntry(`${e}${s}`)}catch(t){if(t.name!=="NotFoundError")throw t}}async keys(){await this._ensureOpen();let n=this._getCryptoKey()?".enc":".json",s=[];for await(let[t]of this._root.entries())t.endsWith(n)&&s.push(t.slice(0,-n.length));return s}async clear(){await this._ensureOpen();let e=[];for await(let[n]of this._root.entries())e.push(n);for(let n of e)await this._root.removeEntry(n)}async filter(e,n){let s=await this.get(e);if(!Array.isArray(s))throw new Error(`Key '${e}' is not a collection`);return s.filter(t=>this._matchQuery(t,n))}async find(e,n){let s=await this.get(e);if(!Array.isArray(s))throw new Error(`Key '${e}' is not a collection`);return s.find(t=>this._matchQuery(t,n))}async search(e,n,s=10){let t=await this.get(e);if(!Array.isArray(t))throw new Error(`Key '${e}' is not a collection`);if(t.length===0)return[];if(this._embedder)return this._semanticSearch(t,e,n,s);let r=n.toLowerCase();return t.map(a=>{let c=this._extractText(a).toLowerCase(),i=r.split(/\s+/),l=i.filter(f=>c.includes(f)).length;return{item:a,score:l/i.length}}).filter(a=>a.score>0).sort((a,c)=>c.score-a.score).slice(0,s)}async _semanticSearch(e,n,s,t){let r=await this._embedder.embed(s),o=[],a=[],c=[];for(let i=0;i<e.length;i++){let l=e[i],f=this._extractText(l),u=`${this.name}:${n}:${f}`;if(fe.has(u)){let m=fe.get(u),g=this._cosineSimilarity(r,m);o.push({item:l,score:g})}else a.push(f),c.push(i)}if(a.length>0){let i;a.length>1&&this._embedder.embedBatch?i=await this._embedder.embedBatch(a):i=await Promise.all(a.map(l=>this._embedder.embed(l)));for(let l=0;l<i.length;l++){let f=c[l],u=e[f],m=a[l],g=i[l],d=`${this.name}:${n}:${m}`;fe.set(d,g);let y=this._cosineSimilarity(r,g);o.push({item:u,score:y})}}return o.sort((i,l)=>l.score-i.score).slice(0,t)}async enableSemanticSearch(e={}){let{model:n="minilm",onProgress:s}=e;if(U||(Y||(Y=this._initGPUTransformer(),$e(Y)),U=await Y,We(U)),!U)return null;let t=await U.loadModel(n,s);return this._embedder={model:n,dimensions:t.hiddenSize,embed:async r=>U.encodeText(r,n),embedBatch:async r=>U.encodeTextBatch(r,n)},{model:n,dimensions:t.hiddenSize,type:t.modelType||"text"}}async _initGPUTransformer(){try{let e=await import("./webgpu/index.js");if(!e.isWebGPUAvailable())return console.log("[WorkerStore] WebGPU not available"),null;let n=e.getGPUTransformer();return await n.init()?(console.log("[WorkerStore] WebGPU initialized"),n):(console.log("[WorkerStore] WebGPU init failed"),null)}catch(e){return console.error("[WorkerStore] WebGPU init error:",e),null}}disableSemanticSearch(){this._embedder&&U&&(U.unloadModel(this._embedder.model),this._embedder=null)}hasSemanticSearch(){return this._embedder!==null}async count(e,n=null){let s=await this.get(e);if(!Array.isArray(s))throw new Error(`Key '${e}' is not a collection`);return n?s.filter(t=>this._matchQuery(t,n)).length:s.length}async _ensureOpen(){this._ready||await this.open()}_matchQuery(e,n){for(let[s,t]of Object.entries(n)){let r=e[s];if(typeof t=="object"&&t!==null)for(let[o,a]of Object.entries(t))switch(o){case"$eq":if(r!==a)return!1;break;case"$ne":if(r===a)return!1;break;case"$lt":if(!(r<a))return!1;break;case"$lte":if(!(r<=a))return!1;break;case"$gt":if(!(r>a))return!1;break;case"$gte":if(!(r>=a))return!1;break;case"$in":if(!Array.isArray(a)||!a.includes(r))return!1;break;case"$nin":if(Array.isArray(a)&&a.includes(r))return!1;break;case"$contains":if(typeof r!="string"||!r.includes(a))return!1;break;case"$regex":if(typeof r!="string"||!new RegExp(a).test(r))return!1;break}else if(r!==t)return!1}return!0}_extractText(e){if(typeof e=="string")return e;let n=[];for(let[s,t]of Object.entries(e))typeof t=="string"&&n.push(t);return n.join(" ")}_cosineSimilarity(e,n){let s=0,t=0,r=0;for(let o=0;o<e.length;o++)s+=e[o]*n[o],t+=e[o]*e[o],r+=n[o]*n[o];return s/(Math.sqrt(t)*Math.sqrt(r))}};var ue=class{constructor(e="lanceql"){this.rootDir=e,this.root=null}async getRoot(){if(this.root)return this.root;if(typeof navigator>"u"||!navigator.storage?.getDirectory)throw new Error("OPFS not available");let e=await navigator.storage.getDirectory();return this.root=await e.getDirectoryHandle(this.rootDir,{create:!0}),this.root}async open(){return await this.getRoot(),this}async getDir(e){let n=await this.getRoot(),s=e.split("/").filter(r=>r),t=n;for(let r of s)t=await t.getDirectoryHandle(r,{create:!0});return t}async save(e,n){let s=e.split("/"),t=s.pop(),r=s.join("/"),a=await(r?await this.getDir(r):await this.getRoot()).getFileHandle(t,{create:!0});if(a.createSyncAccessHandle)try{let i=await a.createSyncAccessHandle();return i.truncate(0),i.write(n,{at:0}),i.flush(),i.close(),{path:e,size:n.byteLength}}catch{}let c=await a.createWritable();return await c.write(n),await c.close(),{path:e,size:n.byteLength}}async load(e){try{let n=e.split("/"),s=n.pop(),t=n.join("/"),c=await(await(await(t?await this.getDir(t):await this.getRoot()).getFileHandle(s)).getFile()).arrayBuffer();return new Uint8Array(c)}catch(n){if(n.name==="NotFoundError")return null;throw n}}async delete(e){try{let n=e.split("/"),s=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(s),!0}catch(n){if(n.name==="NotFoundError")return!1;throw n}}async list(e=""){try{let n=e?await this.getDir(e):await this.getRoot(),s=[];for await(let[t,r]of n.entries())s.push({name:t,type:r.kind});return s}catch{return[]}}async exists(e){try{let n=e.split("/"),s=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).getFileHandle(s),!0}catch{return!1}}async deleteDir(e){try{let n=e.split("/"),s=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(s,{recursive:!0}),!0}catch{return!1}}},x=new ue;var D=new TextEncoder,P=new TextDecoder,xe={INT64:"int64",INT32:"int32",FLOAT64:"float64",FLOAT32:"float32",STRING:"string",BOOL:"bool",VECTOR:"vector"},Le=1,ve=2,Ce=3,Ee=4,he=5,de=6;function Ie(h){switch(h){case"int32":case"integer":return Int32Array;case"int64":return BigInt64Array;case"float32":case"real":return Float32Array;case"float64":case"double":return Float64Array;default:return null}}function Ne(h){switch(h){case"int32":case"integer":return Le;case"int64":return ve;case"float32":case"real":return Ce;case"float64":case"double":return Ee;case"string":case"text":return he;case"bool":case"boolean":return de;default:return he}}var re=class{constructor(e){this.schema=e,this.columns=new Map,this.rowCount=0,this._useBinary=!0}addRows(e){if(e.length!==0){if(this.rowCount===0)for(let n of this.schema){let s=Ie(n.dataType);s?this.columns.set(n.name,{type:"typed",dataType:n.dataType,data:new s(Math.max(e.length,1024)),length:0}):this.columns.set(n.name,{type:"array",dataType:n.dataType,data:[],length:0})}for(let n of this.schema){let s=this.columns.get(n.name);if(s.type==="typed"){let t=s.length+e.length;if(t>s.data.length){let r=Math.max(t,s.data.length*2),o=new s.data.constructor(r);o.set(s.data),s.data=o}for(let r=0;r<e.length;r++){let o=e[r][n.name];s.data[s.length+r]=o??0}s.length+=e.length}else{for(let t=0;t<e.length;t++)s.data.push(e[t][n.name]??null);s.length+=e.length}}this.rowCount+=e.length}}buildBinary(){let e=[],n=16,s=[];for(let c of this.schema){let i=this.columns.get(c.name),l=D.encode(c.name),f=Ne(c.dataType),u;if(i.type==="typed"){let d=i.data.subarray(0,i.length);u=new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}else u=D.encode(JSON.stringify(i.data));s.push({nameBytes:l,typeCode:f,dataBytes:u,dataType:c.dataType});let g=(8-(n+4+l.length+1+4)%8)%8;n+=4+l.length+1+g+4+u.length}let t=new ArrayBuffer(n),r=new DataView(t),o=new Uint8Array(t),a=0;r.setUint32(a,1279348291,!1),a+=4,r.setUint32(a,2,!1),a+=4,r.setUint32(a,this.schema.length,!1),a+=4,r.setUint32(a,this.rowCount,!1),a+=4;for(let c of s){r.setUint32(a,c.nameBytes.length,!1),a+=4,o.set(c.nameBytes,a),a+=c.nameBytes.length,r.setUint8(a,c.typeCode),a+=1;let i=(8-(a+4)%8)%8;for(let l=0;l<i;l++)r.setUint8(a+l,0);a+=i,r.setUint32(a,c.dataBytes.length,!1),a+=4,o.set(c.dataBytes,a),a+=c.dataBytes.length}return new Uint8Array(t)}setColumnarData(e){let n=Object.keys(e)[0];this.rowCount=e[n]?.length||0;for(let s of this.schema){let t=e[s.name];if(!t)continue;let r=Ie(s.dataType);if(r&&ArrayBuffer.isView(t))this.columns.set(s.name,{type:"typed",dataType:s.dataType,data:t,length:t.length});else if(r){let o=new r(t.length);for(let a=0;a<t.length;a++)o[a]=t[a]??0;this.columns.set(s.name,{type:"typed",dataType:s.dataType,data:o,length:t.length})}else this.columns.set(s.name,{type:"array",dataType:s.dataType,data:Array.isArray(t)?t:Array.from(t),length:t.length})}}build(){if(this._useBinary&&this.rowCount>0)try{return this.buildBinary()}catch(n){console.warn("[LanceFileWriter] Binary build failed, falling back to JSON:",n)}let e={format:"json",schema:this.schema,columns:{},rowCount:this.rowCount};for(let[n,s]of this.columns)s.type==="typed"?e.columns[n]=Array.from(s.data.subarray(0,s.length)):e.columns[n]=s.data;return D.encode(JSON.stringify(e))}};function Z(h){let e=new DataView(h.buffer||h),n=new Uint8Array(h.buffer||h),s=0;if(e.getUint32(s,!1)!==1279348291)return null;s+=4;let r=e.getUint32(s,!1);s+=4;let o=e.getUint32(s,!1);s+=4;let a=e.getUint32(s,!1);s+=4;let c=[],i={};for(let l=0;l<o;l++){let f=e.getUint32(s,!1);s+=4;let u=P.decode(n.subarray(s,s+f));s+=f;let m=e.getUint8(s);s+=1;let g=(8-(s+4)%8)%8;s+=g;let d=e.getUint32(s,!1);s+=4;let y=n.subarray(s,s+d);s+=d;let w,b;try{switch(m){case Le:b="int32",y.byteOffset%4!==0?w=new Int32Array(y.slice().buffer):w=new Int32Array(y.buffer,y.byteOffset,y.byteLength/4);break;case Ce:b="float32",y.byteOffset%4!==0?w=new Float32Array(y.slice().buffer):w=new Float32Array(y.buffer,y.byteOffset,y.byteLength/4);break;case Ee:b="float64",y.byteOffset%8!==0?w=new Float64Array(y.slice().buffer):w=new Float64Array(y.buffer,y.byteOffset,y.byteLength/8);break;case ve:b="int64",y.byteOffset%8!==0?w=new BigInt64Array(y.slice().buffer):w=new BigInt64Array(y.buffer,y.byteOffset,y.byteLength/8);break;case he:case de:default:b=m===de?"bool":"string",w=JSON.parse(P.decode(y));break}}catch(p){throw console.error(`[LanceQLWorker] Error parsing column '${u}' (type ${m}, len ${d}):`,p),p}c.push({name:u,dataType:b}),i[u]=w}return{schema:c,columns:i,rowCount:a,format:"binary"}}var Q=class{constructor(e=512*1024*1024){this.maxBytes=e,this.currentBytes=0,this.cache=new Map,this.head=null,this.tail=null}get(e){let n=this.cache.get(e);if(n)return this._moveToHead(n),n.value}set(e,n,s=0){let t=this.cache.get(e);if(t)this.currentBytes-=t.size,this.currentBytes+=s,t.value=n,t.size=s,this._moveToHead(t);else{let r={key:e,value:n,size:s,prev:null,next:null};this.cache.set(e,r),this._addToHead(r),this.currentBytes+=s}this._evictIfNeeded()}has(e){return this.cache.has(e)}delete(e){let n=this.cache.get(e);n&&(this._removeNode(n),this.cache.delete(e),this.currentBytes-=n.size)}clear(){this.cache.clear(),this.head=null,this.tail=null,this.currentBytes=0}_moveToHead(e){e!==this.head&&(this._removeNode(e),this._addToHead(e))}_addToHead(e){e.next=this.head,e.prev=null,this.head&&(this.head.prev=e),this.head=e,this.tail||(this.tail=e)}_removeNode(e){e.prev?e.prev.next=e.next:this.head=e.next,e.next?e.next.prev=e.prev:this.tail=e.prev}_evictIfNeeded(){for(;this.currentBytes>this.maxBytes&&this.tail;){let e=this.tail;this._removeNode(e),this.cache.delete(e.key),this.currentBytes-=e.size}}static estimateSize(e){return e?e.byteLength?e.byteLength:Array.isArray(e)?e.length*100:e.buffer&&e.buffer.byteLength?e.buffer.byteLength:1e3:0}};var we=new Map,Pe=1,z=class{constructor(e,n){this.name=e,this.tables=new Map,this.version=0,this.manifestKey=`${e}/__manifest__`,this.bufferPool=n||new Q,this._writeBuffer=new Map,this._flushTimer=null,this._flushInterval=2e3,this._flushThreshold=1e4,this._columnarBuffer=new Map,this._flushing=!1,this._readCache=new Map,this._columnarCache=new Map}async open(){let e=await x.load(this.manifestKey);if(e){let n=JSON.parse(P.decode(e));this.version=n.version||0,this.tables=new Map(Object.entries(n.tables||{}));for(let[s,t]of this.tables)await this._getLatestVersion(s)===0&&t.fragments?.length>0&&await this._createVersion(s,"MIGRATE")}return this}async _saveManifest(){this.version++;let e={version:this.version,timestamp:Date.now(),tables:Object.fromEntries(this.tables)},n=D.encode(JSON.stringify(e));await x.save(this.manifestKey,n)}async _getLatestVersion(e){let n=`${this.name}/${e}/_latest`;try{let s=await x.load(n);return s?parseInt(P.decode(s),10):0}catch{return 0}}async _setLatestVersion(e,n){let s=`${this.name}/${e}/_latest`;await x.save(s,D.encode(String(n)))}async _loadTableVersion(e,n){let s=`${this.name}/${e}/_versions/${n}.manifest`,t=await x.load(s);if(!t)throw new Error(`Version ${n} not found for table '${e}'`);return JSON.parse(P.decode(t))}async _saveTableVersion(e,n){let s=`${this.name}/${e}/_versions/${n.version}.manifest`;await x.save(s,D.encode(JSON.stringify(n)))}async _createVersion(e,n){let s=this.tables.get(e);if(!s)return 0;let t=await this._getLatestVersion(e),r=t+1,o={version:r,timestamp:Date.now(),parentVersion:t,operation:n,schema:s.schema,fragments:[...s.fragments],deletionVector:[...s.deletionVector],rowCount:s.rowCount,nextRowId:s.nextRowId};return await this._saveTableVersion(e,o),await this._setLatestVersion(e,r),r}async listVersions(e){let n=await this._getLatestVersion(e),s=[];for(let t=1;t<=n;t++)try{let r=await this._loadTableVersion(e,t);s.push({version:r.version,timestamp:r.timestamp,operation:r.operation,rowCount:r.rowCount})}catch{}return s}async selectAtVersion(e,n,s={}){let t=await this._loadTableVersion(e,n),r=new Set(t.deletionVector),o=this.tables.get(e),a=[];for(let l of t.fragments){let f=await x.load(l);if(f){let u=this._parseFragment(f,t.schema);for(let m of u)r.has(m.__rowId)||a.push(m)}}let c=a;if(s.where&&(c=c.filter(s.where)),s.orderBy){let{column:l,desc:f}=s.orderBy;c.sort((u,m)=>{let g=u[l]<m[l]?-1:u[l]>m[l]?1:0;return f?-g:g})}s.offset&&(c=c.slice(s.offset)),s.limit&&(c=c.slice(0,s.limit));let i=s.columns&&s.columns.length>0&&s.columns[0]!=="*"?s.columns:null;return c.map(l=>{if(i){let f={};for(let u of i)f[u]=l[u];return f}else{let{__rowId:f,...u}=l;return u}})}async restoreToVersion(e,n){let s=await this._loadTableVersion(e,n),t=await this._getLatestVersion(e),r=t+1,o={...s,version:r,timestamp:Date.now(),parentVersion:t,operation:`RESTORE_FROM_${n}`};await this._saveTableVersion(e,o),await this._setLatestVersion(e,r);let a=this.tables.get(e);return a&&(a.fragments=[...s.fragments],a.deletionVector=[...s.deletionVector],a.rowCount=s.rowCount,a.nextRowId=s.nextRowId,this._columnarBuffer.delete(e),this._writeBuffer.delete(e),await this._saveManifest()),{restored:!0,newVersion:r}}async createTable(e,n,s=!1){if(this.tables.has(e)){if(s)return{success:!0,existed:!0};throw new Error(`Table '${e}' already exists`)}let t=n.map(o=>({name:o.name,type:xe[(o.dataType||o.type)?.toUpperCase()]||o.dataType||o.type||"string",primaryKey:o.primaryKey||!1,vectorDim:o.vectorDim||null})),r={name:e,schema:t,fragments:[],deletionVector:[],rowCount:0,nextRowId:0,version:0,createdAt:Date.now()};return this.tables.set(e,r),await this._saveManifest(),await this._createVersion(e,"CREATE"),{success:!0,table:e}}async dropTable(e,n=!1){if(!this.tables.has(e)){if(n)return this._writeBuffer.delete(e),{success:!0,existed:!1};throw new Error(`Table '${e}' does not exist`)}let s=this.tables.get(e);this._writeBuffer.delete(e);for(let t of s.fragments)this._readCache.delete(t),await x.delete(t);return this.tables.delete(e),await this._saveManifest(),{success:!0,table:e}}async insert(e,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=this.tables.get(e),t=n.length;if(!this._columnarBuffer.has(e)){let c=Math.max(1024,t*2),i={__rowId:new Float64Array(c),__length:0,__capacity:c,__schema:s.schema};for(let l of s.schema){let f=(l.dataType||l.type||"").toLowerCase();f==="text"||f==="string"||f==="varchar"?i[l.name]=new Array(c):f==="int64"||f==="bigint"?i[l.name]=new BigInt64Array(c):i[l.name]=new Float64Array(c)}this._columnarBuffer.set(e,i)}let r=this._columnarBuffer.get(e),o=r.__length,a=r.__capacity;if(o+t>a){let c=Math.max(a*2,o+t),i=new Float64Array(c);i.set(r.__rowId.subarray(0,o)),r.__rowId=i;for(let l of s.schema){let f=r[l.name];if(f instanceof Float64Array){let u=new Float64Array(c);u.set(f.subarray(0,o)),r[l.name]=u}else if(f instanceof BigInt64Array){let u=new BigInt64Array(c);u.set(f.subarray(0,o)),r[l.name]=u}else r[l.name].length=c}r.__capacity=c}for(let c=0;c<t;c++){let i=n[c];r.__rowId[o+c]=s.nextRowId++;for(let l of s.schema){let f=i[l.name];r[l.name]instanceof Float64Array?r[l.name][o+c]=f!=null?Number(f):NaN:r[l.name]instanceof BigInt64Array?r[l.name][o+c]=f!=null?BigInt(f):0n:r[l.name][o+c]=f??null}}return r.__length=o+t,s.rowCount+=t,s.version=(s.version||0)+1,this._scheduleFlush(),r.__length>=this._flushThreshold&&await this._flushTable(e),{success:!0,inserted:t}}_scheduleFlush(){this._flushTimer||(this._flushTimer=setTimeout(()=>{this._flushTimer=null,this.flush().catch(e=>console.warn("[WorkerDatabase] Flush error:",e))},this._flushInterval))}async flush(){if(!this._flushing){this._flushing=!0;try{let e=[...this._columnarBuffer.keys()];for(let n of e)await this._flushTable(n)}finally{this._flushing=!1}}}async _flushTable(e){let n=this._columnarBuffer.get(e),s=n?.__length||0;if(!n||s===0)return;let t=this.tables.get(e);if(!t)return;let r=[{name:"__rowId",type:"int64",dataType:"float64",primaryKey:!0},...t.schema.filter(l=>l.name!=="__rowId").map(l=>{let f=(l.dataType||l.type||"").toLowerCase();return f==="int64"||f==="bigint"?{...l,dataType:"int64"}:{...l,dataType:f==="float64"||f==="float32"||f==="int32"||f==="integer"||f==="real"||f==="double"?"float64":l.dataType||l.type||"float64"}})],o={};for(let l of r){let f=n[l.name];f&&(f instanceof Float64Array||f instanceof BigInt64Array?o[l.name]=f.subarray(0,s):o[l.name]=f.slice(0,s))}n.__length=0;let a=new re(r);a.setColumnarData(o);let c=a.build(),i=`${this.name}/${e}/frag_${Date.now()}_${Math.random().toString(36).slice(2)}.lance`;await x.save(i,c),t.fragments.push(i),await this._saveManifest(),await this._createVersion(e,"INSERT")}async delete(e,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=this.tables.get(e),t=0,r=this._columnarBuffer.get(e),o=r?.__length||0;if(r&&o>0){let a=s.schema.map(c=>c.name);for(let c=0;c<o;c++){let i={__rowId:r.__rowId[c]};for(let l of a){let f=r[l][c];i[l]=Number.isNaN(f)?null:f}n(i)&&(s.deletionVector.includes(r.__rowId[c])||(s.deletionVector.push(r.__rowId[c]),t++))}}for(let a of s.fragments){let c=await x.load(a);if(c){let i=this._parseFragment(c,s.schema);for(let l of i)!s.deletionVector.includes(l.__rowId)&&n(l)&&(s.deletionVector.push(l.__rowId),t++)}}return s.rowCount-=t,s.version=(s.version||0)+1,await this._saveManifest(),t>0&&await this._createVersion(e,"DELETE"),{success:!0,deleted:t}}async update(e,n,s){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let t=this.tables.get(e),r=0,o=this._writeBuffer.get(e);if(o&&o.length>0)for(let c of o)s(c)&&(Object.assign(c,n),r++);let a=[];for(let c of t.fragments){let i=await x.load(c);if(i){let l=this._parseFragment(i,t.schema);for(let f of l)if(!t.deletionVector.includes(f.__rowId)&&s(f)){t.deletionVector.push(f.__rowId),t.rowCount--;let u={...f,...n};delete u.__rowId,a.push(u),r++}}}return a.length>0?await this.insert(e,a):await this._saveManifest(),r>0&&a.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:r}}async updateWithExpr(e,n,s,t){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=this.tables.get(e),o=0,a=this._columnarBuffer.get(e),c=a?.__length||0;if(a&&c>0){let l=r.schema.map(f=>f.name);for(let f=0;f<c;f++){let u={__rowId:a.__rowId[f]};for(let m of l){let g=a[m][f];u[m]=Number.isNaN(g)?null:g}if(s(u)){for(let[m,g]of Object.entries(n)){let d=t(g,u);a[m]!==void 0&&(a[m][f]=d??(a[m]instanceof Float64Array?NaN:null))}r.version=(r.version||0)+1,o++}}}let i=[];for(let l of r.fragments){let f=await x.load(l);if(f){let u=this._parseFragment(f,r.schema);for(let m of u)if(!r.deletionVector.includes(m.__rowId)&&s(m)){r.deletionVector.push(m.__rowId),r.rowCount--;let g={...m};for(let[d,y]of Object.entries(n))g[d]=t(y,m);delete g.__rowId,i.push(g),o++}}}return i.length>0?await this.insert(e,i):await this._saveManifest(),o>0&&i.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:o}}async select(e,n={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=await this._readAllRows(e);if(n.where&&(s=s.filter(n.where)),n.orderBy){let{column:o,desc:a}=n.orderBy;s.sort((c,i)=>{let l=c[o]<i[o]?-1:c[o]>i[o]?1:0;return a?-l:l})}n.offset&&(s=s.slice(n.offset)),n.limit&&(s=s.slice(0,n.limit));let t=n.columns&&n.columns.length>0&&n.columns[0]!=="*"?n.columns:null,r=new Array(s.length);for(let o=0;o<s.length;o++){let a=s[o];if(t){let c={};for(let i of t)c[i]=a[i];r[o]=c}else{let{__rowId:c,...i}=a;r[o]=i}}return r}async _readAllRows(e){let n=this.tables.get(e),s=this._columnarBuffer.get(e),r=n.deletionVector.length>0?new Set(n.deletionVector):null,o=[];for(let c of n.fragments){let i=this.bufferPool.get(c),l=null;if(!i){let f=await x.load(c);f&&(i=Z(f),i?this.bufferPool.set(c,i,f.byteLength):l=this._parseFragment(f,n.schema))}if(i&&!l&&(l=this._hydrateRowsFromBinary(i,n.schema)),l=l||[],!r)o.push(...l);else for(let f of l)r.has(f.__rowId)||o.push(f)}let a=s?.__length||0;if(s&&a>0){let c=n.schema.map(i=>i.name);for(let i=0;i<a;i++){if(r&&r.has(s.__rowId[i]))continue;let l={__rowId:s.__rowId[i]};for(let f of c){let u=s[f][i];l[f]=Number.isNaN(u)?null:u}o.push(l)}}return o}_hydrateRowsFromBinary(e,n){let{columns:s,rowCount:t}=e,r=n.map(a=>a.name),o=new Array(t);for(let a=0;a<t;a++){let c={__rowId:s.__rowId[a]};for(let i of r)s[i]&&(c[i]=s[i][a]);o[a]=c}return o}_parseFragment(e,n){try{let s=Z(e);if(s)return this._parseBinaryColumnar(s);let t=P.decode(e),r=JSON.parse(t);return r.format==="json"&&r.columns?this._parseJsonColumnar(r):Array.isArray(r)?r:[r]}catch(s){return console.warn("[WorkerDatabase] Failed to parse fragment:",s),[]}}async selectColumnar(e){let n=this.tables.get(e);if(!n)return null;let s=this._columnarBuffer.get(e)?.__length||0,t=`${n.fragments.length}:${s}:${n.deletionVector.length}:${n.version||0}`,r=this._columnarCache.get(e);if(r&&r.version===t){let d={};for(let[y,w]of Object.entries(r.data.columns))ArrayBuffer.isView(w)?d[y]=new w.constructor(w.buffer,w.byteOffset,w.length):d[y]=w;return{schema:n.schema,columns:d,rowCount:r.data.rowCount}}let a=n.deletionVector.length>0?new Set(n.deletionVector):null,c={},i=n.schema.map(d=>d.name);for(let d of i)c[d]=[];c.__rowId=[];for(let d of n.fragments){let y=this.bufferPool.get(d);if(!y){let p=await x.load(d);if(!p)continue;y=Z(p),y&&this.bufferPool.set(d,y,p.byteLength)}if(!y)continue;let{columns:w,rowCount:b}=y;if(a){let p=w.__rowId,_=[];for(let A=0;A<b;A++)a.has(p[A])||_.push(A);for(let A of i)if(w[A]){let B=w[A],T=new B.constructor(_.length);for(let E=0;E<_.length;E++)T[E]=B[_[E]];c[A].push(T)}}else{for(let p of i)w[p]&&c[p].push(w[p]);w.__rowId&&c.__rowId.push(w.__rowId)}}let l=this._columnarBuffer.get(e),f=l?.__length||0;if(l&&f>0)if(a){let d=[];for(let b=0;b<f;b++)a.has(l.__rowId[b])||d.push(b);let y=d.length;for(let b of n.schema){let p=l[b.name];if(p)if(p instanceof Float64Array){let _=new Float64Array(y);for(let A=0;A<y;A++)_[A]=p[d[A]];c[b.name].push(_)}else c[b.name].push(d.map(_=>p[_]))}let w=new Float64Array(y);for(let b=0;b<y;b++)w[b]=l.__rowId[d[b]];c.__rowId.push(w)}else{for(let y of n.schema){let w=l[y.name];if(w)if(w instanceof Float64Array){let b=new Float64Array(f);b.set(w.subarray(0,f)),c[y.name].push(b)}else c[y.name].push(w.slice(0,f))}let d=new Float64Array(f);d.set(l.__rowId.subarray(0,f)),c.__rowId.push(d)}let u={},m=0;for(let d of[...i,"__rowId"]){let y=c[d];if(y.length===0)u[d]=new Float64Array(0);else if(y.length===1)u[d]=y[0],m===0&&(m=y[0].length);else{let w=y.reduce((A,B)=>A+B.length,0);m===0&&(m=w);let b=y[0],p=ArrayBuffer.isView(b)?new b.constructor(w):new Array(w),_=0;for(let A of y){if(ArrayBuffer.isView(p))p.set(A,_);else for(let B=0;B<A.length;B++)p[_+B]=A[B];_+=A.length}u[d]=p}}let g={schema:n.schema,columns:u,rowCount:m};return this._columnarCache.set(e,{version:t,data:g}),g}async _readColumn(e,n){let s=this.tables.get(e);if(!s)return null;let t=this._writeBuffer.get(e),r=[];for(let i of s.fragments){let l=await x.load(i);if(!l)continue;let f=Z(l);if(f&&f.columns[n]){let u=f.columns[n];u.length>0&&r.push(u)}}if(t&&t.length>0){let i=new Float64Array(t.length);for(let l=0;l<t.length;l++){let f=t[l][n];i[l]=typeof f=="number"?f:0}r.push(i)}if(r.length===0)return new Float64Array(0);if(r.length===1)return r[0];let o=r.reduce((i,l)=>i+l.length,0),a=new Float64Array(o),c=0;for(let i of r)a.set(i,c),c+=i.length;return a}_parseBinaryColumnar(e){let{schema:n,columns:s,rowCount:t}=e,r=new Array(t),o=n.map(i=>i.name),a=o.map(i=>s[i]),c=o.length;for(let i=0;i<t;i++){let l={};for(let f=0;f<c;f++)l[o[f]]=a[f][i]??null;r[i]=l}return r}_parseJsonColumnar(e){let{schema:n,columns:s,rowCount:t}=e,r=new Array(t),o=n.map(i=>i.name),a=o.map(i=>s[i]||[]),c=o.length;for(let i=0;i<t;i++){let l={};for(let f=0;f<c;f++)l[o[f]]=a[f][i]??null;r[i]=l}return r}getTable(e){return this.tables.get(e)}listTables(){return Array.from(this.tables.keys())}getFragmentPaths(e){let n=this.tables.get(e);return n?n.fragments:[]}getColumnIndex(e,n){let s=this.tables.get(e);if(!s)return-1;let t=s.schema.findIndex(r=>r.name===n);return t>=0?t+1:-1}hasBufferedData(e){let n=this._columnarBuffer.get(e);return n&&(n.__length||0)>0}async compact(){for(let[e,n]of this.tables){let s=await this._readAllRows(e);for(let t of n.fragments)await x.delete(t);if(n.fragments=[],n.deletionVector=[],n.rowCount=0,n.nextRowId=0,s.length>0){let t=s.map(({__rowId:r,...o})=>o);await this.insert(e,t)}}return{success:!0,compacted:this.tables.size}}async scanStart(e,n={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=Pe++,t=this.tables.get(e),r=new Set(t.deletionVector),o=[];for(let c of t.fragments){let i=await x.load(c);if(i){let l=this._parseFragment(i,t.schema);for(let f of l)r.has(f.__rowId)||o.push(f)}}let a=this._writeBuffer.get(e);if(a)for(let c of a)r.has(c.__rowId)||o.push(c);return we.set(s,{rows:o,index:0,batchSize:n.batchSize||1e4,columns:n.columns}),s}scanNext(e){let n=we.get(e);if(!n)return{batch:[],done:!0};let s=[],t=Math.min(n.index+n.batchSize,n.rows.length);for(let o=n.index;o<t;o++){let a=n.rows[o],c;if(n.columns&&n.columns.length>0&&n.columns[0]!=="*"){c={};for(let i of n.columns)c[i]=a[i]}else{let{__rowId:i,...l}=a;c=l}s.push(c)}n.index=t;let r=n.index>=n.rows.length;return r&&we.delete(e),{batch:s,done:r}}};var oe=class{constructor(){this._root=null,this._ready=!1,this._kv={},this._encryptionKeyId=null,this._db=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:n,keyBytes:s}=e;if(!W.has(n)){let t=await ee(s);W.set(n,t)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle("vault",{create:!0}),await this._loadKV(),this._db=new z("vault"),await this._db.open(),this._ready=!0}catch(n){throw console.error("[WorkerVault] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?W.get(this._encryptionKeyId):null}async _loadKV(){try{let e=this._getCryptoKey(),n=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(n)).getFile();if(e){let r=await t.arrayBuffer();this._kv=await ne(new Uint8Array(r),e)}else{let r=await t.text();this._kv=JSON.parse(r)}}catch(e){if(e.name==="NotFoundError")this._kv={};else throw e}}async _saveKV(){let e=this._getCryptoKey(),n=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(n,{create:!0})).createWritable();if(e){let r=await te(this._kv,e);await t.write(r)}else await t.write(JSON.stringify(this._kv));await t.close()}async get(e){return this._kv[e]}async set(e,n){this._kv[e]=n,await this._saveKV()}async delete(e){delete this._kv[e],await this._saveKV()}async keys(){return Object.keys(this._kv)}async has(e){return e in this._kv}};var Ke=1;var Fe={INT64:0,FLOAT64:1,INT32:2,FLOAT32:3,STRING:4,LIST:5},me=class{constructor(){this._registered=new Map}getLastError(){let e=k();if(!e)return"WASM not loaded";let n=M(),s=e.alloc(4096);console.log(`[WASM LOG] getLastError alloc ptr: ${s}`);let t=e.getLastError(s,4096);if(console.log(`[WASM LOG] getLastError len: ${t}`),t===0)return"Unknown Error";let r=new Uint8Array(n.buffer,s,t),o=new TextDecoder().decode(r);return console.log(`[WASM LOG] getLastError msg: ${o}`),o}getTableNames(e){let n=k();if(!n)throw new Error("WASM not loaded");let s=M(),t=new TextEncoder().encode(e),r=n.alloc(t.length);new Uint8Array(s.buffer,r,t.length).set(t);let o=n.getTableNames(r,t.length);if(o===0)return[];let a=new Uint8Array(s.buffer,o),c=0;for(;a[c]!==0&&c<1024;)c++;let i=new TextDecoder().decode(a.subarray(0,c));return i?i.split(",").filter(l=>l):[]}hasTable(e){let n=k();if(!n)return!1;let s=M(),t=new TextEncoder().encode(e),r=n.alloc(t.length);return new Uint8Array(s.buffer,r,t.length).set(t),n.hasTable(r,t.length)===1}registerTable(e,n,s,t=""){let r=k();if(!r)throw new Error("WASM not loaded");let o=this._registered.get(e);if(o&&o.version===t)return;if(o){let f=new TextEncoder().encode(e);r.clearTable(f,f.length)}let a=M(),c=new TextEncoder().encode(e),i=r.alloc(c.length);new Uint8Array(a.buffer,i,c.length).set(c);let l=new Set;for(let[f,u]of Object.entries(n)){if(f.startsWith("__"))continue;let m=new TextEncoder().encode(f),g=r.alloc(m.length);if(new Uint8Array(a.buffer,g,m.length).set(m),u instanceof Float64Array){let d=r.allocFloat64Buffer(u.length);new Float64Array(a.buffer,d,u.length).set(u),r.registerTableFloat64(i,c.length,g,m.length,d,u.length),l.add(f)}else if(u instanceof BigInt64Array){let d=r.allocInt64Buffer(u.length);new BigInt64Array(a.buffer,d,u.length).set(u),r.registerTableInt64(i,c.length,g,m.length,d,u.length),l.add(f)}else if(u instanceof Int32Array){let d=new Float64Array(u.length);for(let w=0;w<u.length;w++)d[w]=u[w];let y=r.allocFloat64Buffer(d.length);new Float64Array(a.buffer,y,d.length).set(d),r.registerTableFloat64(i,c.length,g,m.length,y,d.length),l.add(f)}else if(Array.isArray(u)){let d=new Uint32Array(u.length),y=new Uint32Array(u.length),w=0;for(let T=0;T<u.length;T++){let E=String(u[T]||"");y[T]=E.length,d[T]=w,w+=E.length}let b=new Uint8Array(w),p=0;for(let T=0;T<u.length;T++){let E=String(u[T]||""),R=new TextEncoder().encode(E);b.set(R,p),p+=R.length}let _=r.alloc(d.byteLength);new Uint32Array(a.buffer,_,d.length).set(d);let A=r.alloc(y.byteLength);new Uint32Array(a.buffer,A,y.length).set(y);let B=r.alloc(b.length);new Uint8Array(a.buffer,B,b.length).set(b),r.registerTableString(i,c.length,g,m.length,_,A,B,w,u.length),l.add(f)}}this._registered.set(e,{version:t,columns:l,rowCount:s})}registerTableFromFiles(e,n,s=""){let t=k();if(!t)throw new Error("WASM not loaded");let r=this._registered.get(e);if(r&&r.version===s)return;if(r){let i=new TextEncoder().encode(e);t.clearTable(i,i.length)}let o=new TextEncoder,a=o.encode(e),c=t.alloc(a.length);new Uint8Array(M().buffer,c,a.length).set(a);for(let i of n){let l=o.encode(i),f=t.alloc(l.length);new Uint8Array(M().buffer,f,l.length).set(l);let u=t.registerTableFromOPFS(c,a.length,f,l.length);u!==0&&console.warn(`Failed to register fragment ${i} for table ${e}: error ${u}`)}this._registered.set(e,{version:s,type:"files"})}appendTableMemory(e,n,s){let t=k();if(!t)throw new Error("WASM not loaded");let r=M(),o=new TextEncoder().encode(e),a=t.alloc(o.length);new Uint8Array(r.buffer,a,o.length).set(o);for(let[c,i]of Object.entries(n)){if(c.startsWith("__"))continue;let l=new TextEncoder().encode(c),f=t.alloc(l.length);if(new Uint8Array(r.buffer,f,l.length).set(l),i instanceof Float64Array){let u=t.allocFloat64Buffer(i.length);new Float64Array(r.buffer,u,i.length).set(i),t.appendTableMemory(a,o.length,f,l.length,u,4,s)}else if(i instanceof BigInt64Array){let u=t.allocInt64Buffer(i.length);new BigInt64Array(r.buffer,u,i.length).set(i),t.appendTableMemory(a,o.length,f,l.length,u,2,s)}else if(i instanceof Int32Array){let u=t.alloc(i.byteLength);new Int32Array(r.buffer,u,i.length).set(i),t.appendTableMemory(a,o.length,f,l.length,u,1,s)}else if(i instanceof Float32Array){let u=t.alloc(i.byteLength);new Float32Array(r.buffer,u,i.length).set(i),t.appendTableMemory(a,o.length,f,l.length,u,3,s)}}}execute(e){let n=k();if(!n)throw new Error("WASM not loaded");let s=M();if(n.setCurrentTimestamp)try{n.setCurrentTimestamp(BigInt(Date.now()))}catch(u){console.warn("setCurrentTimestamp failed:",u)}let t=n.getSqlInputBuffer(),r=n.getSqlInputBufferSize(),o=new TextEncoder().encode(e);if(o.length>r)throw new Error(`SQL too long: ${o.length} > ${r}`);new Uint8Array(s.buffer,t,o.length).set(o),n.setSqlInputLength(o.length);let a=n.executeSql();if(a===0){let u=this.getLastError();throw console.log(`[WASM LOG] execute throwing: "${u}"`),new Error(u)}let c=n.getResultSize(),i=this.getLastError();i&&i.length>0&&console.log(`[WASM DEBUG CAPTURED] ${i}`),i.length>0&&i.startsWith("DEBUG:");let l=n.memory.buffer,f=this._parseResult(s.buffer,a,c);return n.resetResult(),f}_parseResult(e,n,s){let t=new DataView(e,n,s),r=new TextDecoder;if(s>=40){let o=s-40,a=[t.getUint8(o+36),t.getUint8(o+37),t.getUint8(o+38),t.getUint8(o+39)];if(String.fromCharCode(...a)==="LANC")return this._parseLanceResult(e,n,s,o,t,r)}if(s>=36&&t.getUint32(0,!0)===Ke)return this._parseLegacyResult(e,n,s);throw new Error(`Invalid result format (Size: ${s}). Not a Lance file.`)}_parseLanceResult(e,n,s,t,r,o){let a=Number(r.getBigUint64(t+8,!0)),c=r.getUint32(t+28,!0),i=[],l={},f=0;for(let u=0;u<c;u++){let m=a+u*8,d=Number(r.getBigUint64(m,!0));r.getUint8(d++);let[y,w]=this._readVarint(r,d);d+=w;let b=new Uint8Array(e,n+d,y),p=o.decode(b);d+=y,i.push(p),r.getUint8(d++);let[_,A]=this._readVarint(r,d);d+=A;let B=new Uint8Array(e,n+d,_),T=o.decode(B);d+=_,r.getUint8(d++);let[E,R]=this._readVarint(r,d);d+=R,r.getUint8(d++);let ce=Number(r.getBigUint64(d,!0));d+=8,r.getUint8(d++);let[I,j]=this._readVarint(r,d);d+=j,f=I,r.getUint8(d++);let[le,Re]=this._readVarint(r,d);d+=Re;let G=n+ce;if(T==="float64"||T==="int64"||T==="int32"||T==="float32")if(T==="float64"){let V=new Float64Array(e,G,I).slice(),C=!1;for(let S=0;S<I;S++)if(Number.isNaN(V[S])){C=!0;break}if(C){console.log(`[WASM LOG] Column ${p} has NaNs, converting to nulls`);let S=new Array(I);for(let L=0;L<I;L++){let N=V[L];S[L]=Number.isNaN(N)?null:N}l[p]=S}else l[p]=V}else if(T==="int64"){let V=new BigInt64Array(e,G,I),C=new Array(I),S=-9223372036854775808n;for(let L=0;L<I;L++){let N=V[L];C[L]=N===S?null:Number(N)}l[p]=C}else if(T==="int32"){let V=new Int32Array(e,G,I),C=new Array(I);for(let S=0;S<I;S++){let L=V[S];L===-2147483648?C[S]=null:C[S]=L}l[p]=C}else{let V=new Float32Array(e,G,I),C=new Array(I);for(let S=0;S<I;S++){let L=V[S];C[S]=isNaN(L)?null:L}l[p]=C}else if(T==="string"||T==="list"){let V=T==="list",C=(I+1)*4,S=le-C,L=new Uint8Array(e,G,S).slice(),N=new Uint32Array(e,G+S,I+1).slice();l[p]={_arrowString:!0,offsets:N,bytes:L,isList:T==="list",nullable:E===1}}}return{_format:"columnar",columns:i,rowCount:f,data:l}}_readVarint(e,n){let s=0,t=0,r=0;for(;;){let o=e.getUint8(n+r);if(r++,s|=(o&127)<<t,(o&128)===0)break;t+=7}return[s,r]}_parseLegacyResult(e,n,s){let t=new DataView(e,n,s),r=new TextDecoder,o=t.getUint32(4,!0),a=Number(t.getBigUint64(8,!0)),c=t.getUint32(24,!0),i=t.getUint32(32,!0),l=[],f={};for(let u=0;u<o;u++){let m=36+u*16,g=t.getUint32(m,!0),d=t.getUint32(m+4,!0),y=t.getUint32(m+8,!0),w=t.getUint32(m+12,!0),b=new Uint8Array(e,n+i+d,y),p=r.decode(b);l.push(p);let _=Object.keys(Fe).find(B=>Fe[B]===g).toLowerCase(),A=n+c+w;if(_==="float64"||_==="int64"||_==="int32"||_==="float32")_==="float64"?f[p]=new Float64Array(e,A,a).slice():_==="int64"?f[p]=new Float64Array(e,A,a).slice():_==="int32"?f[p]=new Int32Array(e,A,a).slice():_==="float32"&&(f[p]=new Float32Array(e,A,a).slice());else if(_==="string"||_==="list"){let B=new Uint32Array(a+1),T=0;B[0]=0;let E=A,R=0;for(let j=0;j<a;j++){let le=t.getUint32(E+j*8+4,!0);R+=le,B[j+1]=R}let ce=A+a*8,I=new Uint8Array(e,ce,R).slice();f[p]={_arrowString:!0,offsets:B,bytes:I,isList:_==="list"}}}return{_format:"columnar",columns:l,rowCount:a,data:f}}clear(){let e=k();e&&e.clearTables(),this._registered.clear()}},ye=null;function ge(){return ye||(ye=new me),ye}var pe={showVersions:/^\s*SHOW\s+VERSIONS\s+FOR\s+(\w+)\s*$/i,restoreTable:/^\s*RESTORE\s+(\w+)\s+TO\s+VERSION\s+(\d+)\s*$/i,versionAsOf:/FROM\s+(\w+)\s+VERSION\s+AS\s+OF\s+(\d+)/i};function Oe(h){let e;return(e=h.match(pe.showVersions))?{type:"SHOW_VERSIONS",table:e[1]}:(e=h.match(pe.restoreTable))?{type:"RESTORE_TABLE",table:e[1],version:parseInt(e[2],10)}:(e=h.match(pe.versionAsOf))?{type:"SELECT_VERSION",table:e[1],version:parseInt(e[2],10),sql:h}:null}async function Ve(h,e){if(!O&&(await X(),!O))throw new Error("WASM not loaded");let n=ge(),s=n.getTableNames(e);for(let t of s){if(n.hasTable(t))continue;let o=h.tables.get(t);if(!o)continue;let a=h._columnarBuffer?.get(t),c=a?.__length||0,i=`${t}:${o.fragments?.length||0}:${c}:${o.deletionVector?.length||0}`,l=o.fragments.length>0,f=c>0;if(l){let u=[];for(let m of o.fragments){let g=await Ge(m);g&&u.push(g)}if(n.registerTableFromFiles(t,o.fragments,i),f){let m={};for(let g of o.schema){let d=a[g.name];d&&ArrayBuffer.isView(d)&&(m[g.name]=d.subarray(0,c))}n.appendTableMemory(t,m,c)}}else if(f){let u=await h.selectColumnar(t);if(u){let{columns:m,rowCount:g}=u;n.registerTable(t,m,g,i)}}}return n.execute(e)}var O=null,H=null,J=new Map,He=1;async function Me(h){let e=await navigator.storage.getDirectory();e=await e.getDirectoryHandle("lanceql",{create:!0});for(let n of h)e=await e.getDirectoryHandle(n,{create:!0});return e}function je(){return{env:{opfs_open:(h,e)=>{try{let n=new Uint8Array(H.buffer,h,e),s=new TextDecoder().decode(n);for(let[t,r]of J.entries())if(r._path===s)return t;return console.warn("[LanceQLWorker] WASM tried to open unregistered path:",s),0}catch(n){return console.error("[LanceQLWorker] Error:",n),0}},opfs_read:(h,e,n,s)=>{let t=J.get(h);if(!t)return 0;try{let r=new Uint8Array(H.buffer,e,n);return t.read(r,{at:Number(s)})}catch{return 0}},opfs_size:h=>{let e=J.get(h);if(!e)return BigInt(0);try{return BigInt(e.getSize())}catch{return BigInt(0)}},opfs_close:h=>{},__assert_fail:(h,e,n,s)=>{let r=new TextDecoder().decode(new Uint8Array(H.buffer,h).subarray(0,100));console.error(`[WASM ASSERT] ${r} at line ${n}`)},js_log:(h,e)=>{let s=new TextDecoder().decode(new Uint8Array(H.buffer,h,e));console.log(`[WASM LOG] ${s}`);for(let t of Be)t.postMessage({type:"log",message:s,marker:"__WASM_LOG_BRIDGE__"})}}}}async function Ge(h){try{let e=h.split("/").filter(a=>a),n=e.pop(),r=await(await(await Me(e)).getFileHandle(n)).createSyncAccessHandle(),o=He++;return r._path=h,J.set(o,r),o}catch(e){return console.warn("[LanceQLWorker] Failed to register OPFS file:",h,e),0}}function Ct(h){let e=J.get(h);if(e){try{e.close()}catch{}J.delete(h)}}async function X(){if(O)return O;try{let h=new URL("./lanceql.wasm",import.meta.url);h.searchParams.set("v",Date.now().toString());let n=await(await fetch(h)).arrayBuffer(),s=je();return O=(await WebAssembly.instantiate(n,s)).instance.exports,H=O.memory,console.log("[LanceQLWorker] WASM loaded with OPFS support"),O}catch(h){return console.warn("[LanceQLWorker] WASM not available:",h.message),null}}function k(){return O}function M(){return H}var be=0,Ue=0,Qe=1024*1024;function ze(h){if(!O)return 0;if(h<=Ue&&be!==0)return be;let e=Math.max(h,Qe),n=O.alloc(e);return n&&(be=n,Ue=e),n}async function Et(h){let e=await X();if(!e)return 0;try{let n=h.split("/").filter(f=>f),s=n.pop(),o=await(await(await Me(n)).getFileHandle(s)).createSyncAccessHandle(),a=o.getSize(),c=ze(a);if(!c)return o.close(),0;let i=new Uint8Array(H.buffer,c,a),l=o.read(i,{at:0});return o.close(),l!==a?0:e.openFile(c,a)}catch(n){return console.warn("[LanceQLWorker] Failed to load fragment:",h,n),0}}async function qe(h,e){let n=e.split("/").filter(t=>t),s=h;for(let t=0;t<n.length-1;t++)s=await s.getDirectoryHandle(n[t],{create:!1});return await s.getFileHandle(n[n.length-1],{create:!1})}var _e=null;async function Je(h){let e=Se.get(h);if(e)return e;_e||(_e=await navigator.storage.getDirectory());let t=await(await(await qe(_e,h)).getFile()).arrayBuffer();return e=new Uint8Array(t),e&&Se.set(h,e,e.byteLength),e}async function Ft(h,e,n){if(!await Je(h))return null;let t=O;switch(n){case"sum":return t.opfsSumFloat64Column(e);case"min":return t.opfsMinFloat64Column(e);case"max":return t.opfsMaxFloat64Column(e);case"avg":return t.opfsAvgFloat64Column(e);case"count":return Number(t.opfsCountRows());default:return null}}X();var Se=new Q,Ae=new Map,Te=new Map,ae=null,Be=new Set,q=null,K=0,Ye=1024,ie=new Map,De=1;async function $(h=null){return ae||(ae=new oe),await ae.open(h),ae}async function F(h,e={},n=null){let s=n?.keyId||"none",t=`${h}:${s}:${JSON.stringify(e)}`;if(!Ae.has(t)){let r=new se(h,e);await r.open(n),Ae.set(t,r)}return Ae.get(t)}async function v(h){if(!Te.has(h)){let e=new z(h,Se);await e.open(),Te.set(h,e)}return Te.get(h)}function Ze(h,e,n){if(n&&n._format==="wasm_binary"){h.postMessage({id:e,result:{_format:"wasm_binary",buffer:n.buffer,columns:n.columns,rowCount:n.rowCount,schema:n.schema}},[n.buffer]);return}if(n&&n._format==="columnar"&&n.data){let s=n.columns,t=n.rowCount;if(t<1e5){let m=[],g={},d=new Set;for(let y of s){let w=n.data[y];if(ArrayBuffer.isView(w)){let b=w.byteOffset!==0||w.byteLength<w.buffer.byteLength,p=d.has(w.buffer);if(b||p){let _=new w.constructor(w);g[y]=_,m.push(_.buffer)}else g[y]=w,m.push(w.buffer),d.add(w.buffer)}else w&&w._arrowString?(g[y]=w,w.offsets&&w.offsets.buffer&&!d.has(w.offsets.buffer)&&(m.push(w.offsets.buffer),d.add(w.offsets.buffer)),w.bytes&&w.bytes.buffer&&!d.has(w.bytes.buffer)&&(m.push(w.bytes.buffer),d.add(w.bytes.buffer))):g[y]=w}h.postMessage({id:e,result:{_format:"columnar",columns:s,rowCount:t,data:g}},m);return}let r=[],o=[],a=0;for(let m of s){let g=n.data[m];ArrayBuffer.isView(g)?(r.push({name:m,arr:g}),a+=g.byteLength):Array.isArray(g)&&o.push({name:m,arr:g})}let c=a>0?new ArrayBuffer(a):null,i={},l=0;if(c){let m=new Uint8Array(c);for(let{name:g,arr:d}of r){let y=new Uint8Array(d.buffer,d.byteOffset,d.byteLength);m.set(y,l),i[g]={offset:l,length:d.length,type:d.constructor.name},l+=d.byteLength}}let f={};for(let{name:m,arr:g}of o)f[m]=g;let u=[];c&&u.push(c),h.postMessage({id:e,result:{_format:"packed",columns:s,rowCount:t,packedBuffer:c,colOffsets:i,stringData:f}},u);return}if(q&&n!==void 0){let s=JSON.stringify(n);if(s.length>Ye){let t=D.encode(s);if(K+t.length<=q.byteLength){new Uint8Array(q,K,t.length).set(t),h.postMessage({id:e,sharedOffset:K,sharedLength:t.length}),K+=t.length,K>q.byteLength/2&&(K=0);return}}}h.postMessage({id:e,result:n})}async function ke(h,e){if(e.type==="initSharedBuffer"){q=e.buffer,K=0,console.log("[LanceQLWorker] SharedArrayBuffer initialized:",q.byteLength,"bytes");return}let{id:n,method:s,args:t}=e;try{let r;if(s==="ping")r="pong";else if(s==="open")await F(t.name,t.options,t.encryption),r=!0;else if(s==="get")r=await(await F(t.name)).get(t.key);else if(s==="set")await(await F(t.name)).set(t.key,t.value),r=!0;else if(s==="delete")await(await F(t.name)).delete(t.key),r=!0;else if(s==="keys")r=await(await F(t.name)).keys();else if(s==="clear")await(await F(t.name)).clear(),r=!0;else if(s==="filter")r=await(await F(t.name)).filter(t.key,t.query);else if(s==="find")r=await(await F(t.name)).find(t.key,t.query);else if(s==="search")r=await(await F(t.name)).search(t.key,t.text,t.limit);else if(s==="count")r=await(await F(t.name)).count(t.key,t.query);else if(s==="enableSemanticSearch")r=await(await F(t.name)).enableSemanticSearch(t.options);else if(s==="disableSemanticSearch")(await F(t.name)).disableSemanticSearch(),r=!0;else if(s==="hasSemanticSearch")r=(await F(t.name)).hasSemanticSearch();else if(s==="db:open")console.log(`[LanceQLWorker] db:open ${t.name}`),await v(t.name),r=!0;else if(s==="db:createTable")console.log(`[LanceQLWorker] db:createTable ${t.tableName}`),r=await(await v(t.db)).createTable(t.tableName,t.columns,t.ifNotExists),console.log(`[LanceQLWorker] db:createTable ${t.tableName} done`);else if(s==="db:dropTable"){console.log(`[LanceQLWorker] db:dropTable ${t.tableName}`),r=await(await v(t.db)).dropTable(t.tableName,t.ifExists);let a=D.encode(t.tableName);ge().clearTable(a,a.length)}else if(s==="db:insert")console.log(`[LanceQLWorker] db:insert into ${t.tableName}, rows: ${t.rows?.length}`),r=await(await v(t.db)).insert(t.tableName,t.rows),console.log("[LanceQLWorker] db:insert done");else if(s==="db:delete"){let o=await v(t.db),a=t.where?c=>evalWhere(t.where,c):()=>!0;r=await o.delete(t.tableName,a)}else if(s==="db:update"){let o=await v(t.db),a=t.where?c=>evalWhere(t.where,c):()=>!0;r=await o.update(t.tableName,t.updates,a)}else if(s==="db:select"){let o=await v(t.db),a={...t.options};t.where&&(a.where=c=>evalWhere(t.where,c)),r=await o.select(t.tableName,a)}else if(s==="db:exec"){let o=await v(t.db),a=Oe(t.sql);if(a?.type==="SHOW_VERSIONS"){let c=await o.listVersions(a.table);r={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:c.length,data:{version:new Float64Array(c.map(i=>i.version)),timestamp:c.map(i=>new Date(i.timestamp).toISOString()),operation:c.map(i=>i.operation),rowCount:new Float64Array(c.map(i=>i.rowCount))}}}else if(a?.type==="RESTORE_TABLE"){let c=await o.restoreToVersion(a.table,a.version);r={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([c.newVersion])}}}else if(a?.type==="SELECT_VERSION"){let c=await o.selectAtVersion(a.table,a.version,{});if(c.length>0){let i=Object.keys(c[0]),l={};for(let f of i)l[f]=c.map(u=>u[f]);r={_format:"columnar",columns:i,rowCount:c.length,data:l}}else r={_format:"columnar",columns:[],rowCount:0,data:{}}}else r=await Ve(o,t.sql);if(r&&r._format==="columnar"&&r.rowCount>=1e5){let c=De++;ie.set(c,r),r={_format:"cursor",cursorId:c,columns:r.columns,rowCount:r.rowCount}}}else if(s==="cursor:fetch"){let o=ie.get(t.cursorId);if(!o)throw new Error("Cursor not found");r=o,ie.delete(t.cursorId)}else if(s==="db:flush")console.log(`[LanceQLWorker] db:flush ${t.db}`),await(await v(t.db)).flush(),console.log(`[LanceQLWorker] db:flush ${t.db} done`),r=!0;else if(s==="db:compact")r=await(await v(t.db)).compact();else if(s==="db:listTables")r=(await v(t.db)).listTables();else if(s==="db:getTable")r=(await v(t.db)).getTable(t.tableName);else if(s==="db:scanStart")r=await(await v(t.db)).scanStart(t.tableName,t.options);else if(s==="db:scanNext")r=(await v(t.db)).scanNext(t.streamId);else if(s==="db:listVersions")r=await(await v(t.db)).listVersions(t.tableName);else if(s==="db:selectAtVersion"){let o=await v(t.db),a={...t.options};t.where&&(a.where=c=>evalWhere(t.where,c)),r=await o.selectAtVersion(t.tableName,t.version,a)}else if(s==="db:restoreTable")r=await(await v(t.db)).restoreToVersion(t.tableName,t.version);else if(s==="vault:open")await $(t.encryption),r=!0;else if(s==="vault:get")r=await(await $()).get(t.key);else if(s==="vault:set")await(await $()).set(t.key,t.value),r=!0;else if(s==="vault:delete")await(await $()).delete(t.key),r=!0;else if(s==="vault:keys")r=await(await $()).keys();else if(s==="vault:has")r=await(await $()).has(t.key);else if(s==="vault:tables"){let o=await $();r=o._db?o._db.listTables():[]}else if(s==="vault:exec"){let a=(await $())._db,c=Oe(t.sql);if(c?.type==="SHOW_VERSIONS"){let i=await a.listVersions(c.table);r={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:i.length,data:{version:new Float64Array(i.map(l=>l.version)),timestamp:i.map(l=>new Date(l.timestamp).toISOString()),operation:i.map(l=>l.operation),rowCount:new Float64Array(i.map(l=>l.rowCount))}}}else if(c?.type==="RESTORE_TABLE"){let i=await a.restoreToVersion(c.table,c.version);r={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([i.newVersion])}}}else if(c?.type==="SELECT_VERSION"){let i=await a.selectAtVersion(c.table,c.version,{});if(i.length>0){let l=Object.keys(i[0]),f={};for(let u of l)f[u]=i.map(m=>m[u]);r={_format:"columnar",columns:l,rowCount:i.length,data:f}}else r={_format:"columnar",columns:[],rowCount:0,data:{}}}else r=await Ve(a,t.sql);if(r&&r._format==="columnar"&&r.rowCount>=1e5){let i=De++;ie.set(i,r),r={_format:"cursor",cursorId:i,columns:r.columns,rowCount:r.rowCount}}}else throw new Error(`Unknown method: ${s}`);Ze(h,n,r)}catch(r){let o=r.stack||r.message;o.includes("TableDoesNotExist")?o="Table does not exist":o.includes("ColumnDoesNotExist")?o="Column does not exist":o.includes("UnknownEmbeddingModel")&&(o="Unknown embedding model"),h.postMessage({id:n,error:o})}}var Xe=typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope;Xe?self.onconnect=h=>{let e=h.ports[0];Be.add(e),e.onmessage=n=>{ke(e,n.data)},e.onmessageerror=n=>{console.error("[LanceQLWorker] Message error:",n)},X().then(()=>{e.postMessage({type:"ready"})}).catch(n=>{console.error("[LanceQLWorker] Failed to load WASM:",n),e.postMessage({type:"ready",error:"WASM load failed"})}),e.start(),console.log("[LanceQLWorker] New connection, total ports:",Be.size)}:(self.onmessage=h=>{ke(self,h.data)},X().then(()=>{self.postMessage({type:"ready"})}).catch(h=>{console.error("[LanceQLWorker] Failed to load WASM:",h),self.postMessage({type:"ready",error:"WASM load failed"})}));console.log("[LanceQLWorker] Initialized");export{Ct as closeOPFSFile,k as getWasm,M as getWasmMemory,Et as loadFragmentToWasm,Ge as registerOPFSFile,Ft as wasmAggregate};
//# sourceMappingURL=lanceql-worker.js.map
