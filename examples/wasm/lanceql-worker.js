var Y=new Map;async function fe(u){return crypto.subtle.importKey("raw",new Uint8Array(u),{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function ue(u,e){let r=crypto.getRandomValues(new Uint8Array(12)),t=new TextEncoder().encode(JSON.stringify(u)),o=await crypto.subtle.encrypt({name:"AES-GCM",iv:r},e,t),c=new Uint8Array(12+o.byteLength);return c.set(r,0),c.set(new Uint8Array(o),12),c}async function he(u,e){let r=u.slice(0,12),n=u.slice(12),t=await crypto.subtle.decrypt({name:"AES-GCM",iv:r},e,n),o=new TextDecoder;return JSON.parse(o.decode(t))}var G=null,ie=null,be=new Map;function rt(u){G=u}function ot(u){ie=u}var de=class{constructor(e,r={}){this.name=e,this.options=r,this._root=null,this._ready=!1,this._embedder=null,this._encryptionKeyId=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:r,keyBytes:n}=e;if(!Y.has(r)){let t=await fe(n);Y.set(r,t)}this._encryptionKeyId=r}try{let r=await navigator.storage.getDirectory();this._root=await r.getDirectoryHandle(`lanceql-${this.name}`,{create:!0}),this._ready=!0}catch(r){throw console.error("[WorkerStore] Failed to open OPFS:",r),r}return this}_getCryptoKey(){return this._encryptionKeyId?Y.get(this._encryptionKeyId):null}async get(e){await this._ensureOpen();try{let r=this._getCryptoKey(),n=r?".enc":".json",o=await(await this._root.getFileHandle(`${e}${n}`)).getFile();if(r){let c=await o.arrayBuffer();return he(new Uint8Array(c),r)}else{let c=await o.text();return JSON.parse(c)}}catch(r){if(r.name==="NotFoundError")return;throw r}}async set(e,r){await this._ensureOpen();let n=this._getCryptoKey(),t=n?".enc":".json",c=await(await this._root.getFileHandle(`${e}${t}`,{create:!0})).createWritable();if(n){let s=await ue(r,n);await c.write(s)}else await c.write(JSON.stringify(r));await c.close()}async delete(e){await this._ensureOpen();let n=this._getCryptoKey()?".enc":".json";try{await this._root.removeEntry(`${e}${n}`)}catch(t){if(t.name!=="NotFoundError")throw t}}async keys(){await this._ensureOpen();let r=this._getCryptoKey()?".enc":".json",n=[];for await(let[t]of this._root.entries())t.endsWith(r)&&n.push(t.slice(0,-r.length));return n}async clear(){await this._ensureOpen();let e=[];for await(let[r]of this._root.entries())e.push(r);for(let r of e)await this._root.removeEntry(r)}async filter(e,r){let n=await this.get(e);if(!Array.isArray(n))throw new Error(`Key '${e}' is not a collection`);return n.filter(t=>this._matchQuery(t,r))}async find(e,r){let n=await this.get(e);if(!Array.isArray(n))throw new Error(`Key '${e}' is not a collection`);return n.find(t=>this._matchQuery(t,r))}async search(e,r,n=10){let t=await this.get(e);if(!Array.isArray(t))throw new Error(`Key '${e}' is not a collection`);if(t.length===0)return[];if(this._embedder)return this._semanticSearch(t,e,r,n);let o=r.toLowerCase();return t.map(s=>{let a=this._extractText(s).toLowerCase(),i=o.split(/\s+/),l=i.filter(f=>a.includes(f)).length;return{item:s,score:l/i.length}}).filter(s=>s.score>0).sort((s,a)=>a.score-s.score).slice(0,n)}async _semanticSearch(e,r,n,t){let o=await this._embedder.embed(n),c=[],s=[],a=[];for(let i=0;i<e.length;i++){let l=e[i],f=this._extractText(l),h=`${this.name}:${r}:${f}`;if(be.has(h)){let y=be.get(h),m=this._cosineSimilarity(o,y);c.push({item:l,score:m})}else s.push(f),a.push(i)}if(s.length>0){let i;s.length>1&&this._embedder.embedBatch?i=await this._embedder.embedBatch(s):i=await Promise.all(s.map(l=>this._embedder.embed(l)));for(let l=0;l<i.length;l++){let f=a[l],h=e[f],y=s[l],m=i[l],d=`${this.name}:${r}:${y}`;be.set(d,m);let g=this._cosineSimilarity(o,m);c.push({item:h,score:g})}}return c.sort((i,l)=>l.score-i.score).slice(0,t)}async enableSemanticSearch(e={}){let{model:r="minilm",onProgress:n}=e;if(G||(ie||(ie=this._initGPUTransformer(),ot(ie)),G=await ie,rt(G)),!G)return null;let t=await G.loadModel(r,n);return this._embedder={model:r,dimensions:t.hiddenSize,embed:async o=>G.encodeText(o,r),embedBatch:async o=>G.encodeTextBatch(o,r)},{model:r,dimensions:t.hiddenSize,type:t.modelType||"text"}}async _initGPUTransformer(){try{let e=await import("./webgpu/index.js");if(!e.isWebGPUAvailable())return console.log("[WorkerStore] WebGPU not available"),null;let r=e.getGPUTransformer();return await r.init()?(console.log("[WorkerStore] WebGPU initialized"),r):(console.log("[WorkerStore] WebGPU init failed"),null)}catch(e){return console.error("[WorkerStore] WebGPU init error:",e),null}}disableSemanticSearch(){this._embedder&&G&&(G.unloadModel(this._embedder.model),this._embedder=null)}hasSemanticSearch(){return this._embedder!==null}async count(e,r=null){let n=await this.get(e);if(!Array.isArray(n))throw new Error(`Key '${e}' is not a collection`);return r?n.filter(t=>this._matchQuery(t,r)).length:n.length}async _ensureOpen(){this._ready||await this.open()}_matchQuery(e,r){for(let[n,t]of Object.entries(r)){let o=e[n];if(typeof t=="object"&&t!==null)for(let[c,s]of Object.entries(t))switch(c){case"$eq":if(o!==s)return!1;break;case"$ne":if(o===s)return!1;break;case"$lt":if(!(o<s))return!1;break;case"$lte":if(!(o<=s))return!1;break;case"$gt":if(!(o>s))return!1;break;case"$gte":if(!(o>=s))return!1;break;case"$in":if(!Array.isArray(s)||!s.includes(o))return!1;break;case"$nin":if(Array.isArray(s)&&s.includes(o))return!1;break;case"$contains":if(typeof o!="string"||!o.includes(s))return!1;break;case"$regex":if(typeof o!="string"||!new RegExp(s).test(o))return!1;break}else if(o!==t)return!1}return!0}_extractText(e){if(typeof e=="string")return e;let r=[];for(let[n,t]of Object.entries(e))typeof t=="string"&&r.push(t);return r.join(" ")}_cosineSimilarity(e,r){let n=0,t=0,o=0;for(let c=0;c<e.length;c++)n+=e[c]*r[c],t+=e[c]*e[c],o+=r[c]*r[c];return n/(Math.sqrt(t)*Math.sqrt(o))}};var _e=class{constructor(e="lanceql"){this.rootDir=e,this.root=null}async getRoot(){if(this.root)return this.root;if(typeof navigator>"u"||!navigator.storage?.getDirectory)throw new Error("OPFS not available");let e=await navigator.storage.getDirectory();return this.root=await e.getDirectoryHandle(this.rootDir,{create:!0}),this.root}async open(){return await this.getRoot(),this}async getDir(e){let r=await this.getRoot(),n=e.split("/").filter(o=>o),t=r;for(let o of n)t=await t.getDirectoryHandle(o,{create:!0});return t}async save(e,r){let n=e.split("/"),t=n.pop(),o=n.join("/"),s=await(o?await this.getDir(o):await this.getRoot()).getFileHandle(t,{create:!0});if(s.createSyncAccessHandle)try{let i=await s.createSyncAccessHandle();return i.truncate(0),i.write(r,{at:0}),i.flush(),i.close(),{path:e,size:r.byteLength}}catch{}let a=await s.createWritable();return await a.write(r),await a.close(),{path:e,size:r.byteLength}}async load(e){try{let r=e.split("/"),n=r.pop(),t=r.join("/"),a=await(await(await(t?await this.getDir(t):await this.getRoot()).getFileHandle(n)).getFile()).arrayBuffer();return new Uint8Array(a)}catch(r){if(r.name==="NotFoundError")return null;throw r}}async delete(e){try{let r=e.split("/"),n=r.pop(),t=r.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(n),!0}catch(r){if(r.name==="NotFoundError")return!1;throw r}}async list(e=""){try{let r=e?await this.getDir(e):await this.getRoot(),n=[];for await(let[t,o]of r.entries())n.push({name:t,type:o.kind});return n}catch{return[]}}async exists(e){try{let r=e.split("/"),n=r.pop(),t=r.join("/");return await(t?await this.getDir(t):await this.getRoot()).getFileHandle(n),!0}catch{return!1}}async deleteDir(e){try{let r=e.split("/"),n=r.pop(),t=r.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(n,{recursive:!0}),!0}catch{return!1}}},U=new _e;var q=new TextEncoder,ee=new TextDecoder,De={INT64:"int64",INT32:"int32",FLOAT64:"float64",FLOAT32:"float32",STRING:"string",BOOL:"bool",VECTOR:"vector"},Pe=1,He=2,je=3,Ke=4,Ae=5,Se=6;function Ve(u){switch(u){case"int32":case"integer":return Int32Array;case"int64":return BigInt64Array;case"float32":case"real":return Float32Array;case"float64":case"double":return Float64Array;default:return null}}function st(u){switch(u){case"int32":case"integer":return Pe;case"int64":return He;case"float32":case"real":return je;case"float64":case"double":return Ke;case"string":case"text":return Ae;case"bool":case"boolean":return Se;default:return Ae}}var ge=class{constructor(e){this.schema=e,this.columns=new Map,this.rowCount=0,this._useBinary=!0}addRows(e){if(e.length!==0){if(this.rowCount===0)for(let r of this.schema){let n=Ve(r.dataType);n?this.columns.set(r.name,{type:"typed",dataType:r.dataType,data:new n(Math.max(e.length,1024)),length:0}):this.columns.set(r.name,{type:"array",dataType:r.dataType,data:[],length:0})}for(let r of this.schema){let n=this.columns.get(r.name);if(n.type==="typed"){let t=n.length+e.length;if(t>n.data.length){let o=Math.max(t,n.data.length*2),c=new n.data.constructor(o);c.set(n.data),n.data=c}for(let o=0;o<e.length;o++){let c=e[o][r.name];n.data[n.length+o]=c??0}n.length+=e.length}else{for(let t=0;t<e.length;t++)n.data.push(e[t][r.name]??null);n.length+=e.length}}this.rowCount+=e.length}}buildBinary(){let e=[],r=16,n=[];for(let a of this.schema){let i=this.columns.get(a.name),l=q.encode(a.name),f=st(a.dataType),h;if(i.type==="typed"){let d=i.data.subarray(0,i.length);h=new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}else h=q.encode(JSON.stringify(i.data));n.push({nameBytes:l,typeCode:f,dataBytes:h,dataType:a.dataType});let m=(8-(r+4+l.length+1+4)%8)%8;r+=4+l.length+1+m+4+h.length}let t=new ArrayBuffer(r),o=new DataView(t),c=new Uint8Array(t),s=0;o.setUint32(s,1279348291,!1),s+=4,o.setUint32(s,2,!1),s+=4,o.setUint32(s,this.schema.length,!1),s+=4,o.setUint32(s,this.rowCount,!1),s+=4;for(let a of n){o.setUint32(s,a.nameBytes.length,!1),s+=4,c.set(a.nameBytes,s),s+=a.nameBytes.length,o.setUint8(s,a.typeCode),s+=1;let i=(8-(s+4)%8)%8;for(let l=0;l<i;l++)o.setUint8(s+l,0);s+=i,o.setUint32(s,a.dataBytes.length,!1),s+=4,c.set(a.dataBytes,s),s+=a.dataBytes.length}return new Uint8Array(t)}setColumnarData(e){let r=Object.keys(e)[0];this.rowCount=e[r]?.length||0;for(let n of this.schema){let t=e[n.name];if(!t)continue;let o=Ve(n.dataType);if(o&&ArrayBuffer.isView(t))this.columns.set(n.name,{type:"typed",dataType:n.dataType,data:t,length:t.length});else if(o){let c=new o(t.length);for(let s=0;s<t.length;s++)c[s]=t[s]??0;this.columns.set(n.name,{type:"typed",dataType:n.dataType,data:c,length:t.length})}else this.columns.set(n.name,{type:"array",dataType:n.dataType,data:Array.isArray(t)?t:Array.from(t),length:t.length})}}build(){if(this._useBinary&&this.rowCount>0)try{return this.buildBinary()}catch(r){console.warn("[LanceFileWriter] Binary build failed, falling back to JSON:",r)}let e={format:"json",schema:this.schema,columns:{},rowCount:this.rowCount};for(let[r,n]of this.columns)n.type==="typed"?e.columns[r]=Array.from(n.data.subarray(0,n.length)):e.columns[r]=n.data;return q.encode(JSON.stringify(e))}};function le(u){let e=new DataView(u.buffer||u),r=new Uint8Array(u.buffer||u),n=0;if(e.getUint32(n,!1)!==1279348291)return null;n+=4;let o=e.getUint32(n,!1);n+=4;let c=e.getUint32(n,!1);n+=4;let s=e.getUint32(n,!1);n+=4;let a=[],i={};for(let l=0;l<c;l++){let f=e.getUint32(n,!1);n+=4;let h=ee.decode(r.subarray(n,n+f));n+=f;let y=e.getUint8(n);n+=1;let m=(8-(n+4)%8)%8;n+=m;let d=e.getUint32(n,!1);n+=4;let g=r.subarray(n,n+d);n+=d;let w,A;try{switch(y){case Pe:A="int32",g.byteOffset%4!==0?w=new Int32Array(g.slice().buffer):w=new Int32Array(g.buffer,g.byteOffset,g.byteLength/4);break;case je:A="float32",g.byteOffset%4!==0?w=new Float32Array(g.slice().buffer):w=new Float32Array(g.buffer,g.byteOffset,g.byteLength/4);break;case Ke:A="float64",g.byteOffset%8!==0?w=new Float64Array(g.slice().buffer):w=new Float64Array(g.buffer,g.byteOffset,g.byteLength/8);break;case He:A="int64",g.byteOffset%8!==0?w=new BigInt64Array(g.slice().buffer):w=new BigInt64Array(g.buffer,g.byteOffset,g.byteLength/8);break;case Ae:case Se:default:A=y===Se?"bool":"string",w=JSON.parse(ee.decode(g));break}}catch(p){throw console.error(`[LanceQLWorker] Error parsing column '${h}' (type ${y}, len ${d}):`,p),p}a.push({name:h,dataType:A}),i[h]=w}return{schema:a,columns:i,rowCount:s,format:"binary"}}var re=class{constructor(e=512*1024*1024){this.maxBytes=e,this.currentBytes=0,this.cache=new Map,this.head=null,this.tail=null}get(e){let r=this.cache.get(e);if(r)return this._moveToHead(r),r.value}set(e,r,n=0){let t=this.cache.get(e);if(t)this.currentBytes-=t.size,this.currentBytes+=n,t.value=r,t.size=n,this._moveToHead(t);else{let o={key:e,value:r,size:n,prev:null,next:null};this.cache.set(e,o),this._addToHead(o),this.currentBytes+=n}this._evictIfNeeded()}has(e){return this.cache.has(e)}delete(e){let r=this.cache.get(e);r&&(this._removeNode(r),this.cache.delete(e),this.currentBytes-=r.size)}clear(){this.cache.clear(),this.head=null,this.tail=null,this.currentBytes=0}_moveToHead(e){e!==this.head&&(this._removeNode(e),this._addToHead(e))}_addToHead(e){e.next=this.head,e.prev=null,this.head&&(this.head.prev=e),this.head=e,this.tail||(this.tail=e)}_removeNode(e){e.prev?e.prev.next=e.next:this.head=e.next,e.next?e.next.prev=e.prev:this.tail=e.prev}_evictIfNeeded(){for(;this.currentBytes>this.maxBytes&&this.tail;){let e=this.tail;this._removeNode(e),this.cache.delete(e.key),this.currentBytes-=e.size}}static estimateSize(e){return e?e.byteLength?e.byteLength:Array.isArray(e)?e.length*100:e.buffer&&e.buffer.byteLength?e.buffer.byteLength:1e3:0}};var Te=new Map,at=1,oe=class{constructor(e,r){this.name=e,this.tables=new Map,this.version=0,this.manifestKey=`${e}/__manifest__`,this.bufferPool=r||new re,this._writeBuffer=new Map,this._flushTimer=null,this._flushInterval=2e3,this._flushThreshold=1e4,this._columnarBuffer=new Map,this._flushing=!1,this._readCache=new Map,this._columnarCache=new Map}async open(){let e=await U.load(this.manifestKey);if(e){let r=JSON.parse(ee.decode(e));this.version=r.version||0,this.tables=new Map(Object.entries(r.tables||{}));for(let[n,t]of this.tables)await this._getLatestVersion(n)===0&&t.fragments?.length>0&&await this._createVersion(n,"MIGRATE")}return this}async _saveManifest(){this.version++;let e={version:this.version,timestamp:Date.now(),tables:Object.fromEntries(this.tables)},r=q.encode(JSON.stringify(e));await U.save(this.manifestKey,r)}async _getLatestVersion(e){let r=`${this.name}/${e}/_latest`;try{let n=await U.load(r);return n?parseInt(ee.decode(n),10):0}catch{return 0}}async _setLatestVersion(e,r){let n=`${this.name}/${e}/_latest`;await U.save(n,q.encode(String(r)))}async _loadTableVersion(e,r){let n=`${this.name}/${e}/_versions/${r}.manifest`,t=await U.load(n);if(!t)throw new Error(`Version ${r} not found for table '${e}'`);return JSON.parse(ee.decode(t))}async _saveTableVersion(e,r){let n=`${this.name}/${e}/_versions/${r.version}.manifest`;await U.save(n,q.encode(JSON.stringify(r)))}async _createVersion(e,r){let n=this.tables.get(e);if(!n)return 0;let t=await this._getLatestVersion(e),o=t+1,c={version:o,timestamp:Date.now(),parentVersion:t,operation:r,schema:n.schema,fragments:[...n.fragments],deletionVector:[...n.deletionVector],rowCount:n.rowCount,nextRowId:n.nextRowId};return await this._saveTableVersion(e,c),await this._setLatestVersion(e,o),o}async listVersions(e){let r=await this._getLatestVersion(e),n=[];for(let t=1;t<=r;t++)try{let o=await this._loadTableVersion(e,t);n.push({version:o.version,timestamp:o.timestamp,operation:o.operation,rowCount:o.rowCount})}catch{}return n}async selectAtVersion(e,r,n={}){let t=await this._loadTableVersion(e,r),o=new Set(t.deletionVector),c=this.tables.get(e),s=[];for(let l of t.fragments){let f=await U.load(l);if(f){let h=this._parseFragment(f,t.schema);for(let y of h)o.has(y.__rowId)||s.push(y)}}let a=s;if(n.where&&(a=a.filter(n.where)),n.orderBy){let{column:l,desc:f}=n.orderBy;a.sort((h,y)=>{let m=h[l]<y[l]?-1:h[l]>y[l]?1:0;return f?-m:m})}n.offset&&(a=a.slice(n.offset)),n.limit&&(a=a.slice(0,n.limit));let i=n.columns&&n.columns.length>0&&n.columns[0]!=="*"?n.columns:null;return a.map(l=>{if(i){let f={};for(let h of i)f[h]=l[h];return f}else{let{__rowId:f,...h}=l;return h}})}async restoreToVersion(e,r){let n=await this._loadTableVersion(e,r),t=await this._getLatestVersion(e),o=t+1,c={...n,version:o,timestamp:Date.now(),parentVersion:t,operation:`RESTORE_FROM_${r}`};await this._saveTableVersion(e,c),await this._setLatestVersion(e,o);let s=this.tables.get(e);return s&&(s.fragments=[...n.fragments],s.deletionVector=[...n.deletionVector],s.rowCount=n.rowCount,s.nextRowId=n.nextRowId,this._columnarBuffer.delete(e),this._writeBuffer.delete(e),await this._saveManifest()),{restored:!0,newVersion:o}}async createTable(e,r,n=!1){if(this.tables.has(e)){if(n)return{success:!0,existed:!0};throw new Error(`Table '${e}' already exists`)}let t=r.map(c=>({name:c.name,type:De[(c.dataType||c.type)?.toUpperCase()]||c.dataType||c.type||"string",primaryKey:c.primaryKey||!1,vectorDim:c.vectorDim||null})),o={name:e,schema:t,fragments:[],deletionVector:[],rowCount:0,nextRowId:0,version:0,createdAt:Date.now()};return this.tables.set(e,o),await this._saveManifest(),await this._createVersion(e,"CREATE"),{success:!0,table:e}}async dropTable(e,r=!1){if(!this.tables.has(e)){if(r)return this._writeBuffer.delete(e),{success:!0,existed:!1};throw new Error(`Table '${e}' does not exist`)}let n=this.tables.get(e);this._writeBuffer.delete(e);for(let t of n.fragments)this._readCache.delete(t),await U.delete(t);return this.tables.delete(e),await this._saveManifest(),{success:!0,table:e}}async insert(e,r){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let n=this.tables.get(e),t=r.length;if(!this._columnarBuffer.has(e)){let a=Math.max(1024,t*2),i={__rowId:new Float64Array(a),__length:0,__capacity:a,__schema:n.schema};for(let l of n.schema){let f=(l.dataType||l.type||"").toLowerCase();f==="text"||f==="string"||f==="varchar"?i[l.name]=new Array(a):f==="int64"||f==="bigint"?i[l.name]=new BigInt64Array(a):i[l.name]=new Float64Array(a)}this._columnarBuffer.set(e,i)}let o=this._columnarBuffer.get(e),c=o.__length,s=o.__capacity;if(c+t>s){let a=Math.max(s*2,c+t),i=new Float64Array(a);i.set(o.__rowId.subarray(0,c)),o.__rowId=i;for(let l of n.schema){let f=o[l.name];if(f instanceof Float64Array){let h=new Float64Array(a);h.set(f.subarray(0,c)),o[l.name]=h}else if(f instanceof BigInt64Array){let h=new BigInt64Array(a);h.set(f.subarray(0,c)),o[l.name]=h}else o[l.name].length=a}o.__capacity=a}for(let a=0;a<t;a++){let i=r[a];o.__rowId[c+a]=n.nextRowId++;for(let l of n.schema){let f=i[l.name];o[l.name]instanceof Float64Array?o[l.name][c+a]=f!=null?Number(f):NaN:o[l.name]instanceof BigInt64Array?o[l.name][c+a]=f!=null?BigInt(f):0n:o[l.name][c+a]=f??null}}return o.__length=c+t,n.rowCount+=t,n.version=(n.version||0)+1,this._scheduleFlush(),o.__length>=this._flushThreshold&&await this._flushTable(e),{success:!0,inserted:t}}_scheduleFlush(){this._flushTimer||(this._flushTimer=setTimeout(()=>{this._flushTimer=null,this.flush().catch(e=>console.warn("[WorkerDatabase] Flush error:",e))},this._flushInterval))}async flush(){if(!this._flushing){this._flushing=!0;try{let e=[...this._columnarBuffer.keys()];for(let r of e)await this._flushTable(r)}finally{this._flushing=!1}}}async _flushTable(e){let r=this._columnarBuffer.get(e),n=r?.__length||0;if(!r||n===0)return;let t=this.tables.get(e);if(!t)return;let o=[{name:"__rowId",type:"int64",dataType:"float64",primaryKey:!0},...t.schema.filter(l=>l.name!=="__rowId").map(l=>{let f=(l.dataType||l.type||"").toLowerCase();return f==="int64"||f==="bigint"?{...l,dataType:"int64"}:{...l,dataType:f==="float64"||f==="float32"||f==="int32"||f==="integer"||f==="real"||f==="double"?"float64":l.dataType||l.type||"float64"}})],c={};for(let l of o){let f=r[l.name];f&&(f instanceof Float64Array||f instanceof BigInt64Array?c[l.name]=f.subarray(0,n):c[l.name]=f.slice(0,n))}r.__length=0;let s=new ge(o);s.setColumnarData(c);let a=s.build(),i=`${this.name}/${e}/frag_${Date.now()}_${Math.random().toString(36).slice(2)}.lance`;await U.save(i,a),t.fragments.push(i),await this._saveManifest(),await this._createVersion(e,"INSERT")}async delete(e,r){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let n=this.tables.get(e),t=0,o=this._columnarBuffer.get(e),c=o?.__length||0;if(o&&c>0){let s=n.schema.map(a=>a.name);for(let a=0;a<c;a++){let i={__rowId:o.__rowId[a]};for(let l of s){let f=o[l][a];i[l]=Number.isNaN(f)?null:f}r(i)&&(n.deletionVector.includes(o.__rowId[a])||(n.deletionVector.push(o.__rowId[a]),t++))}}for(let s of n.fragments){let a=await U.load(s);if(a){let i=this._parseFragment(a,n.schema);for(let l of i)!n.deletionVector.includes(l.__rowId)&&r(l)&&(n.deletionVector.push(l.__rowId),t++)}}return n.rowCount-=t,n.version=(n.version||0)+1,await this._saveManifest(),t>0&&await this._createVersion(e,"DELETE"),{success:!0,deleted:t}}async update(e,r,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let t=this.tables.get(e),o=0,c=this._writeBuffer.get(e);if(c&&c.length>0)for(let a of c)n(a)&&(Object.assign(a,r),o++);let s=[];for(let a of t.fragments){let i=await U.load(a);if(i){let l=this._parseFragment(i,t.schema);for(let f of l)if(!t.deletionVector.includes(f.__rowId)&&n(f)){t.deletionVector.push(f.__rowId),t.rowCount--;let h={...f,...r};delete h.__rowId,s.push(h),o++}}}return s.length>0?await this.insert(e,s):await this._saveManifest(),o>0&&s.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:o}}async updateWithExpr(e,r,n,t){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let o=this.tables.get(e),c=0,s=this._columnarBuffer.get(e),a=s?.__length||0;if(s&&a>0){let l=o.schema.map(f=>f.name);for(let f=0;f<a;f++){let h={__rowId:s.__rowId[f]};for(let y of l){let m=s[y][f];h[y]=Number.isNaN(m)?null:m}if(n(h)){for(let[y,m]of Object.entries(r)){let d=t(m,h);s[y]!==void 0&&(s[y][f]=d??(s[y]instanceof Float64Array?NaN:null))}o.version=(o.version||0)+1,c++}}}let i=[];for(let l of o.fragments){let f=await U.load(l);if(f){let h=this._parseFragment(f,o.schema);for(let y of h)if(!o.deletionVector.includes(y.__rowId)&&n(y)){o.deletionVector.push(y.__rowId),o.rowCount--;let m={...y};for(let[d,g]of Object.entries(r))m[d]=t(g,y);delete m.__rowId,i.push(m),c++}}}return i.length>0?await this.insert(e,i):await this._saveManifest(),c>0&&i.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:c}}async select(e,r={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let n=await this._readAllRows(e);if(r.where&&(n=n.filter(r.where)),r.orderBy){let{column:c,desc:s}=r.orderBy;n.sort((a,i)=>{let l=a[c]<i[c]?-1:a[c]>i[c]?1:0;return s?-l:l})}r.offset&&(n=n.slice(r.offset)),r.limit&&(n=n.slice(0,r.limit));let t=r.columns&&r.columns.length>0&&r.columns[0]!=="*"?r.columns:null,o=new Array(n.length);for(let c=0;c<n.length;c++){let s=n[c];if(t){let a={};for(let i of t)a[i]=s[i];o[c]=a}else{let{__rowId:a,...i}=s;o[c]=i}}return o}async _readAllRows(e){let r=this.tables.get(e),n=this._columnarBuffer.get(e),o=r.deletionVector.length>0?new Set(r.deletionVector):null,c=[];for(let a of r.fragments){let i=this.bufferPool.get(a),l=null;if(!i){let f=await U.load(a);f&&(i=le(f),i?this.bufferPool.set(a,i,f.byteLength):l=this._parseFragment(f,r.schema))}if(i&&!l&&(l=this._hydrateRowsFromBinary(i,r.schema)),l=l||[],!o)c.push(...l);else for(let f of l)o.has(f.__rowId)||c.push(f)}let s=n?.__length||0;if(n&&s>0){let a=r.schema.map(i=>i.name);for(let i=0;i<s;i++){if(o&&o.has(n.__rowId[i]))continue;let l={__rowId:n.__rowId[i]};for(let f of a){let h=n[f][i];l[f]=Number.isNaN(h)?null:h}c.push(l)}}return c}_hydrateRowsFromBinary(e,r){let{columns:n,rowCount:t}=e,o=r.map(s=>s.name),c=new Array(t);for(let s=0;s<t;s++){let a={__rowId:n.__rowId[s]};for(let i of o)n[i]&&(a[i]=n[i][s]);c[s]=a}return c}_parseFragment(e,r){try{let n=le(e);if(n)return this._parseBinaryColumnar(n);let t=ee.decode(e),o=JSON.parse(t);return o.format==="json"&&o.columns?this._parseJsonColumnar(o):Array.isArray(o)?o:[o]}catch(n){return console.warn("[WorkerDatabase] Failed to parse fragment:",n),[]}}async selectColumnar(e){let r=this.tables.get(e);if(!r)return null;let n=this._columnarBuffer.get(e)?.__length||0,t=`${r.fragments.length}:${n}:${r.deletionVector.length}:${r.version||0}`,o=this._columnarCache.get(e);if(o&&o.version===t){let d={};for(let[g,w]of Object.entries(o.data.columns))ArrayBuffer.isView(w)?d[g]=new w.constructor(w.buffer,w.byteOffset,w.length):d[g]=w;return{schema:r.schema,columns:d,rowCount:o.data.rowCount}}let s=r.deletionVector.length>0?new Set(r.deletionVector):null,a={},i=r.schema.map(d=>d.name);for(let d of i)a[d]=[];a.__rowId=[];for(let d of r.fragments){let g=this.bufferPool.get(d);if(!g){let p=await U.load(d);if(!p)continue;g=le(p),g&&this.bufferPool.set(d,g,p.byteLength)}if(!g)continue;let{columns:w,rowCount:A}=g;if(s){let p=w.__rowId,b=[];for(let F=0;F<A;F++)s.has(p[F])||b.push(F);for(let F of i)if(w[F]){let S=w[F],_=new S.constructor(b.length);for(let T=0;T<b.length;T++)_[T]=S[b[T]];a[F].push(_)}}else{for(let p of i)w[p]&&a[p].push(w[p]);w.__rowId&&a.__rowId.push(w.__rowId)}}let l=this._columnarBuffer.get(e),f=l?.__length||0;if(l&&f>0)if(s){let d=[];for(let A=0;A<f;A++)s.has(l.__rowId[A])||d.push(A);let g=d.length;for(let A of r.schema){let p=l[A.name];if(p)if(p instanceof Float64Array){let b=new Float64Array(g);for(let F=0;F<g;F++)b[F]=p[d[F]];a[A.name].push(b)}else a[A.name].push(d.map(b=>p[b]))}let w=new Float64Array(g);for(let A=0;A<g;A++)w[A]=l.__rowId[d[A]];a.__rowId.push(w)}else{for(let g of r.schema){let w=l[g.name];if(w)if(w instanceof Float64Array){let A=new Float64Array(f);A.set(w.subarray(0,f)),a[g.name].push(A)}else a[g.name].push(w.slice(0,f))}let d=new Float64Array(f);d.set(l.__rowId.subarray(0,f)),a.__rowId.push(d)}let h={},y=0;for(let d of[...i,"__rowId"]){let g=a[d];if(g.length===0)h[d]=new Float64Array(0);else if(g.length===1)h[d]=g[0],y===0&&(y=g[0].length);else{let w=g.reduce((F,S)=>F+S.length,0);y===0&&(y=w);let A=g[0],p=ArrayBuffer.isView(A)?new A.constructor(w):new Array(w),b=0;for(let F of g){if(ArrayBuffer.isView(p))p.set(F,b);else for(let S=0;S<F.length;S++)p[b+S]=F[S];b+=F.length}h[d]=p}}let m={schema:r.schema,columns:h,rowCount:y};return this._columnarCache.set(e,{version:t,data:m}),m}async _readColumn(e,r){let n=this.tables.get(e);if(!n)return null;let t=this._writeBuffer.get(e),o=[];for(let i of n.fragments){let l=await U.load(i);if(!l)continue;let f=le(l);if(f&&f.columns[r]){let h=f.columns[r];h.length>0&&o.push(h)}}if(t&&t.length>0){let i=new Float64Array(t.length);for(let l=0;l<t.length;l++){let f=t[l][r];i[l]=typeof f=="number"?f:0}o.push(i)}if(o.length===0)return new Float64Array(0);if(o.length===1)return o[0];let c=o.reduce((i,l)=>i+l.length,0),s=new Float64Array(c),a=0;for(let i of o)s.set(i,a),a+=i.length;return s}_parseBinaryColumnar(e){let{schema:r,columns:n,rowCount:t}=e,o=new Array(t),c=r.map(i=>i.name),s=c.map(i=>n[i]),a=c.length;for(let i=0;i<t;i++){let l={};for(let f=0;f<a;f++)l[c[f]]=s[f][i]??null;o[i]=l}return o}_parseJsonColumnar(e){let{schema:r,columns:n,rowCount:t}=e,o=new Array(t),c=r.map(i=>i.name),s=c.map(i=>n[i]||[]),a=c.length;for(let i=0;i<t;i++){let l={};for(let f=0;f<a;f++)l[c[f]]=s[f][i]??null;o[i]=l}return o}getTable(e){return this.tables.get(e)}listTables(){return Array.from(this.tables.keys())}getFragmentPaths(e){let r=this.tables.get(e);return r?r.fragments:[]}getColumnIndex(e,r){let n=this.tables.get(e);if(!n)return-1;let t=n.schema.findIndex(o=>o.name===r);return t>=0?t+1:-1}hasBufferedData(e){let r=this._columnarBuffer.get(e);return r&&(r.__length||0)>0}async compact(){for(let[e,r]of this.tables){let n=await this._readAllRows(e);for(let t of r.fragments)await U.delete(t);if(r.fragments=[],r.deletionVector=[],r.rowCount=0,r.nextRowId=0,n.length>0){let t=n.map(({__rowId:o,...c})=>c);await this.insert(e,t)}}return{success:!0,compacted:this.tables.size}}async scanStart(e,r={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let n=at++,t=this.tables.get(e),o=new Set(t.deletionVector),c=[];for(let a of t.fragments){let i=await U.load(a);if(i){let l=this._parseFragment(i,t.schema);for(let f of l)o.has(f.__rowId)||c.push(f)}}let s=this._writeBuffer.get(e);if(s)for(let a of s)o.has(a.__rowId)||c.push(a);return Te.set(n,{rows:c,index:0,batchSize:r.batchSize||1e4,columns:r.columns}),n}scanNext(e){let r=Te.get(e);if(!r)return{batch:[],done:!0};let n=[],t=Math.min(r.index+r.batchSize,r.rows.length);for(let c=r.index;c<t;c++){let s=r.rows[c],a;if(r.columns&&r.columns.length>0&&r.columns[0]!=="*"){a={};for(let i of r.columns)a[i]=s[i]}else{let{__rowId:i,...l}=s;a=l}n.push(a)}r.index=t;let o=r.index>=r.rows.length;return o&&Te.delete(e),{batch:n,done:o}}};var we=class{constructor(){this._root=null,this._ready=!1,this._kv={},this._encryptionKeyId=null,this._db=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:r,keyBytes:n}=e;if(!Y.has(r)){let t=await fe(n);Y.set(r,t)}this._encryptionKeyId=r}try{let r=await navigator.storage.getDirectory();this._root=await r.getDirectoryHandle("vault",{create:!0}),await this._loadKV(),this._db=new oe("vault"),await this._db.open(),this._ready=!0}catch(r){throw console.error("[WorkerVault] Failed to open OPFS:",r),r}return this}_getCryptoKey(){return this._encryptionKeyId?Y.get(this._encryptionKeyId):null}async _loadKV(){try{let e=this._getCryptoKey(),r=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(r)).getFile();if(e){let o=await t.arrayBuffer();this._kv=await he(new Uint8Array(o),e)}else{let o=await t.text();this._kv=JSON.parse(o)}}catch(e){if(e.name==="NotFoundError")this._kv={};else throw e}}async _saveKV(){let e=this._getCryptoKey(),r=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(r,{create:!0})).createWritable();if(e){let o=await ue(this._kv,e);await t.write(o)}else await t.write(JSON.stringify(this._kv));await t.close()}async get(e){return this._kv[e]}async set(e,r){this._kv[e]=r,await this._saveKV()}async delete(e){delete this._kv[e],await this._saveKV()}async keys(){return Object.keys(this._kv)}async has(e){return e in this._kv}};var it=1;var ze={INT64:0,FLOAT64:1,INT32:2,FLOAT32:3,STRING:4,LIST:5},$e=class{constructor(){this._registered=new Map}getLastError(){let e=Q();if(!e)return"WASM not loaded";let r=e.alloc(4096);console.log(`[WASM LOG] getLastError alloc ptr: ${r}`);let n=e.getLastError(r,4096);if(console.log(`[WASM LOG] getLastError len: ${n}`),n===0)return"Unknown Error";let t=new Uint8Array(j().buffer,r,n),o=new TextDecoder().decode(t);return console.log(`[WASM LOG] getLastError msg: ${o}`),o}getTableNames(e){let r=Q();if(!r)throw new Error("WASM not loaded");let n=new TextEncoder().encode(e),t=r.alloc(n.length);new Uint8Array(j().buffer,t,n.length).set(n);let o=r.getTableNames(t,n.length);if(o===0)return[];let c=new Uint8Array(j().buffer,o),s=0;for(;c[s]!==0&&s<1024;)s++;let a=new TextDecoder().decode(c.subarray(0,s));return a?a.split(",").filter(i=>i):[]}hasTable(e){let r=Q();if(!r)return!1;let n=new TextEncoder().encode(e),t=r.alloc(n.length);return new Uint8Array(j().buffer,t,n.length).set(n),r.hasTable(t,n.length)===1}hasTableWithVersion(e,r){let n=this._registered.get(e);return n&&n.version===r}registerTable(e,r,n,t=""){let o=Q();if(!o)throw new Error("WASM not loaded");let c=this._registered.get(e);if(c&&c.version===t)return;if(c){let f=new TextEncoder().encode(e);o.clearTable(f,f.length)}let s=()=>j().buffer;if(!s())throw new Error("WASM memory not available");let a=new TextEncoder().encode(e),i=o.alloc(a.length);if(i<0||i>=s().byteLength)throw new Error(`Invalid alloc result: ${i} for ${a.length} bytes`);new Uint8Array(s(),i,a.length).set(a);let l=new Set;for(let[f,h]of Object.entries(r)){if(f.startsWith("__")||Array.isArray(h)&&h.length===0)continue;let y=new TextEncoder().encode(f),m=o.alloc(y.length);if(m<0||m>=s().byteLength)throw new Error(`Invalid colName alloc: ${m}`);if(new Uint8Array(s(),m,y.length).set(y),h instanceof Float64Array){let d=o.allocFloat64Buffer(h.length);if(d===0||d<0||d>=s().byteLength)throw new Error(`Invalid Float64 alloc: ${d} for ${h.length} elements`);new Float64Array(s(),d,h.length).set(h),o.registerTableFloat64(i,a.length,m,y.length,d,h.length),l.add(f)}else if(h instanceof BigInt64Array){let d=o.allocInt64Buffer(h.length);new BigInt64Array(s(),d,h.length).set(h),o.registerTableInt64(i,a.length,m,y.length,d,h.length),l.add(f)}else if(h instanceof Int32Array){let d=new Float64Array(h.length);for(let w=0;w<h.length;w++)d[w]=h[w];let g=o.allocFloat64Buffer(d.length);new Float64Array(s(),g,d.length).set(d),o.registerTableFloat64(i,a.length,m,y.length,g,d.length),l.add(f)}else if(h instanceof Float32Array){let d=`__${f}_dim`,g=r[d]||0,w=g>0?Math.floor(h.length/g):h.length,A=o.allocFloat32Buffer?o.allocFloat32Buffer(h.length):null;A?(new Float32Array(s(),A,h.length).set(h),o.registerTableFloat32Vector?(o.registerTableFloat32Vector(i,a.length,m,y.length,A,w,g),console.log(`[Bridge] Registered vector column ${f}: ${w} rows, dim=${g}`)):console.warn(`[Bridge] No registerTableFloat32Vector, skipping ${f}`),l.add(f)):console.warn(`[Bridge] Failed to alloc Float32 buffer for ${f}`)}else if(Array.isArray(h)){let d=new Uint32Array(h.length),g=new Uint32Array(h.length),w=new TextEncoder,A=[],p=0;for(let $=0;$<h.length;$++){let k=String(h[$]||""),E=w.encode(k);A.push(E),g[$]=E.length,d[$]=p,p+=E.length}let b=new Uint8Array(p),F=0;for(let $=0;$<A.length;$++)b.set(A[$],F),F+=A[$].length;let S=o.alloc(d.byteLength);if(S<0||S>=s().byteLength)throw new Error(`Invalid offsetsPtr alloc: ${S}`);new Uint32Array(s(),S,d.length).set(d);let _=o.alloc(g.byteLength);if(_<0||_>=s().byteLength)throw new Error(`Invalid lengthsPtr alloc: ${_}`);new Uint32Array(s(),_,g.length).set(g);let T=o.alloc(b.length||1);if(T<0||T>=s().byteLength)throw new Error(`Invalid dataPtr alloc: ${T}`);new Uint8Array(s(),T,b.length).set(b),o.registerTableString(i,a.length,m,y.length,S,_,T,p,h.length),l.add(f)}}this._registered.set(e,{version:t,columns:l,rowCount:n})}aliasTable(e,r){let n=Q();if(!n)throw new Error("WASM not loaded");let t=new TextEncoder,o=t.encode(e),c=t.encode(r),s=n.alloc(o.length),a=n.alloc(c.length),i=j().buffer;new Uint8Array(i,s,o.length).set(o),new Uint8Array(i,a,c.length).set(c),n.aliasTable&&n.aliasTable(s,o.length,a,c.length);let l=this._registered.get(e);l&&this._registered.set(r,{...l,aliasOf:e})}registerTableFromFiles(e,r,n=""){let t=Q();if(!t)throw new Error("WASM not loaded");let o=this._registered.get(e);if(o&&o.version===n)return;if(o){let i=new TextEncoder().encode(e);t.clearTable(i,i.length)}let c=new TextEncoder,s=c.encode(e),a=t.alloc(s.length);new Uint8Array(j().buffer,a,s.length).set(s);for(let i of r){let l=c.encode(i),f=t.alloc(l.length);new Uint8Array(j().buffer,f,l.length).set(l);let h=t.registerTableFromOPFS(a,s.length,f,l.length);h!==0&&console.warn(`Failed to register fragment ${i} for table ${e}: error ${h}`)}this._registered.set(e,{version:n,type:"files"})}appendTableMemory(e,r,n){let t=Q();if(!t)throw new Error("WASM not loaded");let o=()=>j().buffer,c=new TextEncoder().encode(e),s=t.alloc(c.length);new Uint8Array(o(),s,c.length).set(c);for(let[a,i]of Object.entries(r)){if(a.startsWith("__"))continue;let l=new TextEncoder().encode(a),f=t.alloc(l.length);if(new Uint8Array(o(),f,l.length).set(l),i instanceof Float64Array){let h=t.allocFloat64Buffer(i.length);new Float64Array(o(),h,i.length).set(i),t.appendTableMemory(s,c.length,f,l.length,h,4,n)}else if(i instanceof BigInt64Array){let h=t.allocInt64Buffer(i.length);new BigInt64Array(o(),h,i.length).set(i),t.appendTableMemory(s,c.length,f,l.length,h,2,n)}else if(i instanceof Int32Array){let h=t.alloc(i.byteLength);new Int32Array(o(),h,i.length).set(i),t.appendTableMemory(s,c.length,f,l.length,h,1,n)}else if(i instanceof Float32Array){let h=t.alloc(i.byteLength);new Float32Array(o(),h,i.length).set(i),t.appendTableMemory(s,c.length,f,l.length,h,3,n)}}}execute(e){let r=Q();if(!r)throw new Error("WASM not loaded");if(r.setCurrentTimestamp)try{r.setCurrentTimestamp(BigInt(Date.now()))}catch(l){console.warn("setCurrentTimestamp failed:",l)}let n=r.getSqlInputBuffer(),t=r.getSqlInputBufferSize(),o=new TextEncoder().encode(e);if(o.length>t)throw new Error(`SQL too long: ${o.length} > ${t}`);new Uint8Array(j().buffer,n,o.length).set(o),r.setSqlInputLength(o.length);let c=r.executeSql();if(c===0){let l=this.getLastError();throw console.log(`[WASM LOG] execute throwing: "${l}"`),new Error(l)}let s=r.getResultSize(),a=this.getLastError();a&&a.length>0&&console.log(`[WASM DEBUG CAPTURED] ${a}`),a.length>0&&a.startsWith("DEBUG:");let i=this._parseResult(j().buffer,c,s);return r.resetResult(),i}_parseResult(e,r,n){let t=new DataView(e,r,n),o=new TextDecoder;if(n>=40){let c=n-40,s=[t.getUint8(c+36),t.getUint8(c+37),t.getUint8(c+38),t.getUint8(c+39)];if(String.fromCharCode(...s)==="LANC")return this._parseLanceResult(e,r,n,c,t,o)}if(n>=36&&t.getUint32(0,!0)===it)return this._parseLegacyResult(e,r,n);throw new Error(`Invalid result format (Size: ${n}). Not a Lance file.`)}_parseLanceResult(e,r,n,t,o,c){let s=Number(o.getBigUint64(t+8,!0)),a=o.getUint32(t+28,!0),i=[],l={},f=0;for(let h=0;h<a;h++){let y=s+h*8,d=Number(o.getBigUint64(y,!0));o.getUint8(d++);let[g,w]=this._readVarint(o,d);d+=w;let A=new Uint8Array(e,r+d,g),p=c.decode(A);d+=g,i.push(p),o.getUint8(d++);let[b,F]=this._readVarint(o,d);d+=F;let S=new Uint8Array(e,r+d,b),_=c.decode(S);d+=b,o.getUint8(d++);let[T,$]=this._readVarint(o,d);d+=$,o.getUint8(d++);let k=Number(o.getBigUint64(d,!0));d+=8,o.getUint8(d++);let[E,x]=this._readVarint(o,d);d+=x,f=E,o.getUint8(d++);let[B,H]=this._readVarint(o,d);d+=H;let V=r+k;if(_==="float64"||_==="int64"||_==="int32"||_==="float32")if(_==="float64"){let I=new Float64Array(e,V,E).slice(),O=!1;for(let v=0;v<E;v++)if(Number.isNaN(I[v])){O=!0;break}if(O){console.log(`[WASM LOG] Column ${p} has NaNs, converting to nulls`);let v=new Array(E);for(let C=0;C<E;C++){let W=I[C];v[C]=Number.isNaN(W)?null:W}l[p]=v}else l[p]=I}else if(_==="int64"){let I=new BigInt64Array(e,V,E),O=new Array(E),v=-9223372036854775808n;for(let C=0;C<E;C++){let W=I[C];O[C]=W===v?null:Number(W)}l[p]=O}else if(_==="int32"){let I=new Int32Array(e,V,E),O=new Array(E);for(let v=0;v<E;v++){let C=I[v];C===-2147483648?O[v]=null:O[v]=C}l[p]=O}else{let I=new Float32Array(e,V,E),O=new Array(E);for(let v=0;v<E;v++){let C=I[v];O[v]=isNaN(C)?null:C}l[p]=O}else if(_==="string"||_==="list"){let I=_==="list",O=(E+1)*4,v=B-O,C=new Uint8Array(e,V,v).slice(),W=new Uint32Array(e,V+v,E+1).slice();l[p]={_arrowString:!0,offsets:W,bytes:C,isList:_==="list",nullable:T===1}}}return{_format:"columnar",columns:i,rowCount:f,data:l}}_readVarint(e,r){let n=0,t=0,o=0;for(;;){let c=e.getUint8(r+o);if(o++,n|=(c&127)<<t,(c&128)===0)break;t+=7}return[n,o]}_parseLegacyResult(e,r,n){let t=new DataView(e,r,n),o=new TextDecoder,c=t.getUint32(4,!0),s=Number(t.getBigUint64(8,!0)),a=t.getUint32(24,!0),i=t.getUint32(32,!0),l=[],f={};for(let h=0;h<c;h++){let y=36+h*16,m=t.getUint32(y,!0),d=t.getUint32(y+4,!0),g=t.getUint32(y+8,!0),w=t.getUint32(y+12,!0),A=new Uint8Array(e,r+i+d,g),p=o.decode(A);l.push(p);let b=Object.keys(ze).find(S=>ze[S]===m).toLowerCase(),F=r+a+w;if(b==="float64"||b==="int64"||b==="int32"||b==="float32")b==="float64"?f[p]=new Float64Array(e,F,s).slice():b==="int64"?f[p]=new Float64Array(e,F,s).slice():b==="int32"?f[p]=new Int32Array(e,F,s).slice():b==="float32"&&(f[p]=new Float32Array(e,F,s).slice());else if(b==="string"||b==="list"){let S=new Uint32Array(s+1),_=0;S[0]=0;let T=F,$=0;for(let x=0;x<s;x++){let B=t.getUint32(T+x*8+4,!0);$+=B,S[x+1]=$}let k=F+s*8,E=new Uint8Array(e,k,$).slice();f[p]={_arrowString:!0,offsets:S,bytes:E,isList:b==="list"}}}return{_format:"columnar",columns:l,rowCount:s,data:f}}clear(){let e=Q();e&&e.clearTables(),this._registered.clear()}},Fe=null;function Le(){return Fe||(Fe=new $e),Fe}var Ee={showVersions:/^\s*SHOW\s+VERSIONS\s+FOR\s+(\w+)\s*$/i,restoreTable:/^\s*RESTORE\s+(\w+)\s+TO\s+VERSION\s+(\d+)\s*$/i,versionAsOf:/FROM\s+(\w+)\s+VERSION\s+AS\s+OF\s+(\d+)/i};function Ge(u){let e;return(e=u.match(Ee.showVersions))?{type:"SHOW_VERSIONS",table:e[1]}:(e=u.match(Ee.restoreTable))?{type:"RESTORE_TABLE",table:e[1],version:parseInt(e[2],10)}:(e=u.match(Ee.versionAsOf))?{type:"SELECT_VERSION",table:e[1],version:parseInt(e[2],10),sql:u}:null}function lt(u){let e=/^(SELECT|FROM|WHERE|JOIN|LEFT|RIGHT|INNER|OUTER|ON|AND|OR|NOT|IN|LIKE|BETWEEN|GROUP|ORDER|BY|HAVING|LIMIT|OFFSET|UNION|EXCEPT|INTERSECT|AS|NULL|TRUE|FALSE|IS|CASE|WHEN|THEN|ELSE|END|DISTINCT|ALL|ASC|DESC|CREATE|DROP|INSERT|UPDATE|DELETE|INTO|VALUES|TABLE|INDEX|VIEW|SET|WITH|RECURSIVE)$/i,r=/read_lance\s*\(\s*'([^']+)'\s*\)(?:\s+AS\s+(\w+)|\s+(\w+))?/gi,n=[],t;for(;(t=r.exec(u))!==null;){let o=t[2],c=t[3];c&&e.test(c)&&(c=null);let s=o||c||`_tbl${n.length}`,a=t[0];t[3]&&e.test(t[3])&&(a=`read_lance('${t[1]}')`),console.log(`[Worker] extractReadLanceUrls: found "${a}" -> alias "${s}"`),n.push({fullMatch:a,url:t[1],alias:s})}return console.log(`[Worker] extractReadLanceUrls: found ${n.length} URLs`),n}function ct(u,e){let r=u;for(let{fullMatch:n,alias:t}of e)console.log(`[Worker] rewriteSqlWithAliases: replacing "${n}" with "${t}"`),r=r.replace(n,t);return console.log(`[Worker] rewriteSqlWithAliases: result = "${r}"`),r}async function ft(u,e=1e4){try{console.log(`[Worker] Fetching remote Lance: ${u}`);let r=`${u}/.meta.json`,n=null,t=[],o=[];try{let i=await fetch(r);if(i.ok){let l=await i.json();n=l.schema,t=l.fragments||[],o=n.map(f=>{let h=f.type;if(h.startsWith("vector[")){let y=h.match(/vector\[(\d+)\]/);return{type:"vector",dim:y?parseInt(y[1],10):0}}return h==="float64"||h==="double"?"float64":h==="float32"?"float32":h.includes("int64")?"int64":h.includes("int")?"int32":h==="string"?"string":"unknown"}),console.log(`[Worker] Loaded sidecar: ${n.length} columns, ${t.length} fragments`)}}catch(i){console.log(`[Worker] No sidecar available: ${i.message}`)}if(!n){let i=0,l=[1,5,10,20,50,100];for(let m of l)try{(await fetch(`${u}/_versions/${m}.manifest`,{method:"HEAD"})).ok&&(i=m)}catch{}if(i>0)for(let m=i+1;m<=i+50;m++)try{if((await fetch(`${u}/_versions/${m}.manifest`,{method:"HEAD"})).ok)i=m;else break}catch{break}if(i===0)return console.error(`[Worker] No manifest found for ${u}`),null;let f=await fetch(`${u}/_versions/${i}.manifest`);if(!f.ok)return null;let h=new Uint8Array(await f.arrayBuffer()),y=ut(h);n=y.schema,t=y.fragments,o=n.map(m=>m.type||"unknown")}if(!n||n.length===0)return console.error(`[Worker] No schema found for ${u}`),null;if(t.length===0)return console.error(`[Worker] No fragments found for ${u}`),null;let c=t[0].data_files?.[0]||`${t[0].id}.lance`,s=`${u}/data/${c}`;return await gt(s,n,o,e)}catch(r){return console.error("[Worker] Failed to fetch remote Lance:",r),null}}function ut(u){let e=new DataView(u.buffer,u.byteOffset),r=[],n=[],t=e.getUint32(0,!0),o=4+t,c;if(o+4<u.length){let l=e.getUint32(o,!0);l>0&&o+4+l<=u.length?c=u.slice(o+4,o+4+l):c=u.slice(4,4+t)}else c=u.slice(4,4+t);let s=0,a=()=>{let l=0,f=0;for(;s<c.length;){let h=c[s++];if(l|=(h&127)<<f,(h&128)===0)break;f+=7}return l},i=l=>{l===0?a():l===2?s+=a():l===5?s+=4:l===1&&(s+=8)};for(;s<c.length;){let l=a(),f=l>>3,h=l&7;if(f===1&&h===2){let y=a(),m=s+y,d=null,g=null,w=null;for(;s<m;){let A=a(),p=A>>3,b=A&7;if(b===0){let F=a();p===3&&(g=F)}else if(b===2){let F=a(),S=c.slice(s,s+F);s+=F,p===2?d=new TextDecoder().decode(S):p===5&&(w=new TextDecoder().decode(S))}else i(b)}d&&r.push({name:d,id:g,type:w})}else if(f===2&&h===2){let y=a(),m=s+y,d=null,g=null,w=0;for(;s<m;){let A=a(),p=A>>3,b=A&7;if(b===0){let F=a();p===1?d=F:p===4&&(w=F)}else if(b===2){let F=a(),S=c.slice(s,s+F);if(s+=F,p===2){let _=0;for(;_<S.length;){let T=S[_++],$=T>>3,k=T&7;if(k===2){let E=0,x=0;for(;_<S.length;){let B=S[_++];if(E|=(B&127)<<x,(B&128)===0)break;x+=7}$===1&&(g=new TextDecoder().decode(S.slice(_,_+E))),_+=E}else if(k===0)for(;_<S.length&&(S[_++]&128)!==0;);else k===5?_+=4:k===1&&(_+=8)}}}else i(b)}g&&n.push({id:d,data_files:[g],num_rows:w})}else i(h)}return{schema:r,fragments:n}}async function J(u,e,r){let n=await fetch(u,{headers:{Range:`bytes=${e}-${r}`}});if(!n.ok&&n.status!==206)throw new Error(`Range request failed: HTTP ${n.status}`);return new Uint8Array(await n.arrayBuffer())}function K(u,e){let r=0,n=0,t=0;for(;e+t<u.length;){let o=u[e+t];if(t++,r|=(o&127)<<n,(o&128)===0)break;n+=7}return{value:r,bytesRead:t}}function ht(u){let e=[],r=[],n=0,t=0;for(;t<u.length;){let{value:o,bytesRead:c}=K(u,t);t+=c;let s=o>>3,a=o&7;if(s===2&&a===2){let{value:i,bytesRead:l}=K(u,t);t+=l;let f=t+i;for(;t<f;){let{value:h,bytesRead:y}=K(u,t);t+=y;let m=h>>3,d=h&7;if(m===1&&d===2){let{value:g,bytesRead:w}=K(u,t);t+=w;let A=t+g;for(;t<A;){let{value:p,bytesRead:b}=K(u,t);t+=b,e.push(p)}}else if(m===2&&d===2){let{value:g,bytesRead:w}=K(u,t);t+=w;let A=t+g;for(;t<A;){let{value:p,bytesRead:b}=K(u,t);t+=b,r.push(p)}}else if(m===3&&d===0){let{value:g,bytesRead:w}=K(u,t);t+=w,n=g}else if(d===0){let{bytesRead:g}=K(u,t);t+=g}else if(d===2){let{value:g,bytesRead:w}=K(u,t);t+=w+g}else d===5?t+=4:d===1&&(t+=8)}break}else if(a===0){let{bytesRead:i}=K(u,t);t+=i}else if(a===2){let{value:i,bytesRead:l}=K(u,t);t+=l+i}else a===5?t+=4:a===1&&(t+=8)}return{bufferOffsets:e,bufferSizes:r,length:n}}async function dt(u,e,r,n,t){let c=await J(u,t-40,t-1),s=new DataView(c.buffer),a=String.fromCharCode(c[36],c[37],c[38],c[39]);if(a!=="LANC")throw new Error(`Invalid Lance magic: ${a}`);let i=Number(s.getBigUint64(0,!0)),l=Number(s.getBigUint64(8,!0)),f=s.getUint32(28,!0);console.log(`[Worker] Range: footer parsed - ${f} columns, metaStart=${i}, offsetsStart=${l}`);let h=f*16,y=await J(u,l,l+h-1),m=new DataView(y.buffer),d=[];for(let _=0;_<f;_++){let T=Number(m.getBigUint64(_*16,!0)),$=Number(m.getBigUint64(_*16+8,!0));d.push({pos:T,len:$})}let g=d[0]?.pos||i,w=l-1,A=await J(u,g,w),p={},b=[],F=0;for(let _=0;_<e.length&&_<f;_++){let T=e[_].name,$=r[_];b.push(T);let k=d[_].pos-g,E=d[_].len,x=A.slice(k,k+E),{bufferOffsets:B,bufferSizes:H,length:V}=ht(x);_===0&&(F=V);let I=Math.min(V,n),O=typeof $=="object"?`${$.type}[${$.dim}]`:$;console.log(`[Worker] Range: column ${_} (${T}): type=${O}, rows=${V}, buffers=${B.length}`);try{if($==="string"&&B.length>=2){let v=B[0],C=H[0],W=B[1],z=H[1],D=Math.floor(C/V),M=I*D,Xe=await J(u,v,v+M-1),Oe=new DataView(Xe.buffer),ce=[];for(let ne=0;ne<I;ne++)D===4?ce.push(Oe.getInt32(ne*4,!0)):ce.push(Number(Oe.getBigInt64(ne*8,!0)));let et=ce[I-1]||0,Re=Math.min(et,z);if(Re>0){let ne=await J(u,W,W+Re-1),tt=new TextDecoder("utf-8"),Me=[],Ue=0;for(let pe=0;pe<I;pe++){let Ne=ce[pe],nt=ne.slice(Ue,Ne);Me.push(tt.decode(nt)),Ue=Ne}p[T]=Me}else p[T]=Array(I).fill("")}else if(($==="float64"||$==="double")&&B.length>=1){let v=B[0],C=I*8,W=await J(u,v,v+C-1);p[T]=new Float64Array(W.buffer).slice(0,I)}else if($==="int64"&&B.length>=1){let v=B[0],C=I*8,W=await J(u,v,v+C-1),z=new BigInt64Array(W.buffer),D=new Float64Array(I);for(let M=0;M<I;M++)D[M]=Number(z[M]);p[T]=D}else if($==="int32"&&B.length>=1){let v=B[0],C=I*4,W=await J(u,v,v+C-1),z=new Int32Array(W.buffer),D=new Float64Array(I);for(let M=0;M<I;M++)D[M]=z[M];p[T]=D}else if($==="float32"&&B.length>=1){let v=B[0],C=I*4,W=await J(u,v,v+C-1),z=new Float32Array(W.buffer),D=new Float64Array(I);for(let M=0;M<I;M++)D[M]=z[M];p[T]=D}else if(typeof $=="object"&&$.type==="vector"&&$.dim>0&&B.length>=1){let v=$.dim,C=B[0],W=I*v,z=W*4;console.log(`[Worker] Range: Reading vector ${T}: dim=${v}, rows=${I}, bytes=${z}`);let D=await J(u,C,C+z-1),M=new Float32Array(D.buffer,0,W);p[T]=M.slice(),p[`__${T}_dim`]=v}else $==="vector"||typeof $=="string"&&($.includes("list")||$.includes("vector"))?p[T]=new Float32Array(0):p[T]=new Float64Array(I).fill(0)}catch(v){console.warn(`[Worker] Range: Failed to read column ${T}: ${v.message}`),$==="string"?p[T]=Array(I).fill(""):p[T]=new Float64Array(I).fill(0)}}let S=Math.min(F,n);return console.log(`[Worker] Range: Read ${S} rows from ${b.length} columns via HTTP Range requests`),{columns:p,rowCount:S,columnNames:b}}async function gt(u,e,r,n){if(console.log(`[Worker] Fetching fragment: ${u}`),!L&&(await X(),!L))throw new Error("WASM not loaded");let t=await fetch(u,{method:"HEAD"});if(!t.ok)throw new Error(`Failed to check fragment size: HTTP ${t.status}`);let o=parseInt(t.headers.get("Content-Length")||"0",10),c=100*1024*1024;if(o>c)return console.log(`[Worker] Large fragment (${(o/1024/1024).toFixed(1)}MB) - using HTTP Range requests`),await dt(u,e,r,n,o);let s=await fetch(u);if(!s.ok)throw new Error(`Failed to fetch fragment: HTTP ${s.status}`);let a=new Uint8Array(await s.arrayBuffer());if(console.log(`[Worker] Fetched fragment: ${a.length} bytes`),a.length<40)throw new Error("Fragment too small");let i=String.fromCharCode(a[a.length-4],a[a.length-3],a[a.length-2],a[a.length-1]);if(i!=="LANC")throw new Error(`Invalid Lance magic: ${i}`);let l=L.alloc(a.length);if(!l||l<0)throw new Error("Failed to allocate WASM memory for fragment");new Uint8Array(R.buffer,l,a.length).set(a);let f=L.openFile(l,a.length);if(f!==0)throw new Error(`WASM openFile failed: ${f}`);let h=L.getNumColumns(),y=Number(L.getRowCount(0)),m=Math.min(y,n);console.log(`[Worker] Fragment has ${h} columns, ${y} rows, reading ${m}`);let d={},g=[];for(let w=0;w<e.length&&w<h;w++){let A=e[w].name,p=r[w];g.push(A);try{if(p==="float64"||p==="double"){let b=L.allocFloat64Buffer(m);if(b){let F=L.readFloat64Column(w,b,m);d[A]=new Float64Array(R.buffer,b,F).slice()}else d[A]=new Float64Array(m).fill(0)}else if(p==="int64"){let b=L.allocInt64Buffer(m);if(b){let F=L.readInt64Column(w,b,m),S=new BigInt64Array(R.buffer,b,F),_=new Float64Array(F);for(let T=0;T<F;T++)_[T]=Number(S[T]);d[A]=_}else d[A]=new Float64Array(m).fill(0)}else if(p==="int32"){let b=L.allocInt32Buffer(m);if(b){let F=L.readInt32Column(w,b,m),S=new Int32Array(R.buffer,b,F),_=new Float64Array(F);for(let T=0;T<F;T++)_[T]=S[T];d[A]=_}else d[A]=new Float64Array(m).fill(0)}else if(p==="float32"){let b=L.alloc(m*4);if(b&&b>0){let F=L.readFloat32Column(w,b,m),S=new Float32Array(R.buffer,b,F),_=new Float64Array(F);for(let T=0;T<F;T++)_[T]=S[T];d[A]=_}else d[A]=new Float64Array(m).fill(0)}else p==="string"?d[A]=Array(m).fill("(string data)"):p==="vector"?d[A]=[]:d[A]=[]}catch(b){console.warn(`[Worker] Failed to read column ${A}:`,b),d[A]=[]}}return L.closeFile(),console.log(`[Worker] Read ${m} rows from ${g.length} columns`),{columns:d,rowCount:m,columnNames:g}}async function qe(u,e=1e4){try{console.log(`[Worker] Loading OPFS Lance: ${u}`);let r=u.split("/").filter(S=>S),n=r.pop(),t=await We(r),c=await(await t.getFileHandle(n)).getFile(),s=new Uint8Array(await c.arrayBuffer()),a=null;try{let T=await(await(await t.getFileHandle(`${n}.schema`)).getFile()).text();a=JSON.parse(T),console.log(`[Worker] Loaded schema sidecar: ${a.columns?.length} columns`)}catch{}if(!s||s.length===0)return console.error(`[Worker] Empty OPFS file: ${u}`),null;if(s.length<40)return console.error(`[Worker] File too small for Lance format: ${u}`),null;let i=String.fromCharCode(s[s.length-4],s[s.length-3],s[s.length-2],s[s.length-1]);if(i!=="LANC")return console.error(`[Worker] Invalid Lance magic in ${u}: ${i}`),null;let l=new DataView(s.buffer,s.byteOffset),f=s.length-40,h=Number(l.getBigUint64(f+8,!0)),y=l.getUint32(f+28,!0),m=[],d=[];for(let S=0;S<y;S++){let _=h+S*16;if(_+16>s.length){console.log(`[Worker] OPFS column ${S}: offset out of bounds (offsetPos=${_})`);continue}let T=Number(l.getBigUint64(_,!0)),$=Number(l.getBigUint64(_+8,!0));if(T>=s.length||T+$>s.length){console.log(`[Worker] OPFS column ${S}: metadata bounds invalid (pos=${T}, len=${$})`);continue}let k=`col_${S}`,E="unknown";a?.columns?.[S]&&(k=a.columns[S].name,E=a.columns[S].type||"unknown"),m.push({name:k,type:E,metaPos:T,metaLen:$}),d.push(E),console.log(`[Worker] OPFS column ${S}: name=${k}, type=${E}, metaPos=${T}, metaLen=${$}`)}if(!L&&(await X(),!L))throw new Error("WASM not loaded");let g=L.alloc(s.length);if(!g||g<0)throw new Error("Failed to allocate WASM memory for OPFS file");if(new Uint8Array(R.buffer,g,s.length).set(s),L.openFile(g,s.length)===0)throw new Error("WASM openFile failed: invalid Lance file");let A=Number(L.getRowCount(0)),p=Math.min(A,e);console.log(`[Worker] OPFS file has ${y} columns, ${A} rows, reading ${p}`);let b={},F=[];for(let S=0;S<m.length;S++){let{name:_,type:T}=m[S];if(F.push(_),T==="float64"||T==="double"){let $=L.allocFloat64Buffer(p);if($){let k=L.readFloat64Column(S,$,p);b[_]=new Float64Array(R.buffer,$,k).slice()}else b[_]=new Float64Array(p).fill(0)}else if(T==="int64"){let $=L.allocInt64Buffer(p);if($){let k=L.readInt64Column(S,$,p),E=new BigInt64Array(R.buffer,$,k),x=new Float64Array(k);for(let B=0;B<k;B++)x[B]=Number(E[B]);b[_]=x}else b[_]=new Float64Array(p).fill(0)}else if(T==="string"){let $=L.getStringCount?Number(L.getStringCount(S)):0;if(console.log(`[Worker] OPFS column ${S} (${_}): stringCount=${$}`),$>0&&L.readStringAt&&L.allocStringBuffer){let k=[],x=L.allocStringBuffer(4096);if(x){let B=new TextDecoder("utf-8");for(let H=0;H<p;H++){let V=L.readStringAt(S,H,x,4096);if(V>0){let I=Math.min(V,4096),O=new Uint8Array(R.buffer,x,I);k.push(B.decode(O.slice()))}else k.push("")}b[_]=k,console.log(`[Worker] Read ${k.length} strings for column ${_}, first: "${k[0]}"`)}else console.warn(`[Worker] Failed to allocate string buffer for column ${_}`),b[_]=Array(p).fill("")}else console.warn(`[Worker] String column ${_}: no WASM string functions or zero count`),b[_]=Array(p).fill("")}else if(T.includes("vector")||T.includes("list")||T==="float32")if(L.getVectorInfo&&L.readVectorAt&&L.allocFloat32Buffer){let $=L.getVectorInfo(S);if($>0){let k=Number($>>32n),E=Number($&0xFFFFFFFFn),x=Math.min(p,k);if(console.log(`[Worker] OPFS vector column ${_}: dim=${E}, rows=${k}, reading ${x}`),E>0&&x>0){let B=x*E,H=L.allocFloat32Buffer(B);if(H){for(let I=0;I<x;I++){let O=I*E;L.readVectorAt(S,I,H+O,E)}let V=new Float32Array(R.buffer,H,B).slice();b[_]=V,b[`__${_}_dim`]=E}else console.warn(`[Worker] Failed to allocate vector buffer for column ${_}`),b[_]=new Float32Array(0)}else b[_]=new Float32Array(0)}else console.warn(`[Worker] getVectorInfo returned 0 for column ${_}`),b[_]=new Float32Array(0)}else console.warn(`[Worker] No WASM vector functions for column ${_}`),b[_]=new Float32Array(0);else{let $=L.allocFloat64Buffer(p);if($){let k=L.readFloat64Column(S,$,p);k>0?b[_]=new Float64Array(R.buffer,$,k).slice():b[_]=Array(p).fill("")}else b[_]=[]}}return L.closeFile(),console.log(`[Worker] OPFS read ${p} rows from ${F.length} columns: ${F.join(", ")}`),{columns:b,rowCount:p,columnNames:F}}catch(r){return console.error("[Worker] Failed to load OPFS Lance:",r),null}}async function Qe(u,e){if(!L&&(await X(),!L))throw new Error("WASM not loaded");let r=e.replace(/--[^\n]*/g,"").replace(/\/\*[\s\S]*?\*\//g,"").trim(),n=Le(),t=lt(r);for(let{url:s,alias:a}of t){let i=n.hasTable(a);if(console.log(`[Worker] Processing URL mapping: alias=${a}, url=${s.substring(0,50)}..., alreadyRegistered=${i}`),i){console.log(`[Worker] Table ${a} already registered, skipping`);continue}if(s.startsWith("opfs://")){let y=s.replace("opfs://","").replace(".lance","");if(n.hasTable(y)){console.log(`[Worker] Aliasing ${a} to existing table ${y}`),n.aliasTable(y,a);continue}}let l=null,f=null;try{if(s.startsWith("https://")||s.startsWith("http://"))console.log(`[Worker] Fetching remote Lance: ${s} as ${a}`),l=await ft(s);else if(s.startsWith("opfs://")){let h=s.replace("opfs://","");console.log(`[Worker] Loading OPFS Lance: ${h} as ${a}`),l=await qe(h)}else console.log(`[Worker] Loading OPFS Lance (no prefix): ${s} as ${a}`),l=await qe(s)}catch(h){f=h,console.error(`[Worker] Failed to load ${s}:`,h)}if(l){let h=Object.keys(l.columns),y=h.filter(d=>{let g=l.columns[d];return g&&(Array.isArray(g),g.length>0)});console.log(`[Worker] Registering table ${a} with ${l.rowCount} rows, columns: ${h.join(", ")}, non-empty: ${y.join(", ")}`);try{n.registerTable(a,l.columns,l.rowCount,s)}catch(d){throw console.error(`[Worker] Registration error for ${a}:`,d),new Error(`Failed to register table ${a}: ${d.message}`)}let m=n.hasTable(a);if(console.log(`[Worker] hasTable(${a}) = ${m}`),!m)throw new Error(`Failed to register table ${a} from ${s} - hasTable returned false`)}else{let h=f?f.message:"file may not exist or returned empty data";throw new Error(`Could not load read_lance('${s}'): ${h}`)}}let o=t.length>0?ct(r,t):r,c=n.getTableNames(o);for(let s of c){let a=u.tables.get(s);if(!a)continue;let i=u._columnarBuffer?.get(s),l=i?.__length||0,f=`${s}:${a.fragments?.length||0}:${l}:${a.deletionVector?.length||0}`;if(n.hasTableWithVersion(s,f))continue;let h=a.fragments.length>0,y=l>0;if(h){let m=[];for(let d of a.fragments){let g=await yt(d);g&&m.push(g)}if(n.registerTableFromFiles(s,a.fragments,f),y){let d={};for(let g of a.schema){let w=i[g.name];w&&ArrayBuffer.isView(w)&&(d[g.name]=w.subarray(0,l))}n.appendTableMemory(s,d,l)}}else if(y){let m=await u.selectColumnar(s);if(m){let{columns:d,rowCount:g}=m;n.registerTable(s,d,g,f)}}}return n.execute(o)}var L=null,R=null,ae=new Map,wt=1;async function We(u){let e=await navigator.storage.getDirectory();e=await e.getDirectoryHandle("lanceql",{create:!0});for(let r of u)e=await e.getDirectoryHandle(r,{create:!0});return e}function mt(){return{env:{opfs_open:(u,e)=>{try{let r=new Uint8Array(R.buffer,u,e),n=new TextDecoder().decode(r);for(let[t,o]of ae.entries())if(o._path===n)return t;return console.warn("[LanceQLWorker] WASM tried to open unregistered path:",n),0}catch(r){return console.error("[LanceQLWorker] Error:",r),0}},opfs_read:(u,e,r,n)=>{let t=ae.get(u);if(!t)return 0;try{let o=new Uint8Array(R.buffer,e,r);return t.read(o,{at:Number(n)})}catch{return 0}},opfs_size:u=>{let e=ae.get(u);if(!e)return BigInt(0);try{return BigInt(e.getSize())}catch{return BigInt(0)}},opfs_close:u=>{},__assert_fail:(u,e,r,n)=>{let o=new TextDecoder().decode(new Uint8Array(R.buffer,u).subarray(0,100));console.error(`[WASM ASSERT] ${o} at line ${r}`)},js_log:(u,e)=>{let n=new TextDecoder().decode(new Uint8Array(R.buffer,u,e));console.log(`[WASM LOG] ${n}`);for(let t of xe)t.postMessage({type:"log",message:n,marker:"__WASM_LOG_BRIDGE__"})}}}}async function yt(u){try{let e=u.split("/").filter(s=>s),r=e.pop(),o=await(await(await We(e)).getFileHandle(r)).createSyncAccessHandle(),c=wt++;return o._path=u,ae.set(c,o),c}catch(e){return console.warn("[LanceQLWorker] Failed to register OPFS file:",u,e),0}}function en(u){let e=ae.get(u);if(e){try{e.close()}catch{}ae.delete(u)}}async function X(){if(L)return L;try{let u=new URL("./lanceql.wasm",import.meta.url);u.searchParams.set("v",Date.now().toString());let r=await(await fetch(u)).arrayBuffer(),n=mt();return L=(await WebAssembly.instantiate(r,n)).instance.exports,R=L.memory,console.log("[LanceQLWorker] WASM loaded with OPFS support"),L}catch(u){return console.warn("[LanceQLWorker] WASM not available:",u.message),null}}function Q(){return L}function j(){return R}var ve=0,Je=0,pt=1024*1024;function bt(u){if(!L)return 0;if(u<=Je&&ve!==0)return ve;let e=Math.max(u,pt),r=L.alloc(e);return r&&(ve=r,Je=e),r}async function tn(u){let e=await X();if(!e)return 0;try{let r=u.split("/").filter(f=>f),n=r.pop(),c=await(await(await We(r)).getFileHandle(n)).createSyncAccessHandle(),s=c.getSize(),a=bt(s);if(!a)return c.close(),0;let i=new Uint8Array(R.buffer,a,s),l=c.read(i,{at:0});return c.close(),l!==s?0:e.openFile(a,s)}catch(r){return console.warn("[LanceQLWorker] Failed to load fragment:",u,r),0}}async function _t(u,e){let r=e.split("/").filter(t=>t),n=u;for(let t=0;t<r.length-1;t++)n=await n.getDirectoryHandle(r[t],{create:!1});return await n.getFileHandle(r[r.length-1],{create:!1})}var Ie=null;async function At(u){let e=Ce.get(u);if(e)return e;Ie||(Ie=await navigator.storage.getDirectory());let t=await(await(await _t(Ie,u)).getFile()).arrayBuffer();return e=new Uint8Array(t),e&&Ce.set(u,e,e.byteLength),e}async function nn(u,e,r){if(!await At(u))return null;let t=L;switch(r){case"sum":return t.opfsSumFloat64Column(e);case"min":return t.opfsMinFloat64Column(e);case"max":return t.opfsMaxFloat64Column(e);case"avg":return t.opfsAvgFloat64Column(e);case"count":return Number(t.opfsCountRows());default:return null}}X();var Ce=new re,ke=new Map,Be=new Map,me=null,xe=new Set,se=null,te=0,St=1024,ye=new Map,Ye=1;async function Z(u=null){return me||(me=new we),await me.open(u),me}async function P(u,e={},r=null){let n=r?.keyId||"none",t=`${u}:${n}:${JSON.stringify(e)}`;if(!ke.has(t)){let o=new de(u,e);await o.open(r),ke.set(t,o)}return ke.get(t)}async function N(u){if(!Be.has(u)){let e=new oe(u,Ce);await e.open(),Be.set(u,e)}return Be.get(u)}function Tt(u,e,r){if(r&&r._format==="wasm_binary"){u.postMessage({id:e,result:{_format:"wasm_binary",buffer:r.buffer,columns:r.columns,rowCount:r.rowCount,schema:r.schema}},[r.buffer]);return}if(r&&r._format==="columnar"&&r.data){let n=r.columns,t=r.rowCount;if(t<1e5){let y=[],m={},d=new Set;for(let g of n){let w=r.data[g];if(ArrayBuffer.isView(w)){let A=w.byteOffset!==0||w.byteLength<w.buffer.byteLength,p=d.has(w.buffer);if(A||p){let b=new w.constructor(w);m[g]=b,y.push(b.buffer)}else m[g]=w,y.push(w.buffer),d.add(w.buffer)}else w&&w._arrowString?(m[g]=w,w.offsets&&w.offsets.buffer&&!d.has(w.offsets.buffer)&&(y.push(w.offsets.buffer),d.add(w.offsets.buffer)),w.bytes&&w.bytes.buffer&&!d.has(w.bytes.buffer)&&(y.push(w.bytes.buffer),d.add(w.bytes.buffer))):m[g]=w}u.postMessage({id:e,result:{_format:"columnar",columns:n,rowCount:t,data:m}},y);return}let o=[],c=[],s=0;for(let y of n){let m=r.data[y];ArrayBuffer.isView(m)?(o.push({name:y,arr:m}),s+=m.byteLength):Array.isArray(m)&&c.push({name:y,arr:m})}let a=s>0?new ArrayBuffer(s):null,i={},l=0;if(a){let y=new Uint8Array(a);for(let{name:m,arr:d}of o){let g=new Uint8Array(d.buffer,d.byteOffset,d.byteLength);y.set(g,l),i[m]={offset:l,length:d.length,type:d.constructor.name},l+=d.byteLength}}let f={};for(let{name:y,arr:m}of c)f[y]=m;let h=[];a&&h.push(a),u.postMessage({id:e,result:{_format:"packed",columns:n,rowCount:t,packedBuffer:a,colOffsets:i,stringData:f}},h);return}if(se&&r!==void 0){let n=JSON.stringify(r);if(n.length>St){let t=q.encode(n);if(te+t.length<=se.byteLength){new Uint8Array(se,te,t.length).set(t),u.postMessage({id:e,sharedOffset:te,sharedLength:t.length}),te+=t.length,te>se.byteLength/2&&(te=0);return}}}u.postMessage({id:e,result:r})}async function Ze(u,e){if(e.type==="initSharedBuffer"){se=e.buffer,te=0,console.log("[LanceQLWorker] SharedArrayBuffer initialized:",se.byteLength,"bytes");return}let{id:r,method:n,args:t}=e;try{let o;if(n==="ping")o="pong";else if(n==="open")await P(t.name,t.options,t.encryption),o=!0;else if(n==="get")o=await(await P(t.name)).get(t.key);else if(n==="set")await(await P(t.name)).set(t.key,t.value),o=!0;else if(n==="delete")await(await P(t.name)).delete(t.key),o=!0;else if(n==="keys")o=await(await P(t.name)).keys();else if(n==="clear")await(await P(t.name)).clear(),o=!0;else if(n==="filter")o=await(await P(t.name)).filter(t.key,t.query);else if(n==="find")o=await(await P(t.name)).find(t.key,t.query);else if(n==="search")o=await(await P(t.name)).search(t.key,t.text,t.limit);else if(n==="count")o=await(await P(t.name)).count(t.key,t.query);else if(n==="enableSemanticSearch")o=await(await P(t.name)).enableSemanticSearch(t.options);else if(n==="disableSemanticSearch")(await P(t.name)).disableSemanticSearch(),o=!0;else if(n==="hasSemanticSearch")o=(await P(t.name)).hasSemanticSearch();else if(n==="db:open")console.log(`[LanceQLWorker] db:open ${t.name}`),await N(t.name),o=!0;else if(n==="db:createTable")console.log(`[LanceQLWorker] db:createTable ${t.tableName}`),o=await(await N(t.db)).createTable(t.tableName,t.columns,t.ifNotExists),console.log(`[LanceQLWorker] db:createTable ${t.tableName} done`);else if(n==="db:dropTable"){console.log(`[LanceQLWorker] db:dropTable ${t.tableName}`),o=await(await N(t.db)).dropTable(t.tableName,t.ifExists);let s=q.encode(t.tableName);Le().clearTable(s,s.length)}else if(n==="db:insert")console.log(`[LanceQLWorker] db:insert into ${t.tableName}, rows: ${t.rows?.length}`),o=await(await N(t.db)).insert(t.tableName,t.rows),console.log("[LanceQLWorker] db:insert done");else if(n==="db:delete"){let c=await N(t.db),s=t.where?a=>evalWhere(t.where,a):()=>!0;o=await c.delete(t.tableName,s)}else if(n==="db:update"){let c=await N(t.db),s=t.where?a=>evalWhere(t.where,a):()=>!0;o=await c.update(t.tableName,t.updates,s)}else if(n==="db:select"){let c=await N(t.db),s={...t.options};t.where&&(s.where=a=>evalWhere(t.where,a)),o=await c.select(t.tableName,s)}else if(n==="db:exec"){let c=await N(t.db),s=Ge(t.sql);if(s?.type==="SHOW_VERSIONS"){let a=await c.listVersions(s.table);o={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:a.length,data:{version:new Float64Array(a.map(i=>i.version)),timestamp:a.map(i=>new Date(i.timestamp).toISOString()),operation:a.map(i=>i.operation),rowCount:new Float64Array(a.map(i=>i.rowCount))}}}else if(s?.type==="RESTORE_TABLE"){let a=await c.restoreToVersion(s.table,s.version);o={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([a.newVersion])}}}else if(s?.type==="SELECT_VERSION"){let a=await c.selectAtVersion(s.table,s.version,{});if(a.length>0){let i=Object.keys(a[0]),l={};for(let f of i)l[f]=a.map(h=>h[f]);o={_format:"columnar",columns:i,rowCount:a.length,data:l}}else o={_format:"columnar",columns:[],rowCount:0,data:{}}}else o=await Qe(c,t.sql);if(o&&o._format==="columnar"&&o.rowCount>=1e5){let a=Ye++;ye.set(a,o),o={_format:"cursor",cursorId:a,columns:o.columns,rowCount:o.rowCount}}}else if(n==="cursor:fetch"){let c=ye.get(t.cursorId);if(!c)throw new Error("Cursor not found");o=c,ye.delete(t.cursorId)}else if(n==="db:flush")console.log(`[LanceQLWorker] db:flush ${t.db}`),await(await N(t.db)).flush(),console.log(`[LanceQLWorker] db:flush ${t.db} done`),o=!0;else if(n==="db:compact")o=await(await N(t.db)).compact();else if(n==="db:listTables")o=(await N(t.db)).listTables();else if(n==="db:getTable")o=(await N(t.db)).getTable(t.tableName);else if(n==="db:scanStart")o=await(await N(t.db)).scanStart(t.tableName,t.options);else if(n==="db:scanNext")o=(await N(t.db)).scanNext(t.streamId);else if(n==="db:listVersions")o=await(await N(t.db)).listVersions(t.tableName);else if(n==="db:selectAtVersion"){let c=await N(t.db),s={...t.options};t.where&&(s.where=a=>evalWhere(t.where,a)),o=await c.selectAtVersion(t.tableName,t.version,s)}else if(n==="db:restoreTable")o=await(await N(t.db)).restoreToVersion(t.tableName,t.version);else if(n==="vault:open")await Z(t.encryption),o=!0;else if(n==="vault:get")o=await(await Z()).get(t.key);else if(n==="vault:set")await(await Z()).set(t.key,t.value),o=!0;else if(n==="vault:delete")await(await Z()).delete(t.key),o=!0;else if(n==="vault:keys")o=await(await Z()).keys();else if(n==="vault:has")o=await(await Z()).has(t.key);else if(n==="vault:tables"){let c=await Z();o=c._db?c._db.listTables():[]}else if(n==="vault:exec"){let s=(await Z())._db,a=Ge(t.sql);if(a?.type==="SHOW_VERSIONS"){let i=await s.listVersions(a.table);o={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:i.length,data:{version:new Float64Array(i.map(l=>l.version)),timestamp:i.map(l=>new Date(l.timestamp).toISOString()),operation:i.map(l=>l.operation),rowCount:new Float64Array(i.map(l=>l.rowCount))}}}else if(a?.type==="RESTORE_TABLE"){let i=await s.restoreToVersion(a.table,a.version);o={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([i.newVersion])}}}else if(a?.type==="SELECT_VERSION"){let i=await s.selectAtVersion(a.table,a.version,{});if(i.length>0){let l=Object.keys(i[0]),f={};for(let h of l)f[h]=i.map(y=>y[h]);o={_format:"columnar",columns:l,rowCount:i.length,data:f}}else o={_format:"columnar",columns:[],rowCount:0,data:{}}}else o=await Qe(s,t.sql);if(o&&o._format==="columnar"&&o.rowCount>=1e5){let i=Ye++;ye.set(i,o),o={_format:"cursor",cursorId:i,columns:o.columns,rowCount:o.rowCount}}}else if(n==="loadMinilmModel"){if(L||await X(),!L)throw new Error("WASM not loaded");if(L.minilm_weights_loaded&&L.minilm_weights_loaded()===1)o={loaded:!0,cached:!0};else{L.minilm_init&&L.minilm_init();let c="/examples/wasm/models/minilm-l6-v2.gguf",s="https://data.metal0.dev/models/minilm-l6-v2.gguf",a=t.url||c;console.log("[Worker] Downloading MiniLM model from:",a);let i=await fetch(a);if(!i.ok&&a===c&&(console.log("[Worker] Local model not found, trying CDN..."),i=await fetch(s)),!i.ok)throw new Error("MiniLM model download failed");let l=await i.arrayBuffer();console.log("[Worker] MiniLM downloaded:",l.byteLength,"bytes");let f=L.minilm_alloc_model_buffer(l.byteLength);if(f===0)throw new Error("Failed to allocate WASM memory for MiniLM");new Uint8Array(R.buffer).set(new Uint8Array(l),f);let y=L.minilm_load_model(l.byteLength);if(y!==0)throw new Error(`MiniLM load error: ${y}`);console.log("[Worker] MiniLM model loaded successfully"),o={loaded:!0,cached:!1,size:l.byteLength}}}else throw new Error(`Unknown method: ${n}`);Tt(u,r,o)}catch(o){let c=o.stack||o.message;c.includes("TableDoesNotExist")?c="Table does not exist":c.includes("ColumnDoesNotExist")?c="Column does not exist":c.includes("UnknownEmbeddingModel")&&(c="Unknown embedding model"),u.postMessage({id:r,error:c})}}var Ft=typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope;Ft?self.onconnect=u=>{let e=u.ports[0];xe.add(e),e.onmessage=r=>{Ze(e,r.data)},e.onmessageerror=r=>{console.error("[LanceQLWorker] Message error:",r)},X().then(()=>{e.postMessage({type:"ready"})}).catch(r=>{console.error("[LanceQLWorker] Failed to load WASM:",r),e.postMessage({type:"ready",error:"WASM load failed"})}),e.start(),console.log("[LanceQLWorker] New connection, total ports:",xe.size)}:(self.onmessage=u=>{Ze(self,u.data)},X().then(()=>{self.postMessage({type:"ready"})}).catch(u=>{console.error("[LanceQLWorker] Failed to load WASM:",u),self.postMessage({type:"ready",error:"WASM load failed"})}));console.log("[LanceQLWorker] Initialized");export{en as closeOPFSFile,Q as getWasm,j as getWasmMemory,tn as loadFragmentToWasm,yt as registerOPFSFile,nn as wasmAggregate};
//# sourceMappingURL=lanceql-worker.js.map
