var W=new Map;async function ee(h){return crypto.subtle.importKey("raw",new Uint8Array(h),{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function te(h,e){let n=crypto.getRandomValues(new Uint8Array(12)),t=new TextEncoder().encode(JSON.stringify(h)),r=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},e,t),i=new Uint8Array(12+r.byteLength);return i.set(n,0),i.set(new Uint8Array(r),12),i}async function ne(h,e){let n=h.slice(0,12),s=h.slice(12),t=await crypto.subtle.decrypt({name:"AES-GCM",iv:n},e,s),r=new TextDecoder;return JSON.parse(r.decode(t))}var U=null,Y=null,fe=new Map;function We(h){U=h}function $e(h){Y=h}var se=class{constructor(e,n={}){this.name=e,this.options=n,this._root=null,this._ready=!1,this._embedder=null,this._encryptionKeyId=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:n,keyBytes:s}=e;if(!W.has(n)){let t=await ee(s);W.set(n,t)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle(`lanceql-${this.name}`,{create:!0}),this._ready=!0}catch(n){throw console.error("[WorkerStore] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?W.get(this._encryptionKeyId):null}async get(e){await this._ensureOpen();try{let n=this._getCryptoKey(),s=n?".enc":".json",r=await(await this._root.getFileHandle(`${e}${s}`)).getFile();if(n){let i=await r.arrayBuffer();return ne(new Uint8Array(i),n)}else{let i=await r.text();return JSON.parse(i)}}catch(n){if(n.name==="NotFoundError")return;throw n}}async set(e,n){await this._ensureOpen();let s=this._getCryptoKey(),t=s?".enc":".json",i=await(await this._root.getFileHandle(`${e}${t}`,{create:!0})).createWritable();if(s){let o=await te(n,s);await i.write(o)}else await i.write(JSON.stringify(n));await i.close()}async delete(e){await this._ensureOpen();let s=this._getCryptoKey()?".enc":".json";try{await this._root.removeEntry(`${e}${s}`)}catch(t){if(t.name!=="NotFoundError")throw t}}async keys(){await this._ensureOpen();let n=this._getCryptoKey()?".enc":".json",s=[];for await(let[t]of this._root.entries())t.endsWith(n)&&s.push(t.slice(0,-n.length));return s}async clear(){await this._ensureOpen();let e=[];for await(let[n]of this._root.entries())e.push(n);for(let n of e)await this._root.removeEntry(n)}async filter(e,n){let s=await this.get(e);if(!Array.isArray(s))throw new Error(`Key '${e}' is not a collection`);return s.filter(t=>this._matchQuery(t,n))}async find(e,n){let s=await this.get(e);if(!Array.isArray(s))throw new Error(`Key '${e}' is not a collection`);return s.find(t=>this._matchQuery(t,n))}async search(e,n,s=10){let t=await this.get(e);if(!Array.isArray(t))throw new Error(`Key '${e}' is not a collection`);if(t.length===0)return[];if(this._embedder)return this._semanticSearch(t,e,n,s);let r=n.toLowerCase();return t.map(o=>{let c=this._extractText(o).toLowerCase(),a=r.split(/\s+/),l=a.filter(f=>c.includes(f)).length;return{item:o,score:l/a.length}}).filter(o=>o.score>0).sort((o,c)=>c.score-o.score).slice(0,s)}async _semanticSearch(e,n,s,t){let r=await this._embedder.embed(s),i=[],o=[],c=[];for(let a=0;a<e.length;a++){let l=e[a],f=this._extractText(l),u=`${this.name}:${n}:${f}`;if(fe.has(u)){let m=fe.get(u),g=this._cosineSimilarity(r,m);i.push({item:l,score:g})}else o.push(f),c.push(a)}if(o.length>0){let a;o.length>1&&this._embedder.embedBatch?a=await this._embedder.embedBatch(o):a=await Promise.all(o.map(l=>this._embedder.embed(l)));for(let l=0;l<a.length;l++){let f=c[l],u=e[f],m=o[l],g=a[l],d=`${this.name}:${n}:${m}`;fe.set(d,g);let y=this._cosineSimilarity(r,g);i.push({item:u,score:y})}}return i.sort((a,l)=>l.score-a.score).slice(0,t)}async enableSemanticSearch(e={}){let{model:n="minilm",onProgress:s}=e;if(U||(Y||(Y=this._initGPUTransformer(),$e(Y)),U=await Y,We(U)),!U)return null;let t=await U.loadModel(n,s);return this._embedder={model:n,dimensions:t.hiddenSize,embed:async r=>U.encodeText(r,n),embedBatch:async r=>U.encodeTextBatch(r,n)},{model:n,dimensions:t.hiddenSize,type:t.modelType||"text"}}async _initGPUTransformer(){try{let e=await import("./webgpu/index.js");if(!e.isWebGPUAvailable())return console.log("[WorkerStore] WebGPU not available"),null;let n=e.getGPUTransformer();return await n.init()?(console.log("[WorkerStore] WebGPU initialized"),n):(console.log("[WorkerStore] WebGPU init failed"),null)}catch(e){return console.error("[WorkerStore] WebGPU init error:",e),null}}disableSemanticSearch(){this._embedder&&U&&(U.unloadModel(this._embedder.model),this._embedder=null)}hasSemanticSearch(){return this._embedder!==null}async count(e,n=null){let s=await this.get(e);if(!Array.isArray(s))throw new Error(`Key '${e}' is not a collection`);return n?s.filter(t=>this._matchQuery(t,n)).length:s.length}async _ensureOpen(){this._ready||await this.open()}_matchQuery(e,n){for(let[s,t]of Object.entries(n)){let r=e[s];if(typeof t=="object"&&t!==null)for(let[i,o]of Object.entries(t))switch(i){case"$eq":if(r!==o)return!1;break;case"$ne":if(r===o)return!1;break;case"$lt":if(!(r<o))return!1;break;case"$lte":if(!(r<=o))return!1;break;case"$gt":if(!(r>o))return!1;break;case"$gte":if(!(r>=o))return!1;break;case"$in":if(!Array.isArray(o)||!o.includes(r))return!1;break;case"$nin":if(Array.isArray(o)&&o.includes(r))return!1;break;case"$contains":if(typeof r!="string"||!r.includes(o))return!1;break;case"$regex":if(typeof r!="string"||!new RegExp(o).test(r))return!1;break}else if(r!==t)return!1}return!0}_extractText(e){if(typeof e=="string")return e;let n=[];for(let[s,t]of Object.entries(e))typeof t=="string"&&n.push(t);return n.join(" ")}_cosineSimilarity(e,n){let s=0,t=0,r=0;for(let i=0;i<e.length;i++)s+=e[i]*n[i],t+=e[i]*e[i],r+=n[i]*n[i];return s/(Math.sqrt(t)*Math.sqrt(r))}};var ue=class{constructor(e="lanceql"){this.rootDir=e,this.root=null}async getRoot(){if(this.root)return this.root;if(typeof navigator>"u"||!navigator.storage?.getDirectory)throw new Error("OPFS not available");let e=await navigator.storage.getDirectory();return this.root=await e.getDirectoryHandle(this.rootDir,{create:!0}),this.root}async open(){return await this.getRoot(),this}async getDir(e){let n=await this.getRoot(),s=e.split("/").filter(r=>r),t=n;for(let r of s)t=await t.getDirectoryHandle(r,{create:!0});return t}async save(e,n){let s=e.split("/"),t=s.pop(),r=s.join("/"),o=await(r?await this.getDir(r):await this.getRoot()).getFileHandle(t,{create:!0});if(o.createSyncAccessHandle)try{let a=await o.createSyncAccessHandle();return a.truncate(0),a.write(n,{at:0}),a.flush(),a.close(),{path:e,size:n.byteLength}}catch{}let c=await o.createWritable();return await c.write(n),await c.close(),{path:e,size:n.byteLength}}async load(e){try{let n=e.split("/"),s=n.pop(),t=n.join("/"),c=await(await(await(t?await this.getDir(t):await this.getRoot()).getFileHandle(s)).getFile()).arrayBuffer();return new Uint8Array(c)}catch(n){if(n.name==="NotFoundError")return null;throw n}}async delete(e){try{let n=e.split("/"),s=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(s),!0}catch(n){if(n.name==="NotFoundError")return!1;throw n}}async list(e=""){try{let n=e?await this.getDir(e):await this.getRoot(),s=[];for await(let[t,r]of n.entries())s.push({name:t,type:r.kind});return s}catch{return[]}}async exists(e){try{let n=e.split("/"),s=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).getFileHandle(s),!0}catch{return!1}}async deleteDir(e){try{let n=e.split("/"),s=n.pop(),t=n.join("/");return await(t?await this.getDir(t):await this.getRoot()).removeEntry(s,{recursive:!0}),!0}catch{return!1}}},L=new ue;var D=new TextEncoder,N=new TextDecoder,Le={INT64:"int64",INT32:"int32",FLOAT64:"float64",FLOAT32:"float32",STRING:"string",BOOL:"bool",VECTOR:"vector"},ve=1,xe=2,Ce=3,Ee=4,he=5,de=6;function Ie(h){switch(h){case"int32":case"integer":return Int32Array;case"int64":return BigInt64Array;case"float32":case"real":return Float32Array;case"float64":case"double":return Float64Array;default:return null}}function Ne(h){switch(h){case"int32":case"integer":return ve;case"int64":return xe;case"float32":case"real":return Ce;case"float64":case"double":return Ee;case"string":case"text":return he;case"bool":case"boolean":return de;default:return he}}var re=class{constructor(e){this.schema=e,this.columns=new Map,this.rowCount=0,this._useBinary=!0}addRows(e){if(e.length!==0){if(this.rowCount===0)for(let n of this.schema){let s=Ie(n.dataType);s?this.columns.set(n.name,{type:"typed",dataType:n.dataType,data:new s(Math.max(e.length,1024)),length:0}):this.columns.set(n.name,{type:"array",dataType:n.dataType,data:[],length:0})}for(let n of this.schema){let s=this.columns.get(n.name);if(s.type==="typed"){let t=s.length+e.length;if(t>s.data.length){let r=Math.max(t,s.data.length*2),i=new s.data.constructor(r);i.set(s.data),s.data=i}for(let r=0;r<e.length;r++){let i=e[r][n.name];s.data[s.length+r]=i??0}s.length+=e.length}else{for(let t=0;t<e.length;t++)s.data.push(e[t][n.name]??null);s.length+=e.length}}this.rowCount+=e.length}}buildBinary(){let e=[],n=16,s=[];for(let c of this.schema){let a=this.columns.get(c.name),l=D.encode(c.name),f=Ne(c.dataType),u;if(a.type==="typed"){let d=a.data.subarray(0,a.length);u=new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}else u=D.encode(JSON.stringify(a.data));s.push({nameBytes:l,typeCode:f,dataBytes:u,dataType:c.dataType});let g=(8-(n+4+l.length+1+4)%8)%8;n+=4+l.length+1+g+4+u.length}let t=new ArrayBuffer(n),r=new DataView(t),i=new Uint8Array(t),o=0;r.setUint32(o,1279348291,!1),o+=4,r.setUint32(o,2,!1),o+=4,r.setUint32(o,this.schema.length,!1),o+=4,r.setUint32(o,this.rowCount,!1),o+=4;for(let c of s){r.setUint32(o,c.nameBytes.length,!1),o+=4,i.set(c.nameBytes,o),o+=c.nameBytes.length,r.setUint8(o,c.typeCode),o+=1;let a=(8-(o+4)%8)%8;for(let l=0;l<a;l++)r.setUint8(o+l,0);o+=a,r.setUint32(o,c.dataBytes.length,!1),o+=4,i.set(c.dataBytes,o),o+=c.dataBytes.length}return new Uint8Array(t)}setColumnarData(e){let n=Object.keys(e)[0];this.rowCount=e[n]?.length||0;for(let s of this.schema){let t=e[s.name];if(!t)continue;let r=Ie(s.dataType);if(r&&ArrayBuffer.isView(t))this.columns.set(s.name,{type:"typed",dataType:s.dataType,data:t,length:t.length});else if(r){let i=new r(t.length);for(let o=0;o<t.length;o++)i[o]=t[o]??0;this.columns.set(s.name,{type:"typed",dataType:s.dataType,data:i,length:t.length})}else this.columns.set(s.name,{type:"array",dataType:s.dataType,data:Array.isArray(t)?t:Array.from(t),length:t.length})}}build(){if(this._useBinary&&this.rowCount>0)try{return this.buildBinary()}catch(n){console.warn("[LanceFileWriter] Binary build failed, falling back to JSON:",n)}let e={format:"json",schema:this.schema,columns:{},rowCount:this.rowCount};for(let[n,s]of this.columns)s.type==="typed"?e.columns[n]=Array.from(s.data.subarray(0,s.length)):e.columns[n]=s.data;return D.encode(JSON.stringify(e))}};function Z(h){let e=new DataView(h.buffer||h),n=new Uint8Array(h.buffer||h),s=0;if(e.getUint32(s,!1)!==1279348291)return null;s+=4;let r=e.getUint32(s,!1);s+=4;let i=e.getUint32(s,!1);s+=4;let o=e.getUint32(s,!1);s+=4;let c=[],a={};for(let l=0;l<i;l++){let f=e.getUint32(s,!1);s+=4;let u=N.decode(n.subarray(s,s+f));s+=f;let m=e.getUint8(s);s+=1;let g=(8-(s+4)%8)%8;s+=g;let d=e.getUint32(s,!1);s+=4;let y=n.subarray(s,s+d);s+=d;let w,b;try{switch(m){case ve:b="int32",y.byteOffset%4!==0?w=new Int32Array(y.slice().buffer):w=new Int32Array(y.buffer,y.byteOffset,y.byteLength/4);break;case Ce:b="float32",y.byteOffset%4!==0?w=new Float32Array(y.slice().buffer):w=new Float32Array(y.buffer,y.byteOffset,y.byteLength/4);break;case Ee:b="float64",y.byteOffset%8!==0?w=new Float64Array(y.slice().buffer):w=new Float64Array(y.buffer,y.byteOffset,y.byteLength/8);break;case xe:b="int64",y.byteOffset%8!==0?w=new BigInt64Array(y.slice().buffer):w=new BigInt64Array(y.buffer,y.byteOffset,y.byteLength/8);break;case he:case de:default:b=m===de?"bool":"string",w=JSON.parse(N.decode(y));break}}catch(p){throw console.error(`[LanceQLWorker] Error parsing column '${u}' (type ${m}, len ${d}):`,p),p}c.push({name:u,dataType:b}),a[u]=w}return{schema:c,columns:a,rowCount:o,format:"binary"}}var Q=class{constructor(e=512*1024*1024){this.maxBytes=e,this.currentBytes=0,this.cache=new Map,this.head=null,this.tail=null}get(e){let n=this.cache.get(e);if(n)return this._moveToHead(n),n.value}set(e,n,s=0){let t=this.cache.get(e);if(t)this.currentBytes-=t.size,this.currentBytes+=s,t.value=n,t.size=s,this._moveToHead(t);else{let r={key:e,value:n,size:s,prev:null,next:null};this.cache.set(e,r),this._addToHead(r),this.currentBytes+=s}this._evictIfNeeded()}has(e){return this.cache.has(e)}delete(e){let n=this.cache.get(e);n&&(this._removeNode(n),this.cache.delete(e),this.currentBytes-=n.size)}clear(){this.cache.clear(),this.head=null,this.tail=null,this.currentBytes=0}_moveToHead(e){e!==this.head&&(this._removeNode(e),this._addToHead(e))}_addToHead(e){e.next=this.head,e.prev=null,this.head&&(this.head.prev=e),this.head=e,this.tail||(this.tail=e)}_removeNode(e){e.prev?e.prev.next=e.next:this.head=e.next,e.next?e.next.prev=e.prev:this.tail=e.prev}_evictIfNeeded(){for(;this.currentBytes>this.maxBytes&&this.tail;){let e=this.tail;this._removeNode(e),this.cache.delete(e.key),this.currentBytes-=e.size}}static estimateSize(e){return e?e.byteLength?e.byteLength:Array.isArray(e)?e.length*100:e.buffer&&e.buffer.byteLength?e.buffer.byteLength:1e3:0}};var we=new Map,Pe=1,z=class{constructor(e,n){this.name=e,this.tables=new Map,this.version=0,this.manifestKey=`${e}/__manifest__`,this.bufferPool=n||new Q,this._writeBuffer=new Map,this._flushTimer=null,this._flushInterval=2e3,this._flushThreshold=1e4,this._columnarBuffer=new Map,this._flushing=!1,this._readCache=new Map,this._columnarCache=new Map}async open(){let e=await L.load(this.manifestKey);if(e){let n=JSON.parse(N.decode(e));this.version=n.version||0,this.tables=new Map(Object.entries(n.tables||{}));for(let[s,t]of this.tables)await this._getLatestVersion(s)===0&&t.fragments?.length>0&&await this._createVersion(s,"MIGRATE")}return this}async _saveManifest(){this.version++;let e={version:this.version,timestamp:Date.now(),tables:Object.fromEntries(this.tables)},n=D.encode(JSON.stringify(e));await L.save(this.manifestKey,n)}async _getLatestVersion(e){let n=`${this.name}/${e}/_latest`;try{let s=await L.load(n);return s?parseInt(N.decode(s),10):0}catch{return 0}}async _setLatestVersion(e,n){let s=`${this.name}/${e}/_latest`;await L.save(s,D.encode(String(n)))}async _loadTableVersion(e,n){let s=`${this.name}/${e}/_versions/${n}.manifest`,t=await L.load(s);if(!t)throw new Error(`Version ${n} not found for table '${e}'`);return JSON.parse(N.decode(t))}async _saveTableVersion(e,n){let s=`${this.name}/${e}/_versions/${n.version}.manifest`;await L.save(s,D.encode(JSON.stringify(n)))}async _createVersion(e,n){let s=this.tables.get(e);if(!s)return 0;let t=await this._getLatestVersion(e),r=t+1,i={version:r,timestamp:Date.now(),parentVersion:t,operation:n,schema:s.schema,fragments:[...s.fragments],deletionVector:[...s.deletionVector],rowCount:s.rowCount,nextRowId:s.nextRowId};return await this._saveTableVersion(e,i),await this._setLatestVersion(e,r),r}async listVersions(e){let n=await this._getLatestVersion(e),s=[];for(let t=1;t<=n;t++)try{let r=await this._loadTableVersion(e,t);s.push({version:r.version,timestamp:r.timestamp,operation:r.operation,rowCount:r.rowCount})}catch{}return s}async selectAtVersion(e,n,s={}){let t=await this._loadTableVersion(e,n),r=new Set(t.deletionVector),i=this.tables.get(e),o=[];for(let l of t.fragments){let f=await L.load(l);if(f){let u=this._parseFragment(f,t.schema);for(let m of u)r.has(m.__rowId)||o.push(m)}}let c=o;if(s.where&&(c=c.filter(s.where)),s.orderBy){let{column:l,desc:f}=s.orderBy;c.sort((u,m)=>{let g=u[l]<m[l]?-1:u[l]>m[l]?1:0;return f?-g:g})}s.offset&&(c=c.slice(s.offset)),s.limit&&(c=c.slice(0,s.limit));let a=s.columns&&s.columns.length>0&&s.columns[0]!=="*"?s.columns:null;return c.map(l=>{if(a){let f={};for(let u of a)f[u]=l[u];return f}else{let{__rowId:f,...u}=l;return u}})}async restoreToVersion(e,n){let s=await this._loadTableVersion(e,n),t=await this._getLatestVersion(e),r=t+1,i={...s,version:r,timestamp:Date.now(),parentVersion:t,operation:`RESTORE_FROM_${n}`};await this._saveTableVersion(e,i),await this._setLatestVersion(e,r);let o=this.tables.get(e);return o&&(o.fragments=[...s.fragments],o.deletionVector=[...s.deletionVector],o.rowCount=s.rowCount,o.nextRowId=s.nextRowId,this._columnarBuffer.delete(e),this._writeBuffer.delete(e),await this._saveManifest()),{restored:!0,newVersion:r}}async createTable(e,n,s=!1){if(this.tables.has(e)){if(s)return{success:!0,existed:!0};throw new Error(`Table '${e}' already exists`)}let t=n.map(i=>({name:i.name,type:Le[(i.dataType||i.type)?.toUpperCase()]||i.dataType||i.type||"string",primaryKey:i.primaryKey||!1,vectorDim:i.vectorDim||null})),r={name:e,schema:t,fragments:[],deletionVector:[],rowCount:0,nextRowId:0,version:0,createdAt:Date.now()};return this.tables.set(e,r),await this._saveManifest(),await this._createVersion(e,"CREATE"),{success:!0,table:e}}async dropTable(e,n=!1){if(!this.tables.has(e)){if(n)return this._writeBuffer.delete(e),{success:!0,existed:!1};throw new Error(`Table '${e}' does not exist`)}let s=this.tables.get(e);this._writeBuffer.delete(e);for(let t of s.fragments)this._readCache.delete(t),await L.delete(t);return this.tables.delete(e),await this._saveManifest(),{success:!0,table:e}}async insert(e,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=this.tables.get(e),t=n.length;if(!this._columnarBuffer.has(e)){let c=Math.max(1024,t*2),a={__rowId:new Float64Array(c),__length:0,__capacity:c,__schema:s.schema};for(let l of s.schema){let f=(l.dataType||l.type||"").toLowerCase();f==="text"||f==="string"||f==="varchar"?a[l.name]=new Array(c):f==="int64"||f==="bigint"?a[l.name]=new BigInt64Array(c):a[l.name]=new Float64Array(c)}this._columnarBuffer.set(e,a)}let r=this._columnarBuffer.get(e),i=r.__length,o=r.__capacity;if(i+t>o){let c=Math.max(o*2,i+t),a=new Float64Array(c);a.set(r.__rowId.subarray(0,i)),r.__rowId=a;for(let l of s.schema){let f=r[l.name];if(f instanceof Float64Array){let u=new Float64Array(c);u.set(f.subarray(0,i)),r[l.name]=u}else if(f instanceof BigInt64Array){let u=new BigInt64Array(c);u.set(f.subarray(0,i)),r[l.name]=u}else r[l.name].length=c}r.__capacity=c}for(let c=0;c<t;c++){let a=n[c];r.__rowId[i+c]=s.nextRowId++;for(let l of s.schema){let f=a[l.name];r[l.name]instanceof Float64Array?r[l.name][i+c]=f!=null?Number(f):NaN:r[l.name]instanceof BigInt64Array?r[l.name][i+c]=f!=null?BigInt(f):0n:r[l.name][i+c]=f??null}}return r.__length=i+t,s.rowCount+=t,s.version=(s.version||0)+1,this._scheduleFlush(),r.__length>=this._flushThreshold&&await this._flushTable(e),{success:!0,inserted:t}}_scheduleFlush(){this._flushTimer||(this._flushTimer=setTimeout(()=>{this._flushTimer=null,this.flush().catch(e=>console.warn("[WorkerDatabase] Flush error:",e))},this._flushInterval))}async flush(){if(!this._flushing){this._flushing=!0;try{let e=[...this._columnarBuffer.keys()];for(let n of e)await this._flushTable(n)}finally{this._flushing=!1}}}async _flushTable(e){let n=this._columnarBuffer.get(e),s=n?.__length||0;if(!n||s===0)return;let t=this.tables.get(e);if(!t)return;let r=[{name:"__rowId",type:"int64",dataType:"float64",primaryKey:!0},...t.schema.filter(l=>l.name!=="__rowId").map(l=>{let f=(l.dataType||l.type||"").toLowerCase();return f==="int64"||f==="bigint"?{...l,dataType:"int64"}:{...l,dataType:f==="float64"||f==="float32"||f==="int32"||f==="integer"||f==="real"||f==="double"?"float64":l.dataType||l.type||"float64"}})],i={};for(let l of r){let f=n[l.name];f&&(f instanceof Float64Array||f instanceof BigInt64Array?i[l.name]=f.subarray(0,s):i[l.name]=f.slice(0,s))}n.__length=0;let o=new re(r);o.setColumnarData(i);let c=o.build(),a=`${this.name}/${e}/frag_${Date.now()}_${Math.random().toString(36).slice(2)}.lance`;await L.save(a,c),t.fragments.push(a),await this._saveManifest(),await this._createVersion(e,"INSERT")}async delete(e,n){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=this.tables.get(e),t=0,r=this._columnarBuffer.get(e),i=r?.__length||0;if(r&&i>0){let o=s.schema.map(c=>c.name);for(let c=0;c<i;c++){let a={__rowId:r.__rowId[c]};for(let l of o){let f=r[l][c];a[l]=Number.isNaN(f)?null:f}n(a)&&(s.deletionVector.includes(r.__rowId[c])||(s.deletionVector.push(r.__rowId[c]),t++))}}for(let o of s.fragments){let c=await L.load(o);if(c){let a=this._parseFragment(c,s.schema);for(let l of a)!s.deletionVector.includes(l.__rowId)&&n(l)&&(s.deletionVector.push(l.__rowId),t++)}}return s.rowCount-=t,s.version=(s.version||0)+1,await this._saveManifest(),t>0&&await this._createVersion(e,"DELETE"),{success:!0,deleted:t}}async update(e,n,s){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let t=this.tables.get(e),r=0,i=this._writeBuffer.get(e);if(i&&i.length>0)for(let c of i)s(c)&&(Object.assign(c,n),r++);let o=[];for(let c of t.fragments){let a=await L.load(c);if(a){let l=this._parseFragment(a,t.schema);for(let f of l)if(!t.deletionVector.includes(f.__rowId)&&s(f)){t.deletionVector.push(f.__rowId),t.rowCount--;let u={...f,...n};delete u.__rowId,o.push(u),r++}}}return o.length>0?await this.insert(e,o):await this._saveManifest(),r>0&&o.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:r}}async updateWithExpr(e,n,s,t){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let r=this.tables.get(e),i=0,o=this._columnarBuffer.get(e),c=o?.__length||0;if(o&&c>0){let l=r.schema.map(f=>f.name);for(let f=0;f<c;f++){let u={__rowId:o.__rowId[f]};for(let m of l){let g=o[m][f];u[m]=Number.isNaN(g)?null:g}if(s(u)){for(let[m,g]of Object.entries(n)){let d=t(g,u);o[m]!==void 0&&(o[m][f]=d??(o[m]instanceof Float64Array?NaN:null))}r.version=(r.version||0)+1,i++}}}let a=[];for(let l of r.fragments){let f=await L.load(l);if(f){let u=this._parseFragment(f,r.schema);for(let m of u)if(!r.deletionVector.includes(m.__rowId)&&s(m)){r.deletionVector.push(m.__rowId),r.rowCount--;let g={...m};for(let[d,y]of Object.entries(n))g[d]=t(y,m);delete g.__rowId,a.push(g),i++}}}return a.length>0?await this.insert(e,a):await this._saveManifest(),i>0&&a.length===0&&await this._createVersion(e,"UPDATE"),{success:!0,updated:i}}async select(e,n={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=await this._readAllRows(e);if(n.where&&(s=s.filter(n.where)),n.orderBy){let{column:i,desc:o}=n.orderBy;s.sort((c,a)=>{let l=c[i]<a[i]?-1:c[i]>a[i]?1:0;return o?-l:l})}n.offset&&(s=s.slice(n.offset)),n.limit&&(s=s.slice(0,n.limit));let t=n.columns&&n.columns.length>0&&n.columns[0]!=="*"?n.columns:null,r=new Array(s.length);for(let i=0;i<s.length;i++){let o=s[i];if(t){let c={};for(let a of t)c[a]=o[a];r[i]=c}else{let{__rowId:c,...a}=o;r[i]=a}}return r}async _readAllRows(e){let n=this.tables.get(e),s=this._columnarBuffer.get(e),r=n.deletionVector.length>0?new Set(n.deletionVector):null,i=[];for(let c of n.fragments){let a=this.bufferPool.get(c),l=null;if(!a){let f=await L.load(c);f&&(a=Z(f),a?this.bufferPool.set(c,a,f.byteLength):l=this._parseFragment(f,n.schema))}if(a&&!l&&(l=this._hydrateRowsFromBinary(a,n.schema)),l=l||[],!r)i.push(...l);else for(let f of l)r.has(f.__rowId)||i.push(f)}let o=s?.__length||0;if(s&&o>0){let c=n.schema.map(a=>a.name);for(let a=0;a<o;a++){if(r&&r.has(s.__rowId[a]))continue;let l={__rowId:s.__rowId[a]};for(let f of c){let u=s[f][a];l[f]=Number.isNaN(u)?null:u}i.push(l)}}return i}_hydrateRowsFromBinary(e,n){let{columns:s,rowCount:t}=e,r=n.map(o=>o.name),i=new Array(t);for(let o=0;o<t;o++){let c={__rowId:s.__rowId[o]};for(let a of r)s[a]&&(c[a]=s[a][o]);i[o]=c}return i}_parseFragment(e,n){try{let s=Z(e);if(s)return this._parseBinaryColumnar(s);let t=N.decode(e),r=JSON.parse(t);return r.format==="json"&&r.columns?this._parseJsonColumnar(r):Array.isArray(r)?r:[r]}catch(s){return console.warn("[WorkerDatabase] Failed to parse fragment:",s),[]}}async selectColumnar(e){let n=this.tables.get(e);if(!n)return null;let s=this._columnarBuffer.get(e)?.__length||0,t=`${n.fragments.length}:${s}:${n.deletionVector.length}:${n.version||0}`,r=this._columnarCache.get(e);if(r&&r.version===t){let d={};for(let[y,w]of Object.entries(r.data.columns))ArrayBuffer.isView(w)?d[y]=new w.constructor(w.buffer,w.byteOffset,w.length):d[y]=w;return{schema:n.schema,columns:d,rowCount:r.data.rowCount}}let o=n.deletionVector.length>0?new Set(n.deletionVector):null,c={},a=n.schema.map(d=>d.name);for(let d of a)c[d]=[];c.__rowId=[];for(let d of n.fragments){let y=this.bufferPool.get(d);if(!y){let p=await L.load(d);if(!p)continue;y=Z(p),y&&this.bufferPool.set(d,y,p.byteLength)}if(!y)continue;let{columns:w,rowCount:b}=y;if(o){let p=w.__rowId,_=[];for(let A=0;A<b;A++)o.has(p[A])||_.push(A);for(let A of a)if(w[A]){let B=w[A],T=new B.constructor(_.length);for(let E=0;E<_.length;E++)T[E]=B[_[E]];c[A].push(T)}}else{for(let p of a)w[p]&&c[p].push(w[p]);w.__rowId&&c.__rowId.push(w.__rowId)}}let l=this._columnarBuffer.get(e),f=l?.__length||0;if(l&&f>0)if(o){let d=[];for(let b=0;b<f;b++)o.has(l.__rowId[b])||d.push(b);let y=d.length;for(let b of n.schema){let p=l[b.name];if(p)if(p instanceof Float64Array){let _=new Float64Array(y);for(let A=0;A<y;A++)_[A]=p[d[A]];c[b.name].push(_)}else c[b.name].push(d.map(_=>p[_]))}let w=new Float64Array(y);for(let b=0;b<y;b++)w[b]=l.__rowId[d[b]];c.__rowId.push(w)}else{for(let y of n.schema){let w=l[y.name];if(w)if(w instanceof Float64Array){let b=new Float64Array(f);b.set(w.subarray(0,f)),c[y.name].push(b)}else c[y.name].push(w.slice(0,f))}let d=new Float64Array(f);d.set(l.__rowId.subarray(0,f)),c.__rowId.push(d)}let u={},m=0;for(let d of[...a,"__rowId"]){let y=c[d];if(y.length===0)u[d]=new Float64Array(0);else if(y.length===1)u[d]=y[0],m===0&&(m=y[0].length);else{let w=y.reduce((A,B)=>A+B.length,0);m===0&&(m=w);let b=y[0],p=ArrayBuffer.isView(b)?new b.constructor(w):new Array(w),_=0;for(let A of y){if(ArrayBuffer.isView(p))p.set(A,_);else for(let B=0;B<A.length;B++)p[_+B]=A[B];_+=A.length}u[d]=p}}let g={schema:n.schema,columns:u,rowCount:m};return this._columnarCache.set(e,{version:t,data:g}),g}async _readColumn(e,n){let s=this.tables.get(e);if(!s)return null;let t=this._writeBuffer.get(e),r=[];for(let a of s.fragments){let l=await L.load(a);if(!l)continue;let f=Z(l);if(f&&f.columns[n]){let u=f.columns[n];u.length>0&&r.push(u)}}if(t&&t.length>0){let a=new Float64Array(t.length);for(let l=0;l<t.length;l++){let f=t[l][n];a[l]=typeof f=="number"?f:0}r.push(a)}if(r.length===0)return new Float64Array(0);if(r.length===1)return r[0];let i=r.reduce((a,l)=>a+l.length,0),o=new Float64Array(i),c=0;for(let a of r)o.set(a,c),c+=a.length;return o}_parseBinaryColumnar(e){let{schema:n,columns:s,rowCount:t}=e,r=new Array(t),i=n.map(a=>a.name),o=i.map(a=>s[a]),c=i.length;for(let a=0;a<t;a++){let l={};for(let f=0;f<c;f++)l[i[f]]=o[f][a]??null;r[a]=l}return r}_parseJsonColumnar(e){let{schema:n,columns:s,rowCount:t}=e,r=new Array(t),i=n.map(a=>a.name),o=i.map(a=>s[a]||[]),c=i.length;for(let a=0;a<t;a++){let l={};for(let f=0;f<c;f++)l[i[f]]=o[f][a]??null;r[a]=l}return r}getTable(e){return this.tables.get(e)}listTables(){return Array.from(this.tables.keys())}getFragmentPaths(e){let n=this.tables.get(e);return n?n.fragments:[]}getColumnIndex(e,n){let s=this.tables.get(e);if(!s)return-1;let t=s.schema.findIndex(r=>r.name===n);return t>=0?t+1:-1}hasBufferedData(e){let n=this._columnarBuffer.get(e);return n&&(n.__length||0)>0}async compact(){for(let[e,n]of this.tables){let s=await this._readAllRows(e);for(let t of n.fragments)await L.delete(t);if(n.fragments=[],n.deletionVector=[],n.rowCount=0,n.nextRowId=0,s.length>0){let t=s.map(({__rowId:r,...i})=>i);await this.insert(e,t)}}return{success:!0,compacted:this.tables.size}}async scanStart(e,n={}){if(!this.tables.has(e))throw new Error(`Table '${e}' does not exist`);let s=Pe++,t=this.tables.get(e),r=new Set(t.deletionVector),i=[];for(let c of t.fragments){let a=await L.load(c);if(a){let l=this._parseFragment(a,t.schema);for(let f of l)r.has(f.__rowId)||i.push(f)}}let o=this._writeBuffer.get(e);if(o)for(let c of o)r.has(c.__rowId)||i.push(c);return we.set(s,{rows:i,index:0,batchSize:n.batchSize||1e4,columns:n.columns}),s}scanNext(e){let n=we.get(e);if(!n)return{batch:[],done:!0};let s=[],t=Math.min(n.index+n.batchSize,n.rows.length);for(let i=n.index;i<t;i++){let o=n.rows[i],c;if(n.columns&&n.columns.length>0&&n.columns[0]!=="*"){c={};for(let a of n.columns)c[a]=o[a]}else{let{__rowId:a,...l}=o;c=l}s.push(c)}n.index=t;let r=n.index>=n.rows.length;return r&&we.delete(e),{batch:s,done:r}}};var oe=class{constructor(){this._root=null,this._ready=!1,this._kv={},this._encryptionKeyId=null,this._db=null}async open(e=null){if(this._ready)return this;if(e){let{keyId:n,keyBytes:s}=e;if(!W.has(n)){let t=await ee(s);W.set(n,t)}this._encryptionKeyId=n}try{let n=await navigator.storage.getDirectory();this._root=await n.getDirectoryHandle("vault",{create:!0}),await this._loadKV(),this._db=new z("vault"),await this._db.open(),this._ready=!0}catch(n){throw console.error("[WorkerVault] Failed to open OPFS:",n),n}return this}_getCryptoKey(){return this._encryptionKeyId?W.get(this._encryptionKeyId):null}async _loadKV(){try{let e=this._getCryptoKey(),n=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(n)).getFile();if(e){let r=await t.arrayBuffer();this._kv=await ne(new Uint8Array(r),e)}else{let r=await t.text();this._kv=JSON.parse(r)}}catch(e){if(e.name==="NotFoundError")this._kv={};else throw e}}async _saveKV(){let e=this._getCryptoKey(),n=e?"_vault.json.enc":"_vault.json",t=await(await this._root.getFileHandle(n,{create:!0})).createWritable();if(e){let r=await te(this._kv,e);await t.write(r)}else await t.write(JSON.stringify(this._kv));await t.close()}async get(e){return this._kv[e]}async set(e,n){this._kv[e]=n,await this._saveKV()}async delete(e){delete this._kv[e],await this._saveKV()}async keys(){return Object.keys(this._kv)}async has(e){return e in this._kv}};var Ke=1;var Fe={INT64:0,FLOAT64:1,INT32:2,FLOAT32:3,STRING:4,LIST:5},me=class{constructor(){this._registered=new Map}getLastError(){let e=k();if(!e)return"WASM not loaded";let n=M(),s=e.alloc(4096);console.log(`[WASM LOG] getLastError alloc ptr: ${s}`);let t=e.getLastError(s,4096);if(console.log(`[WASM LOG] getLastError len: ${t}`),t===0)return"Unknown Error";let r=new Uint8Array(n.buffer,s,t),i=new TextDecoder().decode(r);return console.log(`[WASM LOG] getLastError msg: ${i}`),i}getTableNames(e){let n=k();if(!n)throw new Error("WASM not loaded");let s=M(),t=new TextEncoder().encode(e),r=n.alloc(t.length);new Uint8Array(s.buffer,r,t.length).set(t);let i=n.getTableNames(r,t.length);if(i===0)return[];let o=new Uint8Array(s.buffer,i),c=0;for(;o[c]!==0&&c<1024;)c++;let a=new TextDecoder().decode(o.subarray(0,c));return a?a.split(",").filter(l=>l):[]}hasTable(e){let n=k();if(!n)return!1;let s=M(),t=new TextEncoder().encode(e),r=n.alloc(t.length);return new Uint8Array(s.buffer,r,t.length).set(t),n.hasTable(r,t.length)===1}registerTable(e,n,s,t=""){let r=k();if(!r)throw new Error("WASM not loaded");let i=this._registered.get(e);if(i&&i.version===t)return;if(i){let f=new TextEncoder().encode(e);r.clearTable(f,f.length)}let o=M(),c=new TextEncoder().encode(e),a=r.alloc(c.length);new Uint8Array(o.buffer,a,c.length).set(c);let l=new Set;for(let[f,u]of Object.entries(n)){if(f.startsWith("__"))continue;let m=new TextEncoder().encode(f),g=r.alloc(m.length);if(new Uint8Array(o.buffer,g,m.length).set(m),u instanceof Float64Array){let d=r.allocFloat64Buffer(u.length);new Float64Array(o.buffer,d,u.length).set(u),r.registerTableFloat64(a,c.length,g,m.length,d,u.length),l.add(f)}else if(u instanceof BigInt64Array){let d=r.allocInt64Buffer(u.length);new BigInt64Array(o.buffer,d,u.length).set(u),r.registerTableInt64(a,c.length,g,m.length,d,u.length),l.add(f)}else if(u instanceof Int32Array){let d=new Float64Array(u.length);for(let w=0;w<u.length;w++)d[w]=u[w];let y=r.allocFloat64Buffer(d.length);new Float64Array(o.buffer,y,d.length).set(d),r.registerTableFloat64(a,c.length,g,m.length,y,d.length),l.add(f)}else if(Array.isArray(u)){let d=new Uint32Array(u.length),y=new Uint32Array(u.length),w=0;for(let T=0;T<u.length;T++){let E=String(u[T]||"");y[T]=E.length,d[T]=w,w+=E.length}let b=new Uint8Array(w),p=0;for(let T=0;T<u.length;T++){let E=String(u[T]||""),R=new TextEncoder().encode(E);b.set(R,p),p+=R.length}let _=r.alloc(d.byteLength);new Uint32Array(o.buffer,_,d.length).set(d);let A=r.alloc(y.byteLength);new Uint32Array(o.buffer,A,y.length).set(y);let B=r.alloc(b.length);new Uint8Array(o.buffer,B,b.length).set(b),r.registerTableString(a,c.length,g,m.length,_,A,B,w,u.length),l.add(f)}}this._registered.set(e,{version:t,columns:l,rowCount:s})}registerTableFromFiles(e,n,s=""){let t=k();if(!t)throw new Error("WASM not loaded");let r=this._registered.get(e);if(r&&r.version===s)return;if(r){let a=new TextEncoder().encode(e);t.clearTable(a,a.length)}let i=new TextEncoder,o=i.encode(e),c=t.alloc(o.length);new Uint8Array(M().buffer,c,o.length).set(o);for(let a of n){let l=i.encode(a),f=t.alloc(l.length);new Uint8Array(M().buffer,f,l.length).set(l);let u=t.registerTableFromOPFS(c,o.length,f,l.length);u!==0&&console.warn(`Failed to register fragment ${a} for table ${e}: error ${u}`)}this._registered.set(e,{version:s,type:"files"})}appendTableMemory(e,n,s){let t=k();if(!t)throw new Error("WASM not loaded");let r=M(),i=new TextEncoder().encode(e),o=t.alloc(i.length);new Uint8Array(r.buffer,o,i.length).set(i);for(let[c,a]of Object.entries(n)){if(c.startsWith("__"))continue;let l=new TextEncoder().encode(c),f=t.alloc(l.length);if(new Uint8Array(r.buffer,f,l.length).set(l),a instanceof Float64Array){let u=t.allocFloat64Buffer(a.length);new Float64Array(r.buffer,u,a.length).set(a),t.appendTableMemory(o,i.length,f,l.length,u,4,s)}else if(a instanceof BigInt64Array){let u=t.allocInt64Buffer(a.length);new BigInt64Array(r.buffer,u,a.length).set(a),t.appendTableMemory(o,i.length,f,l.length,u,2,s)}else if(a instanceof Int32Array){let u=t.alloc(a.byteLength);new Int32Array(r.buffer,u,a.length).set(a),t.appendTableMemory(o,i.length,f,l.length,u,1,s)}else if(a instanceof Float32Array){let u=t.alloc(a.byteLength);new Float32Array(r.buffer,u,a.length).set(a),t.appendTableMemory(o,i.length,f,l.length,u,3,s)}}}execute(e){let n=k();if(!n)throw new Error("WASM not loaded");let s=M();if(n.setCurrentTimestamp)try{n.setCurrentTimestamp(BigInt(Date.now()))}catch(u){console.warn("setCurrentTimestamp failed:",u)}let t=n.getSqlInputBuffer(),r=n.getSqlInputBufferSize(),i=new TextEncoder().encode(e);if(i.length>r)throw new Error(`SQL too long: ${i.length} > ${r}`);new Uint8Array(s.buffer,t,i.length).set(i),n.setSqlInputLength(i.length);let o=n.executeSql();if(o===0){let u=this.getLastError();throw console.log(`[WASM LOG] execute throwing: "${u}"`),new Error(u)}let c=n.getResultSize(),a=this.getLastError();a&&a.length>0&&console.log(`[WASM DEBUG CAPTURED] ${a}`),a.length>0&&a.startsWith("DEBUG:");let l=n.memory.buffer,f=this._parseResult(s.buffer,o,c);return n.resetResult(),f}_parseResult(e,n,s){let t=new DataView(e,n,s),r=new TextDecoder;if(s>=40){let i=s-40,o=[t.getUint8(i+36),t.getUint8(i+37),t.getUint8(i+38),t.getUint8(i+39)];if(String.fromCharCode(...o)==="LANC")return this._parseLanceResult(e,n,s,i,t,r)}if(s>=36&&t.getUint32(0,!0)===Ke)return this._parseLegacyResult(e,n,s);throw new Error(`Invalid result format (Size: ${s}). Not a Lance file.`)}_parseLanceResult(e,n,s,t,r,i){let o=Number(r.getBigUint64(t+8,!0)),c=r.getUint32(t+28,!0),a=[],l={},f=0;for(let u=0;u<c;u++){let m=o+u*8,d=Number(r.getBigUint64(m,!0));r.getUint8(d++);let[y,w]=this._readVarint(r,d);d+=w;let b=new Uint8Array(e,n+d,y),p=i.decode(b);d+=y,a.push(p),r.getUint8(d++);let[_,A]=this._readVarint(r,d);d+=A;let B=new Uint8Array(e,n+d,_),T=i.decode(B);d+=_,r.getUint8(d++);let[E,R]=this._readVarint(r,d);d+=R,r.getUint8(d++);let ce=Number(r.getBigUint64(d,!0));d+=8,r.getUint8(d++);let[I,j]=this._readVarint(r,d);d+=j,f=I,r.getUint8(d++);let[le,Re]=this._readVarint(r,d);d+=Re;let G=n+ce;if(T==="float64"||T==="int64"||T==="int32"||T==="float32")if(T==="float64"){let V=new Float64Array(e,G,I).slice(),C=!1;for(let S=0;S<I;S++)if(Number.isNaN(V[S])){C=!0;break}if(C){console.log(`[WASM LOG] Column ${p} has NaNs, converting to nulls`);let S=new Array(I);for(let v=0;v<I;v++){let $=V[v];S[v]=Number.isNaN($)?null:$}l[p]=S}else l[p]=V}else if(T==="int64"){let V=new BigInt64Array(e,G,I),C=new Array(I),S=-9223372036854775808n;for(let v=0;v<I;v++){let $=V[v];C[v]=$===S?null:Number($)}l[p]=C}else if(T==="int32"){let V=new Int32Array(e,G,I),C=new Array(I);for(let S=0;S<I;S++){let v=V[S];v===-2147483648?C[S]=null:C[S]=v}l[p]=C}else{let V=new Float32Array(e,G,I),C=new Array(I);for(let S=0;S<I;S++){let v=V[S];C[S]=isNaN(v)?null:v}l[p]=C}else if(T==="string"||T==="list"){let V=T==="list",C=(I+1)*4,S=le-C,v=new Uint8Array(e,G,S).slice(),$=new Uint32Array(e,G+S,I+1).slice();l[p]={_arrowString:!0,offsets:$,bytes:v,isList:T==="list",nullable:E===1}}}return{_format:"columnar",columns:a,rowCount:f,data:l}}_readVarint(e,n){let s=0,t=0,r=0;for(;;){let i=e.getUint8(n+r);if(r++,s|=(i&127)<<t,(i&128)===0)break;t+=7}return[s,r]}_parseLegacyResult(e,n,s){let t=new DataView(e,n,s),r=new TextDecoder,i=t.getUint32(4,!0),o=Number(t.getBigUint64(8,!0)),c=t.getUint32(24,!0),a=t.getUint32(32,!0),l=[],f={};for(let u=0;u<i;u++){let m=36+u*16,g=t.getUint32(m,!0),d=t.getUint32(m+4,!0),y=t.getUint32(m+8,!0),w=t.getUint32(m+12,!0),b=new Uint8Array(e,n+a+d,y),p=r.decode(b);l.push(p);let _=Object.keys(Fe).find(B=>Fe[B]===g).toLowerCase(),A=n+c+w;if(_==="float64"||_==="int64"||_==="int32"||_==="float32")_==="float64"?f[p]=new Float64Array(e,A,o).slice():_==="int64"?f[p]=new Float64Array(e,A,o).slice():_==="int32"?f[p]=new Int32Array(e,A,o).slice():_==="float32"&&(f[p]=new Float32Array(e,A,o).slice());else if(_==="string"||_==="list"){let B=new Uint32Array(o+1),T=0;B[0]=0;let E=A,R=0;for(let j=0;j<o;j++){let le=t.getUint32(E+j*8+4,!0);R+=le,B[j+1]=R}let ce=A+o*8,I=new Uint8Array(e,ce,R).slice();f[p]={_arrowString:!0,offsets:B,bytes:I,isList:_==="list"}}}return{_format:"columnar",columns:l,rowCount:o,data:f}}clear(){let e=k();e&&e.clearTables(),this._registered.clear()}},ye=null;function ge(){return ye||(ye=new me),ye}var pe={showVersions:/^\s*SHOW\s+VERSIONS\s+FOR\s+(\w+)\s*$/i,restoreTable:/^\s*RESTORE\s+(\w+)\s+TO\s+VERSION\s+(\d+)\s*$/i,versionAsOf:/FROM\s+(\w+)\s+VERSION\s+AS\s+OF\s+(\d+)/i};function Oe(h){let e;return(e=h.match(pe.showVersions))?{type:"SHOW_VERSIONS",table:e[1]}:(e=h.match(pe.restoreTable))?{type:"RESTORE_TABLE",table:e[1],version:parseInt(e[2],10)}:(e=h.match(pe.versionAsOf))?{type:"SELECT_VERSION",table:e[1],version:parseInt(e[2],10),sql:h}:null}async function Ve(h,e){if(!O&&(await X(),!O))throw new Error("WASM not loaded");let n=ge(),s=n.getTableNames(e);for(let t of s){if(n.hasTable(t))continue;let i=h.tables.get(t);if(!i)continue;let o=h._columnarBuffer?.get(t),c=o?.__length||0,a=`${t}:${i.fragments?.length||0}:${c}:${i.deletionVector?.length||0}`,l=i.fragments.length>0,f=c>0;if(l){let u=[];for(let m of i.fragments){let g=await Ge(m);g&&u.push(g)}if(n.registerTableFromFiles(t,i.fragments,a),f){let m={};for(let g of i.schema){let d=o[g.name];d&&ArrayBuffer.isView(d)&&(m[g.name]=d.subarray(0,c))}n.appendTableMemory(t,m,c)}}else if(f){let u=await h.selectColumnar(t);if(u){let{columns:m,rowCount:g}=u;n.registerTable(t,m,g,a)}}}return n.execute(e)}var O=null,H=null,J=new Map,He=1;async function Me(h){let e=await navigator.storage.getDirectory();e=await e.getDirectoryHandle("lanceql",{create:!0});for(let n of h)e=await e.getDirectoryHandle(n,{create:!0});return e}function je(){return{env:{opfs_open:(h,e)=>{try{let n=new Uint8Array(H.buffer,h,e),s=new TextDecoder().decode(n);for(let[t,r]of J.entries())if(r._path===s)return t;return console.warn("[LanceQLWorker] WASM tried to open unregistered path:",s),0}catch(n){return console.error("[LanceQLWorker] Error:",n),0}},opfs_read:(h,e,n,s)=>{let t=J.get(h);if(!t)return 0;try{let r=new Uint8Array(H.buffer,e,n);return t.read(r,{at:Number(s)})}catch{return 0}},opfs_size:h=>{let e=J.get(h);if(!e)return BigInt(0);try{return BigInt(e.getSize())}catch{return BigInt(0)}},opfs_close:h=>{},__assert_fail:(h,e,n,s)=>{let r=new TextDecoder().decode(new Uint8Array(H.buffer,h).subarray(0,100));console.error(`[WASM ASSERT] ${r} at line ${n}`)},js_log:(h,e)=>{let s=new TextDecoder().decode(new Uint8Array(H.buffer,h,e));console.log(`[WASM LOG] ${s}`);for(let t of Be)t.postMessage({type:"log",message:s,marker:"__WASM_LOG_BRIDGE__"})}}}}async function Ge(h){try{let e=h.split("/").filter(o=>o),n=e.pop(),r=await(await(await Me(e)).getFileHandle(n)).createSyncAccessHandle(),i=He++;return r._path=h,J.set(i,r),i}catch(e){return console.warn("[LanceQLWorker] Failed to register OPFS file:",h,e),0}}function Ct(h){let e=J.get(h);if(e){try{e.close()}catch{}J.delete(h)}}async function X(){if(O)return O;try{let h=new URL("./lanceql.wasm",import.meta.url);h.searchParams.set("v",Date.now().toString());let n=await(await fetch(h)).arrayBuffer(),s=je();return O=(await WebAssembly.instantiate(n,s)).instance.exports,H=O.memory,console.log("[LanceQLWorker] WASM loaded with OPFS support"),O}catch(h){return console.warn("[LanceQLWorker] WASM not available:",h.message),null}}function k(){return O}function M(){return H}var be=0,Ue=0,Qe=1024*1024;function ze(h){if(!O)return 0;if(h<=Ue&&be!==0)return be;let e=Math.max(h,Qe),n=O.alloc(e);return n&&(be=n,Ue=e),n}async function Et(h){let e=await X();if(!e)return 0;try{let n=h.split("/").filter(f=>f),s=n.pop(),i=await(await(await Me(n)).getFileHandle(s)).createSyncAccessHandle(),o=i.getSize(),c=ze(o);if(!c)return i.close(),0;let a=new Uint8Array(H.buffer,c,o),l=i.read(a,{at:0});return i.close(),l!==o?0:e.openFile(c,o)}catch(n){return console.warn("[LanceQLWorker] Failed to load fragment:",h,n),0}}async function qe(h,e){let n=e.split("/").filter(t=>t),s=h;for(let t=0;t<n.length-1;t++)s=await s.getDirectoryHandle(n[t],{create:!1});return await s.getFileHandle(n[n.length-1],{create:!1})}var _e=null;async function Je(h){let e=Se.get(h);if(e)return e;_e||(_e=await navigator.storage.getDirectory());let t=await(await(await qe(_e,h)).getFile()).arrayBuffer();return e=new Uint8Array(t),e&&Se.set(h,e,e.byteLength),e}async function Ft(h,e,n){if(!await Je(h))return null;let t=O;switch(n){case"sum":return t.opfsSumFloat64Column(e);case"min":return t.opfsMinFloat64Column(e);case"max":return t.opfsMaxFloat64Column(e);case"avg":return t.opfsAvgFloat64Column(e);case"count":return Number(t.opfsCountRows());default:return null}}X();var Se=new Q,Ae=new Map,Te=new Map,ae=null,Be=new Set,q=null,K=0,Ye=1024,ie=new Map,De=1;async function P(h=null){return ae||(ae=new oe),await ae.open(h),ae}async function F(h,e={},n=null){let s=n?.keyId||"none",t=`${h}:${s}:${JSON.stringify(e)}`;if(!Ae.has(t)){let r=new se(h,e);await r.open(n),Ae.set(t,r)}return Ae.get(t)}async function x(h){if(!Te.has(h)){let e=new z(h,Se);await e.open(),Te.set(h,e)}return Te.get(h)}function Ze(h,e,n){if(n&&n._format==="wasm_binary"){h.postMessage({id:e,result:{_format:"wasm_binary",buffer:n.buffer,columns:n.columns,rowCount:n.rowCount,schema:n.schema}},[n.buffer]);return}if(n&&n._format==="columnar"&&n.data){let s=n.columns,t=n.rowCount;if(t<1e5){let m=[],g={},d=new Set;for(let y of s){let w=n.data[y];if(ArrayBuffer.isView(w)){let b=w.byteOffset!==0||w.byteLength<w.buffer.byteLength,p=d.has(w.buffer);if(b||p){let _=new w.constructor(w);g[y]=_,m.push(_.buffer)}else g[y]=w,m.push(w.buffer),d.add(w.buffer)}else w&&w._arrowString?(g[y]=w,w.offsets&&w.offsets.buffer&&!d.has(w.offsets.buffer)&&(m.push(w.offsets.buffer),d.add(w.offsets.buffer)),w.bytes&&w.bytes.buffer&&!d.has(w.bytes.buffer)&&(m.push(w.bytes.buffer),d.add(w.bytes.buffer))):g[y]=w}h.postMessage({id:e,result:{_format:"columnar",columns:s,rowCount:t,data:g}},m);return}let r=[],i=[],o=0;for(let m of s){let g=n.data[m];ArrayBuffer.isView(g)?(r.push({name:m,arr:g}),o+=g.byteLength):Array.isArray(g)&&i.push({name:m,arr:g})}let c=o>0?new ArrayBuffer(o):null,a={},l=0;if(c){let m=new Uint8Array(c);for(let{name:g,arr:d}of r){let y=new Uint8Array(d.buffer,d.byteOffset,d.byteLength);m.set(y,l),a[g]={offset:l,length:d.length,type:d.constructor.name},l+=d.byteLength}}let f={};for(let{name:m,arr:g}of i)f[m]=g;let u=[];c&&u.push(c),h.postMessage({id:e,result:{_format:"packed",columns:s,rowCount:t,packedBuffer:c,colOffsets:a,stringData:f}},u);return}if(q&&n!==void 0){let s=JSON.stringify(n);if(s.length>Ye){let t=D.encode(s);if(K+t.length<=q.byteLength){new Uint8Array(q,K,t.length).set(t),h.postMessage({id:e,sharedOffset:K,sharedLength:t.length}),K+=t.length,K>q.byteLength/2&&(K=0);return}}}h.postMessage({id:e,result:n})}async function ke(h,e){if(e.type==="initSharedBuffer"){q=e.buffer,K=0,console.log("[LanceQLWorker] SharedArrayBuffer initialized:",q.byteLength,"bytes");return}let{id:n,method:s,args:t}=e;try{let r;if(s==="ping")r="pong";else if(s==="open")await F(t.name,t.options,t.encryption),r=!0;else if(s==="get")r=await(await F(t.name)).get(t.key);else if(s==="set")await(await F(t.name)).set(t.key,t.value),r=!0;else if(s==="delete")await(await F(t.name)).delete(t.key),r=!0;else if(s==="keys")r=await(await F(t.name)).keys();else if(s==="clear")await(await F(t.name)).clear(),r=!0;else if(s==="filter")r=await(await F(t.name)).filter(t.key,t.query);else if(s==="find")r=await(await F(t.name)).find(t.key,t.query);else if(s==="search")r=await(await F(t.name)).search(t.key,t.text,t.limit);else if(s==="count")r=await(await F(t.name)).count(t.key,t.query);else if(s==="enableSemanticSearch")r=await(await F(t.name)).enableSemanticSearch(t.options);else if(s==="disableSemanticSearch")(await F(t.name)).disableSemanticSearch(),r=!0;else if(s==="hasSemanticSearch")r=(await F(t.name)).hasSemanticSearch();else if(s==="db:open")console.log(`[LanceQLWorker] db:open ${t.name}`),await x(t.name),r=!0;else if(s==="db:createTable")console.log(`[LanceQLWorker] db:createTable ${t.tableName}`),r=await(await x(t.db)).createTable(t.tableName,t.columns,t.ifNotExists),console.log(`[LanceQLWorker] db:createTable ${t.tableName} done`);else if(s==="db:dropTable"){console.log(`[LanceQLWorker] db:dropTable ${t.tableName}`),r=await(await x(t.db)).dropTable(t.tableName,t.ifExists);let o=D.encode(t.tableName);ge().clearTable(o,o.length)}else if(s==="db:insert")console.log(`[LanceQLWorker] db:insert into ${t.tableName}, rows: ${t.rows?.length}`),r=await(await x(t.db)).insert(t.tableName,t.rows),console.log("[LanceQLWorker] db:insert done");else if(s==="db:delete"){let i=await x(t.db),o=t.where?c=>evalWhere(t.where,c):()=>!0;r=await i.delete(t.tableName,o)}else if(s==="db:update"){let i=await x(t.db),o=t.where?c=>evalWhere(t.where,c):()=>!0;r=await i.update(t.tableName,t.updates,o)}else if(s==="db:select"){let i=await x(t.db),o={...t.options};t.where&&(o.where=c=>evalWhere(t.where,c)),r=await i.select(t.tableName,o)}else if(s==="db:exec"){let i=await x(t.db),o=Oe(t.sql);if(o?.type==="SHOW_VERSIONS"){let c=await i.listVersions(o.table);r={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:c.length,data:{version:new Float64Array(c.map(a=>a.version)),timestamp:c.map(a=>new Date(a.timestamp).toISOString()),operation:c.map(a=>a.operation),rowCount:new Float64Array(c.map(a=>a.rowCount))}}}else if(o?.type==="RESTORE_TABLE"){let c=await i.restoreToVersion(o.table,o.version);r={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([c.newVersion])}}}else if(o?.type==="SELECT_VERSION"){let c=await i.selectAtVersion(o.table,o.version,{});if(c.length>0){let a=Object.keys(c[0]),l={};for(let f of a)l[f]=c.map(u=>u[f]);r={_format:"columnar",columns:a,rowCount:c.length,data:l}}else r={_format:"columnar",columns:[],rowCount:0,data:{}}}else r=await Ve(i,t.sql);if(r&&r._format==="columnar"&&r.rowCount>=1e5){let c=De++;ie.set(c,r),r={_format:"cursor",cursorId:c,columns:r.columns,rowCount:r.rowCount}}}else if(s==="cursor:fetch"){let i=ie.get(t.cursorId);if(!i)throw new Error("Cursor not found");r=i,ie.delete(t.cursorId)}else if(s==="db:flush")console.log(`[LanceQLWorker] db:flush ${t.db}`),await(await x(t.db)).flush(),console.log(`[LanceQLWorker] db:flush ${t.db} done`),r=!0;else if(s==="db:compact")r=await(await x(t.db)).compact();else if(s==="db:listTables")r=(await x(t.db)).listTables();else if(s==="db:getTable")r=(await x(t.db)).getTable(t.tableName);else if(s==="db:scanStart")r=await(await x(t.db)).scanStart(t.tableName,t.options);else if(s==="db:scanNext")r=(await x(t.db)).scanNext(t.streamId);else if(s==="db:listVersions")r=await(await x(t.db)).listVersions(t.tableName);else if(s==="db:selectAtVersion"){let i=await x(t.db),o={...t.options};t.where&&(o.where=c=>evalWhere(t.where,c)),r=await i.selectAtVersion(t.tableName,t.version,o)}else if(s==="db:restoreTable")r=await(await x(t.db)).restoreToVersion(t.tableName,t.version);else if(s==="vault:open")await P(t.encryption),r=!0;else if(s==="vault:get")r=await(await P()).get(t.key);else if(s==="vault:set")await(await P()).set(t.key,t.value),r=!0;else if(s==="vault:delete")await(await P()).delete(t.key),r=!0;else if(s==="vault:keys")r=await(await P()).keys();else if(s==="vault:has")r=await(await P()).has(t.key);else if(s==="vault:exec"){let o=(await P())._db,c=Oe(t.sql);if(c?.type==="SHOW_VERSIONS"){let a=await o.listVersions(c.table);r={_format:"columnar",columns:["version","timestamp","operation","rowCount"],rowCount:a.length,data:{version:new Float64Array(a.map(l=>l.version)),timestamp:a.map(l=>new Date(l.timestamp).toISOString()),operation:a.map(l=>l.operation),rowCount:new Float64Array(a.map(l=>l.rowCount))}}}else if(c?.type==="RESTORE_TABLE"){let a=await o.restoreToVersion(c.table,c.version);r={_format:"columnar",columns:["status","newVersion"],rowCount:1,data:{status:["restored"],newVersion:new Float64Array([a.newVersion])}}}else if(c?.type==="SELECT_VERSION"){let a=await o.selectAtVersion(c.table,c.version,{});if(a.length>0){let l=Object.keys(a[0]),f={};for(let u of l)f[u]=a.map(m=>m[u]);r={_format:"columnar",columns:l,rowCount:a.length,data:f}}else r={_format:"columnar",columns:[],rowCount:0,data:{}}}else r=await Ve(o,t.sql);if(r&&r._format==="columnar"&&r.rowCount>=1e5){let a=De++;ie.set(a,r),r={_format:"cursor",cursorId:a,columns:r.columns,rowCount:r.rowCount}}}else throw new Error(`Unknown method: ${s}`);Ze(h,n,r)}catch(r){h.postMessage({id:n,error:r.stack||r.message})}}var Xe=typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope;Xe?self.onconnect=h=>{let e=h.ports[0];Be.add(e),e.onmessage=n=>{ke(e,n.data)},e.onmessageerror=n=>{console.error("[LanceQLWorker] Message error:",n)},X().then(()=>{e.postMessage({type:"ready"})}).catch(n=>{console.error("[LanceQLWorker] Failed to load WASM:",n),e.postMessage({type:"ready",error:"WASM load failed"})}),e.start(),console.log("[LanceQLWorker] New connection, total ports:",Be.size)}:(self.onmessage=h=>{ke(self,h.data)},X().then(()=>{self.postMessage({type:"ready"})}).catch(h=>{console.error("[LanceQLWorker] Failed to load WASM:",h),self.postMessage({type:"ready",error:"WASM load failed"})}));console.log("[LanceQLWorker] Initialized");export{Ct as closeOPFSFile,k as getWasm,M as getWasmMemory,Et as loadFragmentToWasm,Ge as registerOPFSFile,Ft as wasmAggregate};
//# sourceMappingURL=lanceql-worker.js.map
